# 第十一章 测试概述

测试是编程的一部分。事实上，当你第一次编写计算机程序时，你肯定会将一些样本数据作为输入写入计算机程序，来观测它是否如你所期望的那样运行。很长一段时间以来，软件测试的测试过程都显得非常类似，很大程度上是手动进行的并且容易出错。然而，自21世纪初以来，软件行业的测试方法发生了巨大的变化，以应对现代软件系统的规模和复杂性。这一演变的核心是开发驱动的自动化测试实践。

自动化测试可以发现绝大多数漏洞并防止漏洞影响软件用户使用。在开发周期中，一个漏洞被发现的越晚，修复漏洞的代价就越大；并且在许多情况下是指数级增长的。然而，“发现漏洞”只是自动化测试的动机的一部分。你想要测试你的软件的一个相当重要的原因是支持更新换代的能力。无论是添加新功能、进行基于代码规范的代码重构，还是进行更大规模的重新设计，自动化测试都可以快速发现错误，使软件更新换代成为可能。

迭代更新速度更快的公司可以更快地适应不断变化的技术、市场条件和客户爱好。如果你有一个健壮的测试流程，你不必害怕改变 — 你可以把它作为开发软件的一个基本品质。当你越想更快更全面地改变你的系统，你就越需要一种快速的方法来测试它们。

编写测试的行为也改进了系统的设计。作为代码的第一个客户，测试可以告诉你很多关于设计选择的问题。比如，您的系统与数据库的耦合是否过于紧密？接口是否支持要求的用例？您的系统能处理所有的边缘样例吗？编写自动化测试迫使你在早期开发周期就考虑这些问题。这样做通常会导致软件更模块化，从而在以后实现更大的灵活性。

关于软件测试这个主题，已经有了很多的研究成果，而且有很好的理由: 对于这样一个重要的实践来说，做好它对许多人来说似乎仍然是一项神秘的工作。在谷歌，虽然我们已经取得了很大的进步，但我们仍然面临着使我们的流程在整个公司可靠扩展的难题。在这一章中，我们将分享一些我们所学到的东西，以帮助进一步的讨论。

## 我们为什么编写测试？

为了更好地理解如何最大限度地利用测试，让我们从头开始描述。当我们谈论自动化测试时，我们真正在谈论什么？

最简单的测试是这么定义的：

 - 只进行单个行为的测试，通常是你正在调用的方法或应用程序接口
 - 只有一个特定的输入，你传递给应用程序接口的一些数值
 - 可观察的输出或行为
 - 可控制的环境，如单个隔离过程

当你执行这样的测试，将输入传递给系统并验证输出时，你将了解系统是否如你所期望的那样运行。总的来说，数百或数千个简单的测试(通常称为测试套件)可以告诉你，你的整个产品符合预期设计的程度，更重要的是，当它不符合预期设计时，测试也会提醒你。

创建和维护一个健壮的测试套件需要真正的努力。随着代码库的增长，测试套件也会增长。它将开始面临不稳定和缓慢等挑战。如果不能解决这些问题，测试套件就会瘫痪。请记住，测试的价值来自工程师对它们的信任。如果测试成为生产力的一个阻碍，不断地引发辛劳和不确定性，工程师将失去信任，并开始寻找解决办法。一个糟糕的测试套件可能比没有测试套件更糟糕。

除了让公司能够快速制造出优秀的产品，在我们的生活中测试对于确保重要产品和服务安全至关重要。软件比以往任何时候都更加深入我们的生活，缺陷会导致很多烦恼：它们会花费大量的金钱，损失财产，或者最糟糕的是，导致我们失去美好生活。

在谷歌，我们已经确定测试不能是开发完成后的想法。关注质量和测试是我们工作的一部分。我们已经深刻地认识到，无法将质量融入我们的产品和服务不可避免地会导致糟糕的结果。因此，我们已经将测试纳入了我们工程文化的核心。

### 谷歌网络服务器的故事

在谷歌早期，工程师驱动的测试通常被认为不重要。团队经常依靠聪明的人来保证软件的正确。一些系统运行大型集成测试，但主要还是在开拓时期。一种产品似乎受到了特别严重的影响：它是谷歌网络服务器，也被称为GWS。

GWS是负责服务谷歌搜索查询的网络服务器，它对谷歌搜索的重要性不亚于机场的空中交通控制。早在2005年，随着项目规模和复杂性的膨胀，生产率急剧下降。发布变得越来越麻烦，推出它们需要越来越长的时间。团队成员在对服务进行更改时信心不足，并且通常只有在功能停止工作时才发现有问题。(另一点，超过80%的生产推送包含影响用户的漏洞，这些漏洞必须回滚。)

为了解决这些问题，GWS的技术负责人(TL)决定制定一项由工程师驱动的自动化测试政策。作为该策略的一部分，所有新的代码更改都需要包含测试，并且这些测试将持续运行。在制定这项政策的一年内，紧急推送的数量减少了一半。尽管该项目每个季度都有创纪录的变化，但这种减少还是发生了。即使面对前所未有的增长和变化，测试也给谷歌最关键的项目带来了新的生产力和信心。今天，GWS有成千上万的测试，并且几乎每天都发布只有相对较少的客户可见的漏洞。

GWS的变化标志着谷歌测试文化的分水岭，因为公司其他部门的团队看到了测试的好处，并采取了类似的策略。

GWS的经历告诉我们的一个关键观点是你不能仅仅依靠程序员的能力来避免产品缺陷。即使每个工程师只编写很少的错误，当你有足够的人在同一个项目上工作时，你将被不断增长的缺陷清单淹没。想象一个100人的团队，他们的工程师非常优秀，每个人每个月只写一个漏洞。总体来说，这群了不起的工程师每个工作日仍然会产生五个新的漏洞。更糟糕的是，在一个复杂的系统中，修复一个错误往往会导致另一个错误，因为工程师可能基于已知的错误并编写接下来的代码。

最好的团队会想办法将成员的集体智慧转化为整个团队的利益。这正是自动化测试所做的。在团队中的一个工程师编写了一个测试后，它被添加到其他人可用的公共资源池中。团队中的其他每个人现在都可以运行测试，并且当它检测到问题时将会受益。与此形成对比的是基于调试的方法，在这种方法中，每次错误发生时，工程师都必须花费用调试器深入调查的开销。工程资源的成本日以继夜投入，这是GWS能够扭转其命运的根本原因。

### 以现代化发展的速度进行测试

软件系统变得越来越大，越来越复杂。谷歌的典型应用程序或服务由数千或数百万行代码组成。它使用各种库或框架，通过不可靠的网络交付给越来越多的平台，这些平台运行着无数的配置。更糟糕的是，新版本频繁被推送给用户，甚至有时一天多次。这与一年只更新一两次的安装包包装软件的世界相去甚远。

人类手动验证系统中每个功能的能力已经跟不上大多数软件中功能和平台的爆炸式增长。想象一下手动测试谷歌搜索的所有功能需要什么，例如寻找航班、电影时间、相关图像，当然还有网络搜索结果(见图11-1)。即使你能确定如何解决这个问题，你也需要将这个工作量乘以谷歌搜索必须支持的每种语言、国家和设备，并且不要忘记检查可访问性和安全性。试图通过要求人们手动与每一个特征交互来评估产品质量是不可行的。谈到测试，有一个明确的答案可以实现这一点：自动化。
![image-20210428183927257](https://gitee.com/yyjjtt/picture_bed/raw/master/img/image-20210428183927257.png)

### 编程，运行，反应

在其最纯粹的形式中，自动化测试由三个活动组成：编写测试、运行测试和对测试失败做出反应。自动化测试是一小段代码，通常是一个单独的函数或方法，它调用你想要测试的更大系统的一个独立部分。测试代码建立一个预期的环境，调用系统，通常使用一个已知的输入，并验证结果。有些测试非常小，使用单一的代码路径；另一些测试要大得多，可能涉及整个系统，比如移动操作系统或网络浏览器。

示例 11-1展示了一个谨慎的用Java进行的简单测试，不使用框架或测试库。这并不是你编写整个测试套件的方式，但是在它的核心，每个自动化测试看起来都类似于这个非常简单的例子。

*示例 11-1.一个简单的测试*

```java
// 验证计算机类可以处理一个负的结果
public void main(String[] args) {
   Calculator calculator = new Calculator();
   int expectedResult = -3;
   int actualResult = calculator.subtract(2, 5); // Given 2, Subtracts 5.
   assert(expectedResult == actualResult);
}
```

与过去的质量保证过程不同，在过去的质量保证过程中，专门的软件测试人员仔细研究系统的新版本，测试每一种可能的行为，今天构建系统的工程师在为他们自己的代码编写和运行自动化测试方面发挥着积极和不可或缺的作用。即使在质量保证是一个部门的公司里，开发人员编写测试也很常见。以当今系统开发的速度和规模，唯一的方法是让整个工程人员共享测试的开发。

当然，写测试和写好测试是不同的。培养成千上万的工程师来编写好的测试可能相当困难。我们将在接下来的章节中讨论我们所学到的关于编写好的测试的知识。

编写测试只是自动化测试过程的第一步。写完测试后，你需要运行它们。自动化测试其核心包括一遍又一遍地重复相同的动作，只有在出现故障时才需要人工注意。我们将在第23章讨论这种持续集成和测试。通过将测试表示为代码，而不是手动的一系列步骤，我们可以在每次代码更改时运行它们—很容易每天就能运行数千次。与人类测试人员不同，机器永远不会疲劳或厌倦。

将测试表示为代码的另一个好处是，很容易将它们模块化，以便在各种环境中执行。只要你已经为这两个系统进行了配置，在谷歌中进行了谷歌邮件测试就不需要在火狐中测试谷歌邮件花销更多的资源。可以使用与英语相同的测试代码来运行日语或德语用户界面的测试。

正在积极开发的产品和服务将不可避免地经历测试失败。真正使测试过程有效的是它如何解决测试失败。允许失败的测试快速堆积会破坏它们提供的任何价值，所以绝对不能让这种情况发生。优先在失败后几分钟内修复失败测试的团队能够保持高信心和快速的故障隔离，因此从他们的测试中可以获得更多的价值。

总之，健康的自动化测试文化鼓励每个人分享编写的测试。这样的文化也确保了测试的定期运行。最后，也可能是最重要的，它强调快速修复失败的测试以便在过程中保持高度的信心。

### 测试代码的好处

对于来自没有强大测试文化的组织的开发人员来说，将编写测试作为提高生产率和速度的一种手段的想法似乎是对立的。毕竟，与实现一个功能首先要做的事情相比，编写测试的行为可能需要同样长的时间(甚至更长！)。相反，在谷歌，我们发现投资软件测试对开发人员的工作效率有几个主要好处：

*__更少的调试__*  
正如你所期望的那样，测试过的代码在提交时缺陷较少。关键是，它在整个存在过程中也有较少的缺陷；他们中的大多数缺陷会在提交代码之前被抓住。谷歌的一段代码预计在被完全弃用前会被修改几十次。它将被其他团队甚至自动化代码维护系统所改变。一次编写的测试将继续带来回报，并在项目的整个生命周期中防止代价高昂的缺陷和烦人的调试会话。同时可以通过测试基础结构快速检测出破坏测试的项目更改或项目的依存关系，并在问题发布到生产环境之前回滚。

*__增强对变更的信心__*  
所有软件变更。具有良好测试的团队可以自信地评审和接受他们项目的变更，因为他们项目的所有重要行为都被不断地验证。这样的项目鼓励重构。在保留现有行为的同时重构代码的更改（理想情况下）应不需要更改现有测试。

*__改良的文档__*  
软件文档是出了名的不可靠。从过时的需求到缺失的边缘情况，文档与代码之间的关系很脆弱是很常见的。清晰、集中的测试，一次测试一个行为，起到可执行文档的作用。如果你想知道代码在特定情况下做什么，请查看该情况下的测试。更好的是，当需求改变并且新代码破坏了现有的测试时，我们得到了一个明确的信号，即“文档化”现在已经过时了。请注意，只有在注意保持测试清晰和简洁的情况下，测试作为文档才最有效。

*__更简单的审查__*  
谷歌的所有代码都要经过至少一名其他工程师的审查，然后才能提交(详见第9章)。如果代码审查包括证明代码正确性、边缘情况和错误条件的全面测试，则代码审查人员在验证代码是否如预期那样工作方面花费的精力较少。审查者可以验证每个案例都通过了测试，而不是在精神上遍历每个案例所需要的繁琐工作。

*__周到的设计__*
为新代码编写测试是练习代码本身的接口设计的一种实用方法。如果新代码难以测试，通常是因为被测试的代码有太多的分支或者难以管理的依赖关系。设计良好的代码应该是模块化的，避免紧密耦合，专注于特定的责任。尽早解决设计问题通常意味着以后更少的返工。

*__快速、高质量的发布__*    
有了一个健康的自动化测试套件，团队可以放心地发布他们应用程序的新版本。谷歌的许多项目每天都会发布一个新的生产版本—甚至是每天都有数百名工程师和数千条代码变更提交的大型项目。没有自动化测试，这是不可能的。

## 设计一个测试套件

今天，谷歌以巨大的规模运作着，但我们并不总是如此庞大，我们方法的基础在很久以前就奠定了。多年来，随着我们代码库的增长，通过不断出错纠错,我们学到了很多关于如何设计和执行测试套件的方法。
我们很早就得出的一个经验使工程师们喜欢写较大的、系统级规模的测试，但这些测试比小的测试更慢、更不可靠、更难调试。工程师们厌倦了对系统级规模测试的调试，他们问自己，"为什么我们不能一次只测试一台服务器？"或者，"为什么我们需要一次测试整个服务器？我们可以单独测试较小的模块"。最终，减少痛苦的愿望导致团队开发出越来越小的测试，结果是更快，更稳定，而且一般来说不那么痛苦。
这导致了公司内部对 "小 "的确切含义的大量讨论。小是指单元测试吗？那集成测试呢，是什么规模？我们得出的结论是，每个测试案例都有两个不同的维度：规模和范围。规模是指运行一个测试用例所需的资源：如内存、进程和时间。范围指的是我们要验证的具体代码路径。请注意，执行一行代码与验证它是否按预期工作是不同的。规模和范围是相互关联但不同的概念。

### 测试规模

在谷歌，我们把每一个测试都归为一个规模，并鼓励工程师总是为一个给定的功能编写尽可能小的测试。一个测试的规模不是由它的代码行数决定的，而是由它的运行方式、它被允许做什么以及它消耗多少资源决定的。事实上，在某些情况下，我们对小、中、大的定义实际上被编码为测试基础设施可以在测试上执行的约束。我们稍后会讨论这些细节，但简而言之，小型测试在单个进程中运行，中型测试在单个机器上运行，而大型测试则在任何地方运行，如图 11-2 所示。

![image-20210425225744858](https://gitee.com//yyjjtt/picture_bed/raw/master/img/20210425225752.png)

我们做出这样的区分，而不是更传统的 "单元 "或 "集成"，因为我们希望从我们的测试套件中得到的最重要的品质是速度和确定性，这与测试的范围如何无关。小型测试，无论范围如何，几乎总是比涉及更多基础设施或消耗更多资源的测试更快、更有确定性。对小型测试施加限制，使速度和确定性更容易实现。随着测试规模的增长，许多限制都被放松了。中型测试有更多的灵活性，但也有更多的非确定性的风险。较大的测试只保存在最复杂和困难的测试场景中。让我们仔细看看对每种类型的测试施加的确切限制。

#### 小型测试

小型测试是三种测试规模中最受限制的。主要的约束是，小测试必须在一个进程中运行。在许多语言中，我们甚至进一步限制，说它们必须在一个单线程上运行。这意味着执行测试的代码必须与被测试的代码在同一进程中运行。你不能运行一个服务器，而让一个单独的测试进程连接到它。这也意味着你不能运行第三方程序，如让数据库作为你测试的一部分。

对小型测试的其他重要限制是，他们不允许睡眠，执行I/O操作，或进行任何其他阻塞性调用。这意味着，小测试不允许访问网络或磁盘。测试依赖这类操作的代码需要使用测试替代（见第13章），用轻量级的进程内依赖取代重量级依赖。

这些限制的目的是确保小的测试不能接触到测试速度慢或不确定性的主要来源。一个在单个进程上运行并且从不进行阻塞调用的测试可以有效地运行到CPU可以处理的最快速度。很难（但肯定不是不可能）意外地使这样的测试变得缓慢或不确定。对小型测试的限制提供了一个沙盒，防止工程师们自寻烦恼。

这些限制一开始可能看起来很过分，但考虑到一个由几百个小测试案例组成的适度的套件在一天中运行。如果其中有几个非确定性地失败（通常被称为flaky test），追踪原因就会成为生产力的严重消耗。在谷歌的规模下，这样的问题会使我们的测试基础设施陷入停顿。

在Google，我们鼓励工程师尽可能地编写小型测试，不管测试的范围如何，因为这样可以保持整个测试套件快速可靠地运行。关于小型测试与单元测试的更多讨论，见第12章。

#### 中型测试

对于许多有趣的测试来说，对小型测试的限制可能过于严格。测试规模的下一个阶梯是中型测试。中型测试可以跨越多个进程，使用线程，并可以进行阻塞性调用，包括网络调用localhost。剩下的唯一限制是，中型测试不允许对 localhost 以外的任何系统进行网络调用。换句话说，测试必须包含在一台机器内。

运行多个进程的能力开辟了很多可能性。例如，你可以运行一个数据库实例，以验证你正在测试的代码在一个更现实的环境中正确集成。或者你可以测试网络用户界面和服务器代码的组合。网络应用程序的测试经常涉及到像WebDriver这样的工具，它可以启动一个真正的浏览器，并通过测试过程远程控制它。

不幸的是，随着灵活性的增加，测试变得缓慢和不确定的可能性也在增加。跨进程的测试或被允许进行阻塞调用的测试依赖于操作系统和第三方进程的快速和确定性，这在一般情况下我们是无法保证的。中等测试仍然通过防止通过网络访问远程机器来提供一些保护，而网络是大多数系统中速度慢和非确定性的最大来源。尽管如此，在编写中型测试时，"安全 "是关闭的，工程师需要更加小心。

#### 大型测试

最后，我们有大型测试。大型测试取消了对中型测试的本地主机限制，允许测试和被测系统跨越多台机器。例如，测试可能针对远程集群中的系统运行。

和以前一样，灵活性的增加伴随着风险的增加。与在单台机器上运行相比，必须处理一个跨越多台机器和连接它们的网络的系统，大大增加了速度慢和不确定的机会。我们大多将大型测试保留给全系统的端到端测试，这些测试更多的是验证配置而不是代码片断，以及测试那些不可能使用测试替代的遗留组件。我们将在第14章讨论更多关于大型测试的用例。谷歌的团队经常将他们的大型测试与小型或中型测试隔离开来，只在构建和发布过程中运行，以免影响开发人员的工作流程。

**案例学习:flaky test是昂贵的**

如果你有几千个测试，每个测试都有非常小的非确定性，整天运行，偶尔会有一个可能会失败（flaky）。随着测试数量的增加，从统计学上看，flaky的数量也会增加。如果每个测试都有0.1%的失败率，而你每天运行10,000个测试，你每天将调查10个flaky。每次调查都会占用你的团队可以做的更有成效的事情的时间。

在某些情况下，你可以通过在测试失败时自动重新运行它们来限制故障测试的影响。这实际上是用CPU周期换取工程时间。在低水平的不稳定情况下，这种权衡是有意义的。只要记住，重新运行测试只是推迟了解决故障根源的需要。

如果测试松散性继续增长，你将经历比生产力损失更糟糕的事情：对测试失去信心。在一个团队失去对测试套件的信任之前，并不需要调查许多缺陷。发生这种情况后，工程师将停止对测试失败的反应，消除测试套件提供的任何价值。我们的经验表明，当你接近1%的flaky率时，测试开始失去价值。在谷歌，我们的失误率徘徊在0.15%左右，这意味着每天有成千上万的失误。我们努力控制flaky，包括积极投入工程时间来修复片断。

在大多数情况下，flaky的出现是因为测试本身的非确定性行为。软件提供了许多非确定性的来源：时钟时间、线程调度、网络延迟，等等。学习如何隔离和稳定随机性的影响并不容易。有时，影响与硬件中断或浏览器渲染引擎等低级别的问题联系在一起。一个好的自动化测试基础设施应该帮助工程师识别和缓解任何非确定性行为。

**所有测试规模的共同属性**

所有的测试都应该努力做到密封性：一个测试应该包含所有必要的信息来设置、执行和关闭其环境。测试应该尽可能少地假设外部环境，如测试的运行顺序。例如，他们不应该依赖共享数据库。这种限制在大型测试中变得更加具有挑战性，但仍应努力确保隔离。

一个测试应该只包含行使有关行为所需的信息。保持测试的清晰和简单，有助于审查者验证代码是否做了它所说的事情。清晰的代码也有助于在失败时诊断失败。我们喜欢说，"测试应该在检查时是明显的"。因为没有对测试本身的测试，所以需要人工审查作为对正确性的重要检查。作为一个推论，我们也**强烈不鼓励在测试中使用控制流语句，如条件语句和循环语句**。更加复杂的测试流程有可能包含错误本身，并使确定测试失败的原因更加困难。

请记住，测试通常只有在发生故障时才会被重新审视。当你被要求修复一个你以前从未见过的坏掉的测试时，你会感谢有人花时间使它变得容易理解。代码被阅读的次数远远多于被写的次数，所以要确保你写的测试是你想读的

**实践中的测试规模**。有了测试规模的精确定义，我们就可以创建工具来强制执行它们。强制执行使我们能够扩展我们的测试套件，并且仍然能够对速度、资源利用率和稳定性做出一定的保证。在谷歌，这些定义的执行程度因语言而异。例如，我们使用一个自定义的安全管理器来运行所有的Java测试，如果它们试图做一些被禁止的事情，如建立网络连接，就会导致所有被标记为小的测试失败。

### 测试范围

尽管我们在谷歌非常强调测试规模，但另一个需要考虑的重要属性是测试范围。测试范围是指一个特定的测试要验证多少代码。狭窄范围的测试（通常称为 "单元测试"）被设计用来验证代码库中一小部分的逻辑，比如一个单独的类或方法。中等范围的测试（通常称为集成测试）是为了验证少量组件之间的相互作用；例如，在服务器和数据库之间。大范围的测试（通常被称为功能测试，端到端测试，或系统测试）被设计用来验证系统的几个不同部分的交互，或不在一个单一的类或方法中表达的突发行为。

值得注意的是，当我们谈论单元测试是狭义的范围时，我们指的是正在验证的代码，而不是正在执行的代码。一个类有许多依赖关系或它引用的其他类是很常见的，这些依赖关系在测试目标类时自然会被调用。尽管其他一些测试策略大量使用了测试替代（fakes或mocks）来避免执行被测系统之外的代码，但在Google，在可行的情况下，我们更愿意保持真正的依赖关系。第13章更详细地讨论了这个问题。

狭窄范围的测试往往是小型的，而广泛范围的测试往往是中型或大型的，但这并不总是这样的。例如，有可能对一个服务器端点写一个大范围的测试，包括所有正常的解析、请求验证和业务逻辑，但这是小范围的，因为它用双倍数来代替所有进程外的依赖，如数据库或文件系统。同样的，也可以对一个单一的方法写一个狭义的测试，但必须是中等规模的。例如，现代网络框架经常将HTML和JavaScript捆绑在一起，测试一个UI组件，如日期选择器，往往需要运行整个浏览器，甚至验证一个单一的代码路径。

就像我们鼓励小规模的测试一样，在谷歌，我们也鼓励工程师编写范围较小的测试。作为一个非常粗略的指导原则，我们倾向于将80%的测试混合为狭义的单元测试，以验证大部分的业务逻辑；15%的中等范围的集成测试，以验证两个或多个组件之间的交互；以及5%的端到端测试，以验证整个系统。图11-3描述了我们如何以金字塔的形式来看待这个问题。

![image-20210425230552428](https://gitee.com//yyjjtt/picture_bed/raw/master/img/20210425230552.png)

单元测试是一个很好的基础，因为它们快速、稳定，并且极大地缩小了范围，减少了识别一个类或函数的所有可能行为所需的认知负荷。此外，它们使故障诊断变得快速而无痛。需要注意的两个反模式是 "冰激凌锥 "和 "沙漏"，如图11-4所示。

在冰激凌锥中，工程师们写了许多端到端的测试，但很少有集成或单元测试。这样的测试套件往往是缓慢的、不可靠的、难以操作的。这种模式经常出现在那些以原型开始的项目中，并迅速赶往生产，从来没有停止过解决测试的债务。

沙漏涉及许多端到端测试和许多单元测试，但很少有集成测试。它不像冰激凌锥那样糟糕，但它仍然导致许多端到端的测试失败，而这些失败本可以通过一套中等范围的测试更快、更容易地发现。沙漏模式发生在紧耦合使其难以孤立地实例化单个依赖关系的时候。

![image-20210425230623312](https://gitee.com//yyjjtt/picture_bed/raw/master/img/20210425230623.png)

我们推荐的测试组合是由我们的两个主要目标决定的：工程生产力和产品信心。在开发过程的早期，倾向于单元测试可以让我们迅速获得高的信心。在产品的开发过程中，大型测试作为理智的检查；它们不应该被看作是捕捉错误的主要方法。

当考虑你自己的组合时，你可能想要一个不同的平衡。如果你强调集成测试，你可能会发现你的测试套件需要更长的时间来运行，但在组件之间捕获更多的问题。当你强调单元测试时，你的测试套件可以很快完成，而且你会捕捉到许多常见的逻辑错误。但是，单元测试不能验证组件之间的相互作用，就像不同团队开发的两个系统之间的合同。一个好的测试套件包含不同的测试规模和范围的混合，适合于当地的架构和组织的实际情况。

### 碧昂斯规则

在指导新员工时，我们经常被问到，哪些行为或属性实际上需要被测试？直截了当的回答是：测试所有你不想破坏的东西。换句话说，如果你想确信一个系统表现出一个特定的行为，唯一的方法就是为它写一个自动化测试。这包括所有常见的嫌疑人，如测试性能、行为正确性、可及性和安全性。它还包括不太明显的属性，如测试系统如何处理故障。

我们对这一总体理念有一个名称：我们称之为碧昂斯规则。简而言之，它可以被陈述如下。"如果你喜欢它，那么你应该对它进行测试"。碧昂斯法则经常被负责对整个代码库进行修改的基础设施团队所引用。如果不相关的基础设施变化通过了你的所有测试，但仍然破坏了你的团队的产品，你就要负责修复它并增加额外的测试。

#### 失败的测试

一个系统必须考虑的最重要的情况之一是失败。失败是不可避免的，但是等待真正的灾难来发现系统对灾难的反应如何，是非常痛苦的。与其等待失败，不如写自动测试来模拟常见的失败类型。这包括在单元测试中模拟异常或错误，在集成和端到端测试中注入远程过程调用（RPC）错误或延迟。它还可以包括使用混沌工程等技术模拟对真实生产网络的巨大破坏。对不利条件的可预测和可控制的反应是一个可靠系统的标志。

### 关于代码覆盖率的说明

代码覆盖率是衡量哪些特征代码行被哪些测试所执行。如果你有100行代码，你的测试执行了其中的90行，你就有90%的代码覆盖率。
代码覆盖率经常被认为是理解测试质量的黄金标准指标，这一点是很不幸的。有可能用一些测试来锻炼大量的代码行，但从未检查过每一行是否在做任何有用的事情。这是因为代码覆盖率只衡量一行被调用的情况，而不是结果。（我们建议只测量小型测试的覆盖率，以避免执行大型测试时出现覆盖率膨胀）。

代码覆盖率的一个更隐蔽的问题是，像其他指标一样，它很快就变成了一个单独的目标。对于团队来说，建立一个预期的代码覆盖率标准是很常见的，例如，80%。起初，这听起来非常合理；你肯定希望至少有这么多的覆盖率。在实践中，发生的情况是，工程师们不是把80%当作一个底线，而是把它当作一个上限。很快，变化就开始了，覆盖率不超过80%。毕竟，为什么要做比指标要求更多的工作？

接近你的测试套件质量的一个更好的方法是思考被测试的行为。你有信心你的客户所期望的一切都能正常工作吗？你是否有信心能抓住你的依赖关系中的突发变化？你的测试是否稳定和可靠？像这样的问题是思考测试套件的一种更全面的方式。每个产品和团队都是不同的；有些会有难以测试的与硬件的交互，有些涉及到大量的数据集。试图用一个单一的数字来回答 "我们有足够的测试吗？"忽略了很多背景，不太可能是有用的。代码覆盖率可以提供一些对未测试代码的洞察力，但它不能替代对系统测试情况的批判性思考。

## 谷歌规模测试
这一点的大部分指导可以应用于几乎任何大小的代码库。然而，在非常大规模的测试中，我们应该花一些时间在我们所学到的东西上。要了解谷歌的测试工作原理，需要先了解我们的开发环境，谷歌的大部分代码都保存在一个单一的单片存储库（monorepo）中。这一点的大部分指导可以应用于几乎任何大小的代码库。然而，我们应该花一些时间在我们所学到的东西上，在我们非常大规模的测试中。要了解谷歌的测试工作原理，您需要了解我们的开发环境，其中最重要的事实是谷歌的大部分代码都保存在一个单一的单片存储库（monorepo）中。几乎我们经营的每一种产品和服务的每一行代码都存储在一个地方。如今，我们的存储库中已有20多亿行代码。

谷歌的代码库每周经历近2500万行的变化。其中大约一半是由在monorepo工作的数以万计的工程师完成的，另一半则是自动化系统配置更新或大规模更改（第22章）。其中许多更改都是从直接项目外部发起的。我们对工程师重用代码的能力没有太多限制。

我们代码库的开放性鼓励了一定程度的共同所有权，让每个人都对代码库负责。这种开放性的一个好处是能够直接修复您所使用的产品或服务中的错误（当然需要获得批准），而不仅仅是只能抱怨。这也意味着许多人将对其他人拥有的代码库的一部分进行更改。

另一件让谷歌有些不同的事情是，几乎没有团队使用存储库分支。所有更改都提交到存储库头部，并立即对每个人可见。此外，所有的软件构建都是使用最新版本的测试工具来执行的。构建产品或服务时，运行它所需的几乎所有依赖项都是从源代码构建的，也就是从存储库的头部构建的。谷歌通过使用CI系统来管理这种规模的测试。我们的CI系统的关键组件之一是我们的自动化测试平台（TAP）。有关TAP和CI理念的更多信息，请参阅第23章。


无论你是考虑到我们的规模，我们的monorepo，还是我们提供的产品数量，谷歌的工程环境都是复杂的。每周它都会经历数以百万计的换行、数十亿个测试用例的运行、数以万计的二进制文件的构建、数以百计的产品的更新，这些都很复杂！

## 大型测试套件的缺陷
随着代码库的增长，您将不可避免地需要对现有代码进行更改。如果编写得不好，自动化测试会使进行这些更新变得更加困难。脆性测试实际上是可以阻碍更新的，指那些过度明确预期结果或依赖于广泛而复杂的样板的测试。即使做出了不相关的更改，不好的编程测试也可能失败。

如果你曾经对一个特征做了五行的更改，却发现了几十个不相关的、不完整的测试，那么你已经感受到了脆性测试的问题。随着时间的推移，这种问题会使团队不愿执行必要的重构来保持代码库的健康。接下来的章节将介绍一些策略，您可以使用这些策略来提高测试的鲁棒性和质量。

脆性测试中一些最严重的违规者来自于对模拟对象的滥用。谷歌的代码库因为滥用模拟框架而遭受了严重的损失，以至于一些工程师宣布“绝不再有模拟！”尽管这是一个强有力的声明，但了解模拟对象的限制有助于避免误用它们。

有关有效使用模拟对象的更多信息，请参见第13章。

除了脆性试验引起的问题外，更大的试验组运行速度也会更慢。测试套件的速度越慢，运行的频率就越低，提供的好处就越少。我们使用了许多技术来加速我们的测试套件，包括并行执行和使用更快的硬件。然而，这些技巧最终会被大量单个缓慢的测试用例拖垮。

测试可能会因为许多原因而变得缓慢，比如启动系统的核心部分、在执行前启动模拟器、处理大型数据集或等待不同的系统同步。测试通常启动得足够快，但随着系统的增长，速度会减慢。例如，您可能有一个集成测试执行一个依赖项，需要5秒钟才能响应，但是随着时间的推移，您逐渐依赖于十几个服务，那么现在相同的测试就需要5分钟。

由于sleep()和setTimeout()等函数引入了不必要的速度限制，测试也会变得很慢。在检查不确定性行为的结果之前，对这些函数的调用通常被用作简单的启发式方法。在这里或那里暂停半秒钟一开始似乎并不太危险；然而，如果在一个广泛使用的实用程序中嵌入了“等待并检查”，那么很快您就为测试套件的每次运行增加了几分钟的空闲时间。更好的解决方案是主动轮询频率接近微秒的状态转换。如果测试无法达到稳定状态，可以将其与超时限结合使用。

如果不能保证测试套件的确定性和快速性，那么它将成为生产力的障碍。在谷歌，遇到这些测试的工程师们已经找到了解决缓慢问题的方法，有些工程师甚至在提交更改时完全跳过了测试。显然，这是一种危险的做法，应该加以劝阻，但如果一个测试套件是弊大于利，最终工程师会找到一种方法来完成他们的工作，测试或不测试。

与大型测试套件友好共处的秘诀是要尊重它。激励工程师关心他们的测试；奖励他们坚持做测试，就像对待一个伟大的功能启动。设定适当的性能目标，缓慢重构或做边缘测试。基本上，将测试视为生产代码。当简单的更新开始占用大量的时间时，花点精力让测试不那么麻烦。

除了发展适当的文化之外，还可以通过开发linter、文档或其他避免写出糟糕的测试的方法来投资于您的测试工具。减少需要支持的框架和工具的数量，以提高改进工作所需时间的效率。如果不采取措施简化测试管理，工程师最终会认为根本不需要它们。

## 谷歌的测试历史
既然我们已经讨论了谷歌是如何进行测试的，那么了解一下我们是如何做到这一点可能会有所启发。如前所述，谷歌的工程师并不总是接受自动化测试的价值。事实上，直到2005年，测试更像是一种好奇心，而不是一种有纪律的做法。如果真的要测试的话，大多数测试也都是手工完成的。然而，从2005年到2006年，发生了一场测试革命，改变了我们处理软件工程的方式。至今仍影响着公司。

我们在本章开头讨论的GWS项目的经验起到了催化剂的作用。它清楚地表明了自动化测试有多强大。在2005年对GWS进行了改进之后，这些做法开始在整个公司蔓延开来。工具很原始。然而，这些自称谷歌测试小组的志愿者们并没有因此而放慢脚步。

三个关键的举措帮助公司意识到自动化测试的重要性：定向课程、测试认证计划和马桶测试。每一个都有着完全不同的影响，他们一起重塑了谷歌的工程文化。

### 入职培训班
尽管谷歌早期的工程人员大多回避测试，但谷歌自动化测试的先驱们知道，以公司的发展速度，新工程师的数量将很快超过现有的团队成员。如果他们能接触到公司所有的新员工，这将是一个非常有效的引入文化变革的途径。幸运的是，过去和现在，所有新的工程人员都要经历一个历程：培训。

谷歌早期的培训项目大多涉及医疗福利和谷歌搜索的工作原理等方面，但从2005年开始，它还开始包括一个小时的自动测试价值讨论。<sup>9</sup>该课程涵盖了测试的各种好处，如提高生产力、更好的文档，以及对重构的支持。它还包括如何编写一个好的测试。对于当时的许多Noogler（新谷歌用户）来说，这样的课程是他们第一次接触到这种材料。最重要的是，所有这些想法都是公司的标准做法。新员工不知道他们被用作特洛伊木马，把这个想法偷偷带进他们毫无戒备的团队。

当Nooglers加入他们的团队时，他们开始写测试并询问那些不写测试的人。在短短一两年内，接受过测试教学的工程师人数就超过了预先测试文化的工程师。因此，许多新项目一开始就进展顺利。

测试现在在行业中得到了更广泛的应用，因此大多数新员工的到来都带着对自动化测试的期望。尽管如此，培训课程仍在继续提高对测试的期望，并将noogler在谷歌之外获得的测试知识运用在我们庞大而复杂的代码库上。

### 测试认证
最初，我们的代码库中更大更复杂的部分似乎对良好的测试实践有抵触情绪。有些项目的代码质量很差，几乎无法进行测试。为了给项目一条明确的前进道路，测试小组设计了一个他们称之为测试认证的认证程序。TestCertified旨在为团队提供一种了解其测试过程成熟度的方法，更重要的是，提供如何改进测试过程的指导用书。

该计划分为五个级别，每个级别都需要一些具体的行动来改善团队的测试整洁。这些级别的设计方式是这样的，每一个步骤都可以在四分之一部分之内完成，这使得它更适合谷歌的内部规划节奏。

测试认证级别1涵盖了基础知识：建立一个连续构建；开始跟踪代码覆盖率；把你所有的测试分为小的、中的或大的；识别（但不一定修复）片状测试；并创建一组可以快速运行的快速（不一定全面）测试。随后的每一个级别都增加了更多的挑战，如“没有中断测试的发布”或“删除所有不确定的测试”。到了第5级，所有测试都是自动化的，在每次提交之前都运行快速测试，所有不确定的测试都被删除，所有行为都被覆盖。内部仪表盘通过显示每个团队的水平来施加压力。不久之后，各队就开始互相比较进步。

到2015年，测试认证项目被自动化方法取代时（稍后会有更多关于pH的内容），它已经帮助了1500多个项目改善了他们的测试文化。

### 马桶测试
在测试小组用来改进谷歌测试的所有方法中，也许没有一种方法比如厕测试（TotT）更不寻常的了。TotT的目标相当简单：积极提高整个公司对测试的认识。问题是，在一个员工分散在世界各地的公司里，最好的方法是什么？

测试小组考虑了定期发送电子邮件时事通讯的想法，但考虑到每个人在谷歌处理的大量电子邮件，它很可能会淹没在邮件海里。经过一番头脑风暴，有人提出了在洗手间的摊位上张贴传单的想法，以此作为玩笑。我们很快就意识到了其中的天才：厕所是一个每个人每天都必须至少去一次的地方，不管发生什么。不管你开不开玩笑，这个想法的实施成本很低，因此必须加以尝试。

2006年4月，一篇关于如何改进Python测试的短文出现在谷歌的洗手间里。第一个篇章是由一小队志愿者发布的。说反应两极分化是轻描淡写的；一些人认为这是对个人空间的侵犯，他们强烈反对。邮件列表上充满了抱怨，但TotT的创建者们很满意：抱怨的人还在谈论测试。

最终，这场喧嚣平息，TotT迅速成为谷歌文化的一大支柱。迄今为止，公司所有的工程师已经制作了几百个篇章，涵盖了几乎所有可以想象的测试方面（除了其他各种技术主题）。新的篇章被热切期待，一些工程师甚至自愿在自己的建筑周围张贴这些情节。我们故意将每篇章限制在一页，使作者集中精力于最重要和最可行的建议。一个好的篇章包含了一个工程师可以立即回到办公桌上尝试的东西。

具有讽刺意味的是，对于一份出现在一个更私密的地方的出版物来说，TotT已经产生了巨大的公众影响。大多数外部访问者在访问过程中的某个时刻都会看到一个小篇章，这样的遭遇常常会引发一些有趣的对话，比如雇谷歌人似乎总是在思考代码。另外，TotT的剧集也可以写很好的博客文章，这是TotT最初的作者很早就认识到的。他们开始公开发布轻量编辑的版本，帮助我们与整个行业分享经验。

尽管开始是个笑话，TotT的运行时间最长，也是测试组所发起的任何测试计划中影响最深远的。

### 如今的测试文化
从2005年开始，如今谷歌的文化测试已经走过了漫长的道路。Noogler仍然参加测试的定向课程，TotT几乎每周都会被分发。然而，对测试的期望已经更深入地嵌入到日常的开发人员工作流程中。

谷歌的每一个代码更改都需要经过代码审查。每一个变化都将包括特性代码和测试。评审员应评审两者的质量和正确性。事实上，如果某个更改缺少测试，那么阻止它是完全合理的。

作为测试认证的替代品，我们的一个工程生产力团队最近推出了一个名为Project Health（pH）的工具。pH工具不断地收集关于项目健康状况的几十个度量，包括测试覆盖率和测试延迟，并使它们在内部可用。pH值按1（最差）到5（最佳）的比例测量。pH-1项目被视为团队需要解决的问题。几乎每个运行连续构建的团队都会自动获得pH值。

随着时间的推移，测试已经成为谷歌工程文化不可或缺的一部分。我们有无数种方法来增强它对整个公司工程师的价值。通过培训、轻推、指导，以及，是的，甚至是一点友好的竞争，我们创造了一个明确的期望，即测试是每个人的工作。

我们为什么不开始强制编写测试呢？

测试小组曾考虑过向高级领导层请求测试授权，但很快就决定反对。任何关于如何开发代码的授权都将严重违背谷歌文化，而且很可能会放慢进度，与授权的想法无关。人们相信成功的想法会传播开来，所以关注点变成了展示成功。

如果工程师们决定自己编写测试，那意味着他们已经完全接受了这个想法，即使没有人强迫他们去做，他们也可能继续做正确的事情。

### 自动化测试的局限性
自动化测试并不适用于所有的测试任务。例如，测试搜索结果的质量往往涉及到人的判断。我们进行有针对性的内部研究，使用搜索质量评分员执行真实的查询并记录他们的印象。同样，在自动测试中很难捕捉音频和视频质量的细微差别，因此我们经常使用人类的判断来评估电话或视频通话系统的性能。

除了定性的判断，还有一些创造性的评估，人们擅长于此。例如，搜索复杂的安全漏洞是人比自动化系统做得更好的事情。人在发现并理解了一个缺陷之后，它可以被添加到一个自动化的安全测试系统中，比如谷歌的云安全扫描器，在那里它可以连续、大规模地运行。

这种技术的一个更广义的术语是探索性测试。探索性测试是一种基本的创造性工作，在这种工作中，有人将被测试的应用程序视为一个待破解的难题，可能是通过执行一组意外的步骤或插入意外的数据。在进行探索性测试时，一开始就不知道要发现的具体问题。通过探测通常被忽略的代码路径或来自应用程序的异常响应，它们逐渐被发现。与安全漏洞的检测一样，一旦探索性测试发现问题，就应该添加一个自动测试以防止将来的退步。

通过使用自动化测试来覆盖被充分理解的行为，人类测试人员可以花费大量的精力和定性的工作来关注产品中他们能够提供最大价值的部分，并避免在过程中让他们厌烦到流泪。

## 结论
采用开发人员驱动的自动化测试是谷歌最具变革性的软件工程实践之一。它使我们能够用更大的团队构建更大的系统，比我们想象的更快。它帮助我们跟上了技术进步的步伐。在过去的15年里，我们成功地转变了我们的工程文化，将测试提升为一种文化规范。尽管公司自成立以来增长了近100倍，但我们对质量和测试的承诺比以往任何时候都更加坚定。

本章旨在帮助您了解谷歌如何看待测试。在接下来的几章中，我们将更深入地探讨一些关键主题，这些主题帮助我们理解编写良好、稳定和可靠的测试意味着什么。我们将讨论单元测试的内容、原因和方式，这是谷歌最常见的测试类型。我们将深入讨论如何通过伪造、存根和交互测试等技术在测试中有效地使用双重测试。最后，我们将讨论测试更大、更复杂的系统所面临的挑战，就像我们在谷歌的许多系统一样。

在这三章的结尾，你应该对我们使用的测试策略有一个更深刻更清晰的了解，更重要的是理解，我们为什么使用它们。

## TL;DRs
* 自动化测试是使软件改变的基础。
* 由于测试规模大，所以必须是自动化的。
* 平衡的测试套件对于保持健康的测试覆盖率是必要的。
* “如果你喜欢它，你应该对它进行测试。”
* 改变组织中的测试文化需要时间。