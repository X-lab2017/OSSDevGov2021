## 第二十章

# 静态分析

*Written by Caitlin Sadowski  
Edited by Lisa Carey*

静态分析是指程序对源代码进行分析以发现潜在的问题，例如错误，反面模式和其他无需执行程序即可诊断的问题。“静态”部分特指分析源代码，而不是分析正在运行的程序（称为“动态”分析）。静态分析可以在程序作为生产代码检入之前尽早发现程序中的错误。例如，静态分析可以识别到溢出的常量表达式，永不运行的测试，日志中的无效格式字符串等在执行时会崩溃的语句。<sup id="a1">[[1]](#f1)</sup> 但是，静态分析的有用之处不仅在于发现 bug。通过Google的静态分析，我们整理了最佳做法，帮助使代码与最新的 API 保持版本一致，并防止或减少了技术负担。这些分析的示例包括验证是否遵循命名约定，标记不赞成使用的 API 的使用，或者指出使代码更易于阅读的更简单但等效的表达式。静态分析也是 API 弃用过程中不可或缺的工具，可以在将代码库迁移到新 API 的过程中防止回退（请参阅 [第二十二章](../chapter22/large_scale_changes_zh.md)）。我们还发现有证据表明静态分析检查可以引导开发人员并切实地阻止反面模式进入代码库。<sup id="a2">[[2]](#f2)</sup>

在本章中，我们将研究什么是有效的静态分析，在 Google 学到的一些使静态分析更有效的经验，以及如何在静态分析工具和流程中实施。<sup id="a3">[[3]](#f3)</sup>

## 有效静态分析的特点
在开发新的分析技术和特定分析上，尽管已经有数十年的静态分析研究，但是提高静态分析工具的可扩展性和可用性的方法仍是相对前沿的发展方向。

### 可扩展性
由于现代软件已经变得越来越庞大，因此分析工具必须显式地解决扩展问题，以便及时生成结果，而不会拖慢软件开发的进度。Google 的静态分析工具必须扩展到 Google 数十亿行代码库的规模。为此，分析工具是可共享的和增量更新的。我们不会分析整个大型项目，而是将分析重点放在受代码更改影响的文件上，并且通常仅显示针对已编辑文件或行的分析结果。扩展也有好处：由于我们的代码库很大，因此在查找错误方面有很多 bug 需要查找。除了确保分析工具可以在大型代码库上运行之外，我们还必须扩大可用分析的数量和种类。面向整个公司征求分析意见。静态分析可伸缩性的另一个组件是确保流程可扩展，为此，Google静态分析基础架构通过直接向相关工程师显示分析结果来避免瓶颈分析。
### 可用性
在考虑分析可用性时，重要的是要考虑静态分析工具用户的成本和收益权衡。此“成本”可以是开发人员时间，也可以是代码质量。修复静态分析警告可能会引入错误。对于不经常修改的代码，为什么要“修复”在生产环境中运行良好的代码？ 例如，通过添加对先前无效代码的调用来修复无效代码警告，可能会导致未经测试甚至可能是错误的代码突然运行。收益不明，成本可能很高。因此，我们通常将重点放在新引入的警告上。如果工作代码特别重要（例如安全问题，重大错误修复等），则通常仅应突出显示（并修复）本来可以正常工作的代码中存在的问题。关注新引入的警告（或修改的行上的警告）还意味着查看警告的开发人员对其有相关的调用。

另外，开发人员的时间很宝贵！ 将花费在对分析报告进行分类或解决突出问题上的时间与特定分析所提供的收益进行权衡。如果分析作者可以节省时间（例如，通过提供可以自动应用于相关代码的修复程序），那么折衷的成本就会降低。可以自动修复的所有内容都应自动修复。我们还尝试向开发人员显示有关实际上对代码质量有负面影响的问题的报告，以使他们不会在无关紧要的结果上浪费时间。

为了进一步降低查看静态分析结果的成本，我们专注于平稳的开发人员工作流集成。使一个工作流程中的所有内容均质化的另一个优势是，专门的工具团队可以随工作流程和代码一起更新工具，从而使分析工具可以与源代码一起发展。

我们相信，在使静态分析具有可扩展性和可用性时，我们做出的这些选择和权衡取舍源于我们对三项核心原则的关注，这些原则将在下一节中进行阐述。

## 进行静态分析的关键经验
我们从 Google 上学到了三项关键经验，这些经验使静态分析工具能够很好地发挥作用。我们将在下文中对其进行介绍。

### 关注开发者的感受
我们提到了一些方法试图节省开发人员时间并减少与上述静态分析工具进行交互的成本。我们还将跟踪分析工具的性能。如果你不对此采取一些措施，就无法解决问题。我们只会部署误报率较低的分析工具。我们还积极地实时征询开发人员的反馈，并根据其反馈采取行动。在静态分析工具用户和开发人员之间培育这种反馈循环，会形成一个良性循环，从而建立了用户信任并改善了我们的工具。用户信任对于静态分析工具的成功至关重要。

对于静态分析，“假阴性”是指一段代码中包含分析工具旨在发现的问题，但该工具却忽略了该问题。当工具错误地将代码标记为有问题时，就会出现“误报”。传统上关于静态分析工具的研究集中在减少误报上。在实践中，低误报率对于开发人员实际使用工具通常很关键——谁想在数百个错误报告中寻找一些真实的报告呢？<sup id="a4">[[4]](#f4)</sup>

此外，用户感知是假阳性率的关键。如果静态分析工具产生的警告在技术上是正确的，但被用户误认为是误报（例如，由于混淆的消息），那么用户的反应将与这些警告实际上是误报一样。同样，在技术上正确但在总体方案中不重要的警告也会引起同样的反应。我们将用户感知的假阳性率称为“有效假阳性”率。如果开发人员在看到问题后未采取任何积极行动，则该问题为“有效误报”。这意味着，如果分析错误地报告了问题，但是开发人员仍然乐于进行修复以提高代码的可读性或可维护性，那不是有效误报。例如，我们有一个 Java 分析，当开发人员在一个哈希表上调用了 `contains` 方法（等效于 `containsValue`）时给出标记——即使开发人员打算正确地检查该值，调用 `containsValue` 会更具可读性。同样，如果分析报告存在实际故障，但是开发人员不了解该故障，因此未采取任何措施，这是有效的误报。

### 使静态分析成为核心开发人员工作流程的一部分
在 Google，我们通过与代码审查工具的集成将静态分析集成到核心工作流程中。基本上，所有代码在被提交给 Google 之前都必须经过审核； 由于开发人员在发送代码进行审查时已经处于变更思维中，因此可以进行静态分析工具建议的改进而不会造成太多干扰。代码审查集成还有其他好处， 开发人员通常在发送代码以供审阅后进行上下文切换，并被审阅者拦下——即使有几分钟的时间，分析仍然有时间运行。审阅者也面临同事的压力，要求他们解决静态分析警告。此外，静态分析可以通过自动突出显示常见问题来节省审阅者的时间； 静态分析工具可帮助代码审查过程（和审阅者）扩展。代码审查是分析结果的最佳方案。<sup id="a5">[[5]](#f5)</sup>

### 为用户贡献赋能
Google 有很多领域专家，他们的知识可以改善所生成的代码。静态分析是利用专业知识并大规模应用专业知识的机会，让领域专家编写新的分析工具或对工具中的模块单独检查。

例如，了解特定类型配置文件部分的专家可以编写分析器来检查那些文件的属性。除了领域专家之外，分析还由发现错误的开发人员提供，他们希望防止同一类型的错误再次出现在代码库的其他任何地方。我们专注于构建易于插入的静态分析生态系统，而不是集成少量现有工具。我们致力于开发简单的 API，供整个 Google 的工程师（不仅是分析人员或语言专家）用来创建分析的 API。例如，Refaster<sup id="a6">[[6] ](#f6)</sup>允许通过指定前代码段和后代码段来编写分析器，以说明该分析器期望进行哪些转换。

## Tricorder：Google 的静态分析平台
Tricorder，我们的静态分析平台，是Google静态分析的核心部分<sup id="a7">[[7]](#f7)</sup>。Tricorder 诞生自将静态分析与 Google 开发人员工作流程集成的几次失败尝试；<sup id="a8">[[8]](#f8)</sup> Tricorder 和以前的尝试之间的主要区别是我们不懈地致力于让 Tricorder 仅向其用户提供有价值的结果。Tricorder 与 Google Critique 的主要代码审查工具集成在一起。Tricorder 警告在 Critique 的查看器中显示为灰色注释框，如 [图 20-1](https://i.loli.net/2021/04/13/xfsrGWhi5HlumwB.jpg) 所示。
![figure20-1.jpg](https://i.loli.net/2021/04/13/xfsrGWhi5HlumwB.jpg)
*Figure 20-1. Critique 的差异视图，以灰色显示来自 Tricorder 的静态分析警告*

为了扩展，Tricorder 使用了微服务架构。Tricorder 系统将分析请求以及有关代码更改的元数据发送到分析服务器。这些服务器可以使用该元数据通过基于 FUSE 的文件系统读取更改中的源代码文件的版本，并且可以访问缓存的构建输入和输出。然后，分析服务器开始运行每个单独的分析器，并将输出写入存储层； 每个类别的最新结果将显示在“批注”中。由于分析有时需要几分钟才能运行，因此分析服务器还会发布状态更新，以使变更作者和审阅者知道分析器正在运行，并在分析器完成时发布完成的状态。Tricorder 每天分析超过 50,000 个代码审查更改，并且通常每秒运行几次分析。

整个 Google 的开发人员都编写 Tricorder 分析或对现有分析进行单独的“检查”。新的 Tricorder 检查有四个条件：

易读性
- 让输出信息对任何工程师都能容易读懂。

易修复
- 该修复可能比编译器检查需要更多的时间、思想或精力，并且结果应包括有关如何确实解决此问题的指南

低误报
- 开发人员应该感觉到检查至少 90％ 的检查中指出了实际问题。

潜移默化地提高代码质量
- 这些问题可能不会影响正确性，但是开发人员应认真对待它们，并修复它们。

Tricorder 分析器报告 30 多种语言的结果，并支持多种分析类型。Tricorder 包括 100 多个分析器，其中大多数来自 Tricorder 团队以外的人员。这些分析器中的七个本身就是插件系统，具有数百种其他检查功能，这些检查程序又由 Google 的开发人员提供。总体有效假阳性率略低于 5％。

### 综合集成工具
Tricorder 集成了许多不同类型的静态分析工具。

容易出错和 clang-tidy 扩展了编译器，以分别识别 Java 和 C ++ 的 AST 反面模式。这些反面模式可能代表真正的错误。例如，考虑以下代码片段对 long 类型的字段 f 进行哈希处理：

- `result = 31 * result + (int) (f ^ (f >>> 32));`

现在考虑 f 的类型为 int 的情况。该代码仍将编译，但是右移 32 位是空操作，因此 f 与自身进行 XOR 运算，并且不再影响所产生的值。我们在 Google 的代码库中修复了 31 个此类错误，同时在“容易出错”中启用了作为编译器错误的检查功能。还有更多这样的例子。AST反模式还可以提高代码的可读性，例如，删除智能指针上对 `.get()` 的多余调用。

其他分析器展示了语料库中不同文件之间的关系。Deleted Artifact Analyzer 会警告是否删除了代码库中其他非代码位置所引用的源文件（例如，签入文档中的内容）。“如果 A 那么 B”模式允许开发人员指定必须同时更改两个不同文件的各个部分（如果没有，则发出警告）。Chrome 浏览器的 Finch 分析器在用于 Chrome 浏览器A / B实验的配置文件上运行，突出显示了常见问题，包括未获得批准才能启动实验或与影响相同总体的其他当前正在运行的实验进行串扰。Finch 分析器对其他服务进行远程过程调用（RPC），以提供此信息。

除了源代码本身之外，某些分析器还可以在由该源代码产生的其他编译结果上运行；例如， 许多项目启用了二进制大小检查器，当更改对二进制大小有重大影响时会发出警告。

几乎所有分析器都是过程内分析器，这意味着分析结果基于过程（功能）中的代码。组合式或增量式过程间分析技术在技术上是可行的，但需要额外的基础设施投资（例如，在分析器运行时分析和存储方法摘要）。

### 集成化的反馈通道

正如前面提到的，在analysis consumers和analysis writers之间建立一个反馈循环对于跟踪和维持开发人员的积极性是至关重要的。 使用Tricorder时，我们会在分析结果中显示“无用”的选项按钮; 单击此按钮，可以直接对分析器开发人员提出一个反馈，说明为什么分析结果是没用的。 代码审阅者还可以通过单击“Please fix”按钮来请求change authors修改分析结果。Tricorder团队会追踪具有高“无用”点击率的分析器，特别是经常被要求修改分析结果的分析器，如果它们不能解决问题并降低“无用”按钮的点击率，则团队会禁用这个分析器。 建立和调整这个反馈循环将会花费大量的工作，但能够有效改善分析结果和获得更好的用户体验(UX)，因为在我们建立清晰的反馈渠道之前，许多开发人员会忽略他们不理解的分析结果。

有时修复一个问题是很简单的--比如改进一个分析器输出的提示信息! 例如，我们曾经推出一个错误分析器叫：Error Prone，它的功能是当太多的参数被传递给一个类似于Guava的printf的函数时，它会提示错误（这个函数仅接受 %s，不接受其他类型的占位符)。但是在推出Error Prone后团队每周都会收到提示信息“无用”的错误报告，报告里称当占位符的数量与参数的数量相同时分析器却提示错误，其原因是用户试图传递%s以外的占位符导致的。在团队更改诊断信息并声明该函数只接受%s占位符后，Error Prone团队就不再继续收到错误报告了。从上面的例子可以知道提示信息应该尽可能详细，如说明哪里是错的、为什么错、以及修复它的方法，并且可以使开发人员在阅读提示信息时学到一些东西。

### 修复建议

Tricorder 会尽可能提供错误的修复建议，如下图所示 [图 20-2]([figure20-2.png](https://i.loli.net/2021/04/13/bNEeaMWyr7T4PtQ.png)).

![figure20-2.png](https://i.loli.net/2021/04/13/bNEeaMWyr7T4PtQ.png)
*图 20-2. 一个通过静态分析修复错误的例子*

当信息不明确时，自动修复可以作为额外的参考文档，并且如前文所述，这可以降低解决静态分析问题的成本。开发者可以直接点击提示信息来应用自动修复，或者通过命令行工具应用于整个代码更改。虽然不是所有的分析器都支持代码修复，但是大部分分析器都提供了这个功能。我们认为代码格式问题应该由分析器自动解决，例如代码文件的格式化程序。谷歌对每种语言都指定了代码风格指南，并指出开发者不应该浪费时间在修复格式问题上。代码Reviewers每天点击“请修复”数千次，代码作者每天应用自动修复约3000次，但Tricorder分析器每天仅收到250次“无用”点击。

### 基于项目的可定制化
在我们通过只显示高可信度的分析结果建立了用户的信任之后，除了默认的分析结果之外，我们还为特定的项目增加了额外“可选的”的分析器支持。Proto Best Practices分析器是可自定义分析器的一个例子。这个分析器会高亮那些可能会对协议缓冲区(google的独立于语言的数据序列化格式)数据格式破坏的更改。只有当序列化数据存储在某个地方(例如，在服务器日志中)时，这些更改才会中断；没有存储序列化数据的项目的协议缓冲区不需要启用检查。尽管有所限制，我们还是增加了定制现有分析器的功能，而在默认情况下，我们会在代码库中使用统一的代码检查方式。

有些分析器甚至开始就是可定制的，然后根据用户反馈进行改进，建立庞大的用户基础，一旦我们能够取得我们用户的信任，分析器的配置就逐步固定为默认。例如，我们有一个分析器，它用于提高Java代码的可读性，但通常不会真正改变代码行为。Tricorder的用户最初担心这种分析过于“啰嗦”，但最终他们还是希望获得更多的分析结果。

成功定制的关键在于关注项目级定制，而不是用户级定制。项目级定制确保所有团队成员对其项目的分析结果有一致的看法，并防止一个开发人员试图解决问题而另一个开发人员引入问题的情况。

在Tricorder开发的早期，一组相对简单的样式检查器(“linters”)在Critique中显示分析结果，Critique提供用户设置来选择结果的置信度，以显示和抑制特定分析的结果。当我们从Critique中删除了所有这些用户可定制选项后，立即开始收到用户对恼人的分析结果的投诉。为了应对这个问题我们没有重新启用可定制的功能，而是询问用户为什么他们感到恼火，并发现了各种各样的错误和误报。例如，C++ linter会在Objective-C文件上运行，但是产生了不正确的、无用的分析结果。我们修复了linter的基础框架，避免了这种情况再发生。HTML linter具有极高的误报率，而且几乎没有有用的提示，因此通常被编写HTML的开发人员屏蔽掉。因为HTML linter很少给出有用的提示，所以我们禁用了这个linter。简而言之，用户定制导致了Bug难以被发现并减少了用户的反馈。

### 预提交
除了代码审查之外，谷歌还有其他用于静态分析的工作流集成点。因为开发人员可以选择忽略代码审查中显示的静态分析警告，谷歌还能够分析并阻止提交待定代码更改，我们称之为预提交检查。预提交检查包括非常简单的对更改的内容或元数据的可定制的检查，例如确保提交信息没有说“不要提交”，或者测试代码总是包含在相应的代码文件中。团队还可以指定一套测试，这些测试必须通过或验证代码没有Tricorder指定的某一类别问题。预提交还检查代码是否格式良好。预提交检查通常发生在开发人员将更改发送出去的时候，并在提交过程中再次运行，但检查也可以在这些点之间临时触发。关于预提交的更多细节请参见[第23章](../chapter23/continuous_integration_zh.md)。

一些团队已经编写了他们自己定制的预提交检查。这些是基础预提交检查之外的额外检查，可以提高比整个公司更高的最佳实践标准，并添加特定于项目的分析。这使得新项目比具有大量遗留代码的项目具有更严格的`最佳实践指导方针`。团队定制的预提交检查可能会使项目大规模变更(LSC)更加困难(见[第22章](../chapter22/large_scale_changes_zh.md))，因此有些变更会在变更描述中使用“`CLEANUP=`”参数跳过。

### 编译器集成
虽然用静态分析阻止提交很好，但是在工作流中更早地通知开发人员问题更好。 在可能的情况下，我们尝试将静态分析集成入编译器。构建失败是一个不可忽视的警告，但在许多情况下这种方式是不可行的。然而，有些分析是高度机械的，没有“有效假阳性”。一个例子是Error Prone的“ERROR”检查。这些检查都是在谷歌的Java编译器中启用的，防止错误实例再次被引入我们的代码库中。编译器检查需要足够快，这样才不会降低构建速度。此外，我们强制执行这三个标准(C++编译器也存在类似的标准):
- 可操作且易于修复(只要有可能，错误应该包括可以机械应用的修复建议)
- 不会产生影响运行的误报(分析永远不会停止构建正确的代码)
- 报告仅影响正确性而非代码风格或最佳实践

为了启用新的代码检查，我们首先需要清理代码库中该问题的所有实例，这样我们就不会因为编译器升级而破坏现有项目的构建。这也意味着部署新的基于编译器的检查的效果必须足够好，以保证修复它的所有现有问题实例。谷歌通过集群在整个代码库并行运行各种编译器(如clang和javac)--作为一个MapReduce操作。当编译器以这种MapReduce方式运行时，运行的静态分析检查必须进行修复，以便自动清理。在一个待定的代码变更进行测试并在整个代码库中应用修复程序之后，我们提交该变更并移除所有的问题实例。然后，我们在编译器中打开检查，以便在不破坏构建的情况下，不会提交新的问题实例。构建中断是在我们的连续集成系统（CI）提交之后，或者在预提交检查提交之前被捕获的(参见前面的讨论)。

我们的目标是编译器永远不发出警告。因为我们不断发现开发人员会忽略编译器警告。我们要么让编译器警告作为错误输出(这会中断构建)，要么不在编译器中输出它。因为在整个代码库中使用相同的编译器标志，所以这个配置是全局的。无法中断构建的警告要么被忽略，要么在代码review时显示(例如，通过Tricorder)。虽然不是谷歌的每种语言都有这个配置，但最常用的语言有。Java和C++编译器都配置为避免显示编译器警告。Go编译器把这一点发挥到了极致；其他语言会认为是警告的一些东西(如未使用的变量或包导入)在Go编译器中是错误。
### 在编辑和浏览时进行代码分析
静态分析的另一个潜在集成点是集成开发环境(IDE)。然而，集成开发环境分析需要极短的分析时间(通常少于1秒，理想情况下少于100毫秒)，因此一些工具不适合在此集成。此外，还有一个问题是要确保相同的分析器在多个IDE中以相同的方式运行。我们还注意到集成开发环境的受欢迎程度可能会有所变化(我们并不强制开发人员使用同一种的IDE)；因此，IDE集成往往比插入审查过程更混乱。代码审查对于显示分析结果也有特定的好处。分析可以考虑变更的整个背景；某些分析可能对部分代码不准确(例如在添加调用点之前对函数的死代码分析)。在代码评审中显示分析结果也意味着如果代码作者想要忽略分析结果，他们也必须说服评审员。也就是说，在集成开发环境进行适当的分析是有帮助的。

虽然我们主要关注于显示新引入的静态分析警告，或者编辑代码时的警告，但是对于某些分析，开发人员实际上确实希望能够在浏览代码期间查看整个代码库的分析结果。这方面的一个例子是一些安全分析。谷歌的特定安全团队希望看到问题所有实例的整体视图。开发人员还喜欢在清理代码时通过代码库查看分析结果。换句话说，有时在代码浏览时显示分析结果是正确的选择。

## 结论
静态分析是一个很好的工具，可以改进代码库，早期发现错误，并允许更宝贵的资源(如人工审查和测试)专注于不能机械验证的问题。通过提高静态分析基础软件的可扩展性和可用性，我们已经使静态分析成为谷歌软件开发的重要组成部分。

## TL;DRs
- 关注开发者的感受。我们投入了大量精力来在开发者和分析器作者之间建立反馈渠道，并积极调整分析程序以减少误报数量。
- 将静态分析作为核心开发人员工作流程的一部分。谷歌静态分析的主要集成点是代码审查，其中分析工具提供修复功能且这一集成点涉及审查者。然而，我们也集成了其他分析工具(编译器检查、检查代码提交、在IDEs中以及浏览代码时静态分析)。
- 鼓励用户做出贡献。通过利用不同领域专家的专业知识，我们可以扩展构建和维护分析工具和平台的工作。开发人员不断增加新的分析和检查工具，使他们的生活更轻松，让我们的代码库更好。

## References

1. <span id="f1">[^](#a1)</span> See http://errorprone.info/bugpatterns.
2. <span id="f2">[^](#a2)</span> Caitlin Sadowski et al. Tricorder: Building a Program Analysis Ecosystem, International Conference on Software Engineering (ICSE), May 2015.
3. <span id="f3">[^](#a3)</span> A good academic reference for static analysis theory is: Flemming Nielson et al. Principles of Program Analysis (Gernamy: Springer, 2004).
4. <span id="f4">[^](#a4)</span> Note that there are some specific analyses for which reviewers might be willing to tolerate a much higher false-positive rate: one example is security analyses that identify critical problems.
5. <span id="f5">[^](#a5)</span> See later in this chapter for more information on additional integration points when editing and browsing code.
6. <span id="f6">[^](#a6)</span> Louis Wasserman, “Scalable, Example-Based Refactorings with Refaster.” Workshop on Refactoring Tools, 2013.
7. <span id="f7">[^](#a7)</span> Caitlin Sadowski, Jeffrey van Gogh, Ciera Jaspan, Emma Söderberg, and Collin Winter, Tricorder: Building a Program Analysis Ecosystem, International Conference on Software Engineering (ICSE), May 2015.
8. <span id="f8">[^](#a8)</span> Caitlin Sadowski, Edward Aftandilian, Alex Eagle, Liam Miller-Cushon, and Ciera Jaspan, “Lessons from Building Static Analysis Tools at Google”, Communications of the ACM, 61 No. 4 (April 2018): 58–66, https://cacm.acm.org/magazines/2018/4/226371-lessons-from-building-static-analysis-tools-at-google/fulltext.