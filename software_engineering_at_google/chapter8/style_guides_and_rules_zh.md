# 第八章 样式指南和规则

*作者 Shaindel Schwartz* 

*编辑 Tom Manshreck*

大多数工程组织都有管理代码库的规则——关于源文件存储的位置的规则、关于代码格式的规则、关于命名、模式、异常和线程的规则。大多数软件工程师都在一组规定他们如何进行操作的策略下工作。在谷歌，为了管理我们的代码库，我们维护了一组定义规则的风格指南。

规则是法律。它们不仅仅是建议或推荐的规范，而是严格的、强制性的法律。因此，它们是普遍的强制执行的——除非确实有需要且经过批准，规则不能被忽视。与规则相反，指导提供建议和最佳实践。遵循这些规则是好的，甚至是非常明智的，但与规则不同的是，它们通常有一些变化的空间。

我们从我们的编程风格指南中收集我们定义的编写代码时必须遵循的注意事项，它们被视为规范。“风格”可能在这里有点用词不当，这意味着一个仅限于格式化实践的集合。我们的风格指南不仅仅是这些；它们是管理我们代码的一整套约定。这并不是说我们的风格指南是严格规定的；风格指南规则可能需要判断，比如使用"尽可能合理地描述"的命名的规则。相反，我们的风格指南作为规则的权威来源，工程师要对此负责。

我们为谷歌上使用的每种编程语言维护单独的风格指南<sup>1</sup>。在更高的层面，所有的指南都有相似的目标，旨在引导代码注重可持续性的发展。同时，它们之间在范围、长度和内容上也有很大的差异。在谷歌不断发展的代码存储库中，编程语言具有不同的优势、不同的特性、不同的优先级和不同的历史采用路径。因此，独立定制每种语言的指导方针要实用得多。我们的一些风格指南很简明，专注于一些总体原则，如命名和格式化，如我们的Dart、R和SHELL指南中所示。其他风格指南包括更详细的内容，深入研究特定的语言特性，并扩展到更长的文档——尤其是我们的C++、Python和Java指南。一些风格指南强调了非谷歌对该语言典型地使用——我们的Go风格指南非常短，只在总结指令中添加了一些规则，以遵守外部公认的惯例中概述的实践。其他规则包括从根本上不同于外部规范的规则；我们的C++规则不允许使用异常，这是一种在谷歌代码之外广泛使用的语言特性。

即使是我们自己的风格指南之间，差异也很大，这使得我们很难确定一个风格指南应该涵盖什么内容。引导谷歌风格指南发展的决策源于保持我们代码库可持续性的需要。其他组织的代码库本身就对可持续性有不同的要求，这需要一套不同的定制规则。本章讨论了指导我们规则和指南开发的原则和过程，主要从Google的C++、Python和Java风格指南中借鉴例子。

## 为什么要有规则？

那么，我们为什么要有规则呢？制定规则的目标是鼓励“好”地行为，并阻止“坏”的行为。对“好”和“坏”的解释因组织而不同，这取决于组织的关心内容。这样的设计并非普遍的偏好；好与坏是主观的，是根据需要量身定制的。对于某些组织来说，“好的”可能会促进支持少量内存占用，或优先考虑潜在的运行时优化的使用模式。在其他组织中，“好的”可能会促进使用新语言功能的选择。有时，一个组织最关心一致性，所以任何与现有模式不一致的东西都是“糟糕的”。我们必须首先认识到一个给定的组织所看重的，并使用规则和指南来鼓励和阻止相应的行为。

随着组织的发展，既定的规则和指导方针形成了编码的通用词汇表。通用词汇允许工程师集中于代码需要表达的内容，而不是怎么表达。通过构造这个词汇表，工程师会倾向于做一些“好的”事情，甚至是下意识地。因此，规则为我们提供了广泛的杠杆作用，以向期望的方向推动共同的开发模式。

## 正在创建这些规则

在定义一组规则时，关键问题不是“我们应该有什么规则？”，要问的问题是“我们试图推进什么目标？”。当我们关注规则将服务的目标时，确定哪些规则支持这一目标，会更容易地提炼一套有用的规则。在谷歌，风格指南是代码实践的法律，我们不会问，“风格指南是什么？”，而是问，“为什么要在风格指南中加入这些内容？”，通过拥有一套规则来规范代码的编写，我们的组织可以获得什么？

### 指南原则

让我们来看一看：谷歌的工程组织由3万多名工程师组成。这个工程群体在技能和背景上表现出巨大的差异。每天大约有6万条文件被提交到一个可能存在数十年的20多亿行代码的代码库上。我们正在为一套与大多数其他组织的需求不同的价值需要进行优化，但在某种程度上，这些问题无处不在——我们需要维持一个既能适应规模又能适应时间的工程环境。

在这种情况下，我们的规则的目标是管理我们的开发环境的复杂性，保持代码库的可管理性，同时仍然允许工程师高效地工作。我们在这里做出权衡：帮助我们实现这一目标的大量规则确实意味着我们正在限制选择。我们失去了一些灵活性，甚至可能冒犯一些人，但是，由权威标准提供的一致性和减少冲突的收益最终胜出。

鉴于这一观点，我们认识到一些指导我们的规则发展的首要原则，这些原则必须：

- 满足实际需要
- 为读者进行优化
- 保持一致
- 避免容易出错和令人惊讶的结构
- 必要时应遵守实际情况

#### 规则必须满足实际需要
并不是所有的东西都应该进入风格指南。要求组织中的所有工程师学习和适应任何设定的新规则都不是零成本的。由于规则过多<sup>2</sup>，不仅工程师在编写代码时更加难以记住所有的规则，新工程师也更加难以学习。更多的规则也使维护规则集更具有挑战性，代驾更昂贵。

为此目的，我们故意选择不在指南中包括那些应该不言自明的规则。谷歌的风格指南并不是为了以合法的方式来解释；仅仅因为某些东西没有被明确禁止，并不意味着它是合法的。比如，C++风格指南没有规则禁止使用goto。C++程序员已经倾向于避免它，因此在规则指南中包括进一个禁止它的明确规则将会引入不必要的开销。如果只有一两个工程师出了问题，通过创造新规则来增加每个人的精神负担是行不通的。

#### 为读者进行优化

我们的规则的另一个原则是为代码的读者而不是作者进行优化。随着时间的推移，我们的代码被阅读频率将比编写要频繁得多。我们宁愿输入冗长乏味的代码，也不愿难以阅读它。在我们的Python风格指南中，当讨论条件表达式时，我们认识到它们比如果语句更短，因此对代码作者更方便。然而，由于它们对读者来说比任何陈述都更难理解，我们限制了它们的使用。我们重视“简单易读”而不是“简单易写”。“我们在这里进行权衡：当工程师必须重复输入变量和类型的描述性名称时，可能会花费更高的成本。我们选择为它为所有未来读者提供的可读性支付这个成本。

作为优先级的一部分，我们还要求工程师在他们的代码中留下关于预期行为的明确证据。我们希望读者在阅读该代码时能清楚地了解该代码在做什么。例如，我们的Java、JavaScript和C++会指示每当方法重写超类方法时，强制使用覆盖注释或关键字。如果没有明确的设计证据，读者可能会弄清楚这个意图，尽管每个读者理解代码时需要更深入的挖掘。

意图行为的证据在可能令人相对吃惊的时候变得更加重要，在C++中，有时仅仅通过读取代码片段就很难跟踪指针的所有权。如果将指针传递给一个函数，而不熟悉该函数的行为，我们就无法确定将会发生什么。调用者仍然拥有这个指针吗？这个函数拥有所有权了吗？我可以在函数返回后继续使用指针吗?或者它可能已经被删除了?为了避免这个问题，我们的C++风格指南更喜欢在打算进行所有权转移时使用std::unique_ptr。unique_ptr是管理指针所有权的结构，确保指针只有一个副本。当函数将unique_ptr作为参数并打算获取指针的所有权时，调用者必须显式地调用转移语义：

```c++
// Function that takes a Foo* and may or may not assume ownership of
// the passed pointer.
void TakeFoo(Foo* arg);
// Calls to the function don’t tell the reader anything about what to
// expect with regard to ownership after the function returns.
Foo* my_foo(NewFoo());
TakeFoo(my_foo);
```

请将其与以下内容进行比较：
```c++
// Function that takes a std::unique_ptr<Foo>.
void TakeFoo(std::unique_ptr<Foo> arg);
// Any call to the function explicitly shows that ownership is
// yielded and the unique_ptr cannot be used after the function
// returns.
std::unique_ptr<Foo> my_foo(FooFactory());
TakeFoo(std::move(my_foo));
```

鉴于风格指南规则，我们保证所有调用处都将包括明确的所有权转移证据，无论何时应用。有了这个信号，代码的代码的阅读者就不需要理解每个函数调用的行为了。我们在API中提供了足够的信息来解释它的交互作用。调用点行为文档确保了代码片段保持可读性和可理解性。我们的目标是进行局部推理，其目标是清楚地了解在调用点上发生的事情，而不需要查找和引用其他代码，包括函数的实现。

大多数涵盖评论的风格指南规则也被设计为支持为读者提供适当证据的目标。文档注释（添加到给定文件前面的块注释、类或函数的块注释）描述了以下代码的设计或意图。实现注释（散布在代码本身中的注释）证明或突出了不明显的选择，解释了棘手的部分，并强调了代码的重要部分。

我们的风格指南的规则涵盖了这两种类型的注释，要求工程师提供另一个工程师在阅读代码时可能会寻找的解释。

#### 保持一致
我们对代码库中一致性的看法与我们应用于谷歌办公机构的理念相似。由于有大量分散的工程人员，团队被分成办公机构，谷歌员工经常发现自己去了其他站点。虽然每个办公机构都保持着其独特的个性，拥抱着当地的风俗和风格，但对于任何完成工作所必需的事情，一切都刻意保持不变。来访的谷歌员工的ID卡刷当地的读卡器；任何谷歌设备都可以使用WiFi; 任何会议室的视频会议设置都具有相同的界面。一个谷歌员工不需要花时间学习如何建立这一切；他们知道，无论他们在哪里，这一切都将是一样的。在办公机构之间移动，仍然很容易完成工作。

这就是我们在源代码中所争取的。一致性是让任何工程师永远不会跳进代码库中不熟悉的部分，并相当快地开始工作的原因。一个本地项目可以有它独特的个性，但它的工具是一样的，它的技术是一样的，它的库是一样的，而且这一切都只是工作。

#### 一致性的优势
尽管不允许办公室定制读卡器或视频会议界面可能会觉得有限制，但一致性的好处远远超过了我们失去的创造性自由。代码也是一样：保持一致有时可能会感到紧张，但这意味着更多的工程师可以用更少的精力完成更多的工作<sup>3</sup>：

- 当代码库在内部的风格和规范保持一致时，编写代码和其他阅读代码的工程师可以关注正在做的事情，而不是如何表示它。在很大程度上，这种一致性允许专家分块<sup>4</sup>。当我们用相同的接口解决问题并以一致的方式格式化代码时，专家们更容易查看一些代码，忽略当前的内容，并了解它在做什么。它还使模块化代码和点复制更容易。由于这些原因，我们非常关注一致的命名约定、公共模式的一致使用以及一致的格式设置和结构。还有许多规则会对一个似乎非常小的问题做出决定，仅仅是为了保证事情只能以一种方式完成。例如，选择用于缩进的空格数或行长度的限制<sup>5</sup>。有一个答案的一致性而不是答案本身才是这里有价值的部分。

- 支持扩展的一致性。工具是组织规模缩放的关键，而一致性代码可以使构建能够理解、编辑和生成代码的工具更容易。如果每个人都有少量不同的代码，那么依赖于一致性的工具的全部好处就无法得到应用——如果一个工具可以通过添加缺少的导入或删除未使用的包含来更新源文件，如果不同的项目为它们的导入列表选择不同的排序策略，那么该工具可能无法在所有地方工作。当每个人都使用相同的组件，当每个人的代码都遵循相同的结构和组织规则时，我们可以投资于在任何地方都能工作的工具，为我们的许多维护任务构建自动化。如果每个团队都需要为同一工具的定制版本进行单独投资，为他们独特的环境量身定制，我们就会失去这种优势。

- 在扩展组织的人力部分时，一致性也会有帮助。随着一个组织的增长，研究代码库的工程师的数量也会增加。保持每个人正在工作的代码尽可能一致，可以提高跨项目的移动性，最大限度地减少工程师切换团队的适应时间，并增强组织随着员工需求波动而灵活调整和适应的能力。不断增长的组织还意味着担任其他角色的人员会与代码进行交互，例如，SREs、库工程师和代码管理员。在谷歌，这些角色通常跨越多个项目，这意味着不熟悉某个团队项目的工程师可能会直接参与该项目的代码工作。跨代码库的一致体验使其更有效。

- 一致性还确保了对时间的弹性。随着时间的推移，工程师们离开项目，新的人加入，所有权转移，项目合并或分裂。努力建立一个一致的代码库可以确保这些转换是低成本的，并允许我们对代码和为此工作的工程师具有几乎不受约束的流动性，从而简化了长期维护所必需的过程。

*5 See 4.2 Block indentation: +2 spaces, Spaces vs. Tabs, 4.4 Column limit:100 and Line Length.*


---
## 大规模地

几年前，我们的C风格指南承诺几乎永远不会改变使旧代码不一致的风格指南规则：“在某些情况下，改变某些风格规则可能有很好的理由，但我们仍然为了保持一致性。”

当码库较小，角落较少时，这是有意义的。

当代码库越来越大时，这就不再是一件需要优先考虑的事情了。这(至少对我们的C风格指南背后的仲裁者来说)是一个有意识的改变：在触及这一点时，我们明确声明C代码库永远不会再完全一致，我们甚至也没有达到这个目标。

不仅将规则更新到当前的最佳实践，而且要求我们将这些规则应用于所有编写的一切，这将是太大的负担。我们的大规模更改工具和流程允许我们更新几乎所有的代码，以遵循几乎每一种新的模式或语法，以便大多数旧代码显示其最新批准的样式（见第22章）。然而，这些机制并不完美；当代码库尽可能大时，我们不能确定所有的旧代码都能符合新的最佳实践。要求完美的一致性已经达到了价值成本过多的程度。

---

**正在设定标准。** 当我们提倡一致性时，我们倾向于关注内部一致性。有时，地方会议在全球会议通过之前就会出现，调整一切以匹配是不合理的。在这种情况下，我们提倡一个更严格的一致性体系：“保持一致性”从本地开始，即给定文件中的规范先于给定团队的规范，先于较大的项目的规范，先于整个代码库的规范。事实上，样式指南包含了一些明确地遵从本地约定的规则，6重视这种本地一致性，而不是科学的技术选择。

然而，一个组织要创建并坚持一组内部约定并不总是不够的。有时，应考虑到外部社区所采用的标准。


