# 第八章 样式指南和规则

*作者 Shaindel Schwartz* 

*编辑 Tom Manshreck*

大多数工程组织都有管理代码库的规则——关于源文件存储的位置的规则、关于代码格式的规则、关于命名、模式、异常和线程的规则。大多数软件工程师都在一组规定他们如何进行操作的策略下工作。在谷歌，为了管理我们的代码库，我们维护了一组定义规则的风格指南。

规则是法律。它们不仅仅是建议或推荐的规范，而是严格的、强制性的法律。因此，它们是普遍的强制执行的——除非确实有需要且经过批准，规则不能被忽视。与规则相反，指导提供建议和最佳实践。遵循这些规则是好的，甚至是非常明智的，但与规则不同的是，它们通常有一些变化的空间。

我们从我们的编程风格指南中收集我们定义的编写代码时必须遵循的注意事项，它们被视为规范。“风格”可能在这里有点用词不当，这意味着一个仅限于格式化实践的集合。我们的风格指南不仅仅是这些；它们是管理我们代码的一整套约定。这并不是说我们的风格指南是严格规定的；风格指南规则可能需要判断，比如使用"尽可能合理地描述"的命名的规则。相反，我们的风格指南作为规则的权威来源，工程师要对此负责。

我们为谷歌上使用的每种编程语言维护单独的风格指南<sup>1</sup>。在更高的层面，所有的指南都有相似的目标，旨在引导代码注重可持续性的发展。同时，它们之间在范围、长度和内容上也有很大的差异。在谷歌不断发展的代码存储库中，编程语言具有不同的优势、不同的特性、不同的优先级和不同的历史采用路径。因此，独立定制每种语言的指导方针要实用得多。我们的一些风格指南很简明，专注于一些总体原则，如命名和格式化，如我们的Dart、R和SHELL指南中所示。其他风格指南包括更详细的内容，深入研究特定的语言特性，并扩展到更长的文档——尤其是我们的C++、Python和Java指南。一些风格指南强调了非谷歌对该语言典型地使用——我们的Go风格指南非常短，只在总结指令中添加了一些规则，以遵守外部公认的惯例中概述的实践。其他规则包括从根本上不同于外部规范的规则；我们的C++规则不允许使用异常，这是一种在谷歌代码之外广泛使用的语言特性。

即使是我们自己的风格指南之间，差异也很大，这使得我们很难确定一个风格指南应该涵盖什么内容。引导谷歌风格指南发展的决策源于保持我们代码库可持续性的需要。其他组织的代码库本身就对可持续性有不同的要求，这需要一套不同的定制规则。本章讨论了指导我们规则和指南开发的原则和过程，主要从Google的C++、Python和Java风格指南中借鉴例子。

## 为什么要有规则？

那么，我们为什么要有规则呢？制定规则的目标是鼓励“好”地行为，并阻止“坏”的行为。对“好”和“坏”的解释因组织而不同，这取决于组织的关心内容。这样的设计并非普遍的偏好；好与坏是主观的，是根据需要量身定制的。对于某些组织来说，“好的”可能会促进支持少量内存占用，或优先考虑潜在的运行时优化的使用模式。在其他组织中，“好的”可能会促进使用新语言功能的选择。有时，一个组织最关心一致性，所以任何与现有模式不一致的东西都是“糟糕的”。我们必须首先认识到一个给定的组织所看重的，并使用规则和指南来鼓励和阻止相应的行为。

随着组织的发展，既定的规则和指导方针形成了编码的通用词汇表。通用词汇允许工程师集中于代码需要表达的内容，而不是怎么表达。通过构造这个词汇表，工程师会倾向于做一些“好的”事情，甚至是下意识地。因此，规则为我们提供了广泛的杠杆作用，以向期望的方向推动共同的开发模式。

## 正在创建这些规则

在定义一组规则时，关键问题不是“我们应该有什么规则？”，要问的问题是“我们试图推进什么目标？”。当我们关注规则将服务的目标时，确定哪些规则支持这一目标，会更容易地提炼一套有用的规则。在谷歌，风格指南是代码实践的法律，我们不会问，“风格指南是什么？”，而是问，“为什么要在风格指南中加入这些内容？”，通过拥有一套规则来规范代码的编写，我们的组织可以获得什么？

### 指南原则

让我们来看一看：谷歌的工程组织由3万多名工程师组成。这个工程群体在技能和背景上表现出巨大的差异。每天大约有6万条文件被提交到一个可能存在数十年的20多亿行代码的代码库上。我们正在为一套与大多数其他组织的需求不同的价值需要进行优化，但在某种程度上，这些问题无处不在——我们需要维持一个既能适应规模又能适应时间的工程环境。

在这种情况下，我们的规则的目标是管理我们的开发环境的复杂性，保持代码库的可管理性，同时仍然允许工程师高效地工作。我们在这里做出权衡：帮助我们实现这一目标的大量规则确实意味着我们正在限制选择。我们失去了一些灵活性，甚至可能冒犯一些人，但是，由权威标准提供的一致性和减少冲突的收益最终胜出。

鉴于这一观点，我们认识到一些指导我们的规则发展的首要原则，这些原则必须：

- 满足实际需要
- 为读者进行优化
- 保持一致
- 避免容易出错和令人惊讶的结构
- 必要时应遵守实际情况

#### 规则必须满足实际需要
并不是所有的东西都应该进入风格指南。要求组织中的所有工程师学习和适应任何设定的新规则都不是零成本的。由于规则过多<sup>2</sup>，不仅工程师在编写代码时更加难以记住所有的规则，新工程师也更加难以学习。更多的规则也使维护规则集更具有挑战性，代驾更昂贵。

为此目的，我们故意选择不在指南中包括那些应该不言自明的规则。谷歌的风格指南并不是为了以合法的方式来解释；仅仅因为某些东西没有被明确禁止，并不意味着它是合法的。比如，C++风格指南没有规则禁止使用goto。C++程序员已经倾向于避免它，因此在规则指南中包括进一个禁止它的明确规则将会引入不必要的开销。如果只有一两个工程师出了问题，通过创造新规则来增加每个人的精神负担是行不通的。

#### 为读者进行优化

我们的规则的另一个原则是为代码的读者而不是作者进行优化。随着时间的推移，我们的代码被阅读频率将比编写要频繁得多。我们宁愿输入冗长乏味的代码，也不愿难以阅读它。在我们的Python风格指南中，当讨论条件表达式时，我们认识到它们比如果语句更短，因此对代码作者更方便。然而，由于它们对读者来说比任何陈述都更难理解，我们限制了它们的使用。我们重视“简单易读”而不是“简单易写”。“我们在这里进行权衡：当工程师必须重复输入变量和类型的描述性名称时，可能会花费更高的成本。我们选择为它为所有未来读者提供的可读性支付这个成本。

作为优先级的一部分，我们还要求工程师在他们的代码中留下关于预期行为的明确证据。我们希望读者在阅读该代码时能清楚地了解该代码在做什么。例如，我们的Java、JavaScript和C++会指示每当方法重写超类方法时，强制使用覆盖注释或关键字。如果没有明确的设计证据，读者可能会弄清楚这个意图，尽管每个读者理解代码时需要更深入的挖掘。

意图行为的证据在可能令人相对吃惊的时候变得更加重要，在C++中，有时仅仅通过读取代码片段就很难跟踪指针的所有权。如果将指针传递给一个函数，而不熟悉该函数的行为，我们就无法确定将会发生什么。调用者仍然拥有这个指针吗？这个函数拥有所有权了吗？我可以在函数返回后继续使用指针吗?或者它可能已经被删除了?为了避免这个问题，我们的C++风格指南更喜欢在打算进行所有权转移时使用std::unique_ptr。unique_ptr是管理指针所有权的结构，确保指针只有一个副本。当函数将unique_ptr作为参数并打算获取指针的所有权时，调用者必须显式地调用转移语义：

```c++
// Function that takes a Foo* and may or may not assume ownership of
// the passed pointer.
void TakeFoo(Foo* arg);
// Calls to the function don’t tell the reader anything about what to
// expect with regard to ownership after the function returns.
Foo* my_foo(NewFoo());
TakeFoo(my_foo);
```

请将其与以下内容进行比较：
```c++
// Function that takes a std::unique_ptr<Foo>.
void TakeFoo(std::unique_ptr<Foo> arg);
// Any call to the function explicitly shows that ownership is
// yielded and the unique_ptr cannot be used after the function
// returns.
std::unique_ptr<Foo> my_foo(FooFactory());
TakeFoo(std::move(my_foo));
```

鉴于风格指南规则，我们保证所有调用处都将包括明确的所有权转移证据，无论何时应用。有了这个信号，代码的代码的阅读者就不需要理解每个函数调用的行为了。我们在API中提供了足够的信息来解释它的交互作用。调用点行为文档确保了代码片段保持可读性和可理解性。我们的目标是进行局部推理，其目标是清楚地了解在调用点上发生的事情，而不需要查找和引用其他代码，包括函数的实现。

大多数涵盖评论的风格指南规则也被设计为支持为读者提供适当证据的目标。文档注释（添加到给定文件前面的块注释、类或函数的块注释）描述了以下代码的设计或意图。实现注释（散布在代码本身中的注释）证明或突出了不明显的选择，解释了棘手的部分，并强调了代码的重要部分。

我们的风格指南的规则涵盖了这两种类型的注释，要求工程师提供另一个工程师在阅读代码时可能会寻找的解释。

#### 保持一致
我们对代码库中一致性的看法与我们应用于谷歌办公机构的理念相似。由于有大量分散的工程人员，团队被分成办公机构，谷歌员工经常发现自己去了其他站点。虽然每个办公机构都保持着其独特的个性，拥抱着当地的风俗和风格，但对于任何完成工作所必需的事情，一切都刻意保持不变。来访的谷歌员工的ID卡刷当地的读卡器；任何谷歌设备都可以使用WiFi; 任何会议室的视频会议设置都具有相同的界面。一个谷歌员工不需要花时间学习如何建立这一切；他们知道，无论他们在哪里，这一切都将是一样的。在办公机构之间移动，仍然很容易完成工作。

这就是我们在源代码中所争取的。一致性是让任何工程师永远不会跳进代码库中不熟悉的部分，并相当快地开始工作的原因。一个本地项目可以有它独特的个性，但它的工具是一样的，它的技术是一样的，它的库是一样的，而且这一切都只是工作。

#### 一致性的优势
尽管不允许办公室定制读卡器或视频会议界面可能会觉得有限制，但一致性的好处远远超过了我们失去的创造性自由。代码也是一样：保持一致有时可能会感到紧张，但这意味着更多的工程师可以用更少的精力完成更多的工作<sup>3</sup>：

- 当代码库在内部的风格和规范保持一致时，编写代码和其他阅读代码的工程师可以关注正在做的事情，而不是如何表示它。在很大程度上，这种一致性允许专家分块<sup>4</sup>。当我们用相同的接口解决问题并以一致的方式格式化代码时，专家们更容易查看一些代码，忽略当前的内容，并了解它在做什么。它还使模块化代码和点复制更容易。由于这些原因，我们非常关注一致的命名约定、公共模式的一致使用以及一致的格式设置和结构。还有许多规则会对一个似乎非常小的问题做出决定，仅仅是为了保证事情只能以一种方式完成。例如，选择用于缩进的空格数或行长度的限制<sup>5</sup>。有一个答案的一致性而不是答案本身才是这里有价值的部分。

- 支持扩展的一致性。工具是组织规模缩放的关键，而一致性代码可以使构建能够理解、编辑和生成代码的工具更容易。如果每个人都有少量不同的代码，那么依赖于一致性的工具的全部好处就无法得到应用——如果一个工具可以通过添加缺少的导入或删除未使用的包含来更新源文件，如果不同的项目为它们的导入列表选择不同的排序策略，那么该工具可能无法在所有地方工作。当每个人都使用相同的组件，当每个人的代码都遵循相同的结构和组织规则时，我们可以投资于在任何地方都能工作的工具，为我们的许多维护任务构建自动化。如果每个团队都需要为同一工具的定制版本进行单独投资，为他们独特的环境量身定制，我们就会失去这种优势。

- 在扩展组织的人力部分时，一致性也会有帮助。随着一个组织的增长，研究代码库的工程师的数量也会增加。保持每个人正在工作的代码尽可能一致，可以提高跨项目的移动性，最大限度地减少工程师切换团队的适应时间，并增强组织随着员工需求波动而灵活调整和适应的能力。不断增长的组织还意味着担任其他角色的人员会与代码进行交互，例如，SREs、库工程师和代码管理员。在谷歌，这些角色通常跨越多个项目，这意味着不熟悉某个团队项目的工程师可能会直接参与该项目的代码工作。跨代码库的一致体验使其更有效。

- 一致性还确保了对时间的弹性。随着时间的推移，工程师们离开项目，新的人加入，所有权转移，项目合并或分裂。努力建立一个一致的代码库可以确保这些转换是低成本的，并允许我们对代码和为此工作的工程师具有几乎不受约束的流动性，从而简化了长期维护所必需的过程。

*5 See 4.2 Block indentation: +2 spaces, Spaces vs. Tabs, 4.4 Column limit:100 and Line Length.*


---
## 大规模地

几年前，我们的C风格指南承诺几乎永远不会改变使旧代码不一致的风格指南规则：“在某些情况下，改变某些风格规则可能有很好的理由，但我们仍然为了保持一致性。”

当码库较小，角落较少时，这是有意义的。

当代码库越来越大时，这就不再是一件需要优先考虑的事情了。这(至少对我们的C风格指南背后的仲裁者来说)是一个有意识的改变：在触及这一点时，我们明确声明C代码库永远不会再完全一致，我们甚至也没有达到这个目标。

不仅将规则更新到当前的最佳实践，而且要求我们将这些规则应用于所有编写的一切，这将是太大的负担。我们的大规模更改工具和流程允许我们更新几乎所有的代码，以遵循几乎每一种新的模式或语法，以便大多数旧代码显示其最新批准的样式（见第22章）。然而，这些机制并不完美；当代码库尽可能大时，我们不能确定所有的旧代码都能符合新的最佳实践。要求完美的一致性已经达到了价值成本过多的程度。

---

**正在设定标准。** 当我们提倡一致性时，我们倾向于关注内部一致性。有时，地方会议在全球会议通过之前就会出现，调整一切以匹配是不合理的。在这种情况下，我们提倡一个更严格的一致性体系：“保持一致性”从本地开始，即给定文件中的规范先于给定团队的规范，先于较大的项目的规范，先于整个代码库的规范。事实上，样式指南包含了一些明确地遵从本地约定的规则，6重视这种本地一致性，而不是科学的技术选择。

然而，一个组织要创建并坚持一组内部约定并不总是不够的。有时，应考虑到外部社区所采用的标准。


# 计算空间

谷歌的Python风格指南最初要求我们所有的Python代码都有两个空格的缩进。外部Python社区使用的标准Python样式指南使用四个空格的缩进。早期的Python开发大多直接支持我们的C++项目，而不是实际的Python应用程序。因此，我们选择使用两个空格的缩进来与我们的C++代码保持一致，因为我们的c++代码已经用这种方式格式化了。随着时间的推移，我们发现这个理论并不成立。 编写Python代码的工程师阅读和编写其他Python代码的频率比阅读和编写C++代码的频率高得多。每当我们的工程师需要查找一些东西或引用外部代码片段时，我们就要花费他们额外的精力。每次我们试图将代码片段导出到开源时，我们都会经历很多痛苦，花时间来协调我们的内部代码和我们想要加入的外部世界之间的差异。

当 *Starlark* (一种在谷歌设计的基于Python的语言，作为构建描述语言)拥有自己的风格指南的时候，我们选择使用四个空格的缩进来与外部世界保持一致。

-----

如果约定已经存在，那么组织与外界保持一致通常是个好主意。 对于小的、独立的和短暂的努力，这可能不会有什么不同；内部一致性比项目有限范围之外发生的任何事情都更重要。 一旦时间的流逝和潜在的可伸缩性成为因素，你的代码与外部项目交互甚至最终出现在外部世界的可能性就会增加。 从长远来看，坚持广泛接受的标准可能会有回报。

# 避免容易出错和令人惊讶的构造

我们的风格指南限制了我们使用的语言中一些更令人惊讶、不寻常或棘手的结构的使用。复杂的特征往往有细微的陷阱，乍一看并不明显。使用这些特性而不彻底理解它们的复杂性，很容易误用它们并引入bug。即使一个构造被项目的工程师很好地理解，未来的项目成员和维护者也不能保证有相同的理解。

这种推理是在我们的Python风格指南规则的背后，以避免使用反射等强大的功能。反射Python函数 hasattr() 和 getattr() 允许用户使用字符串访问对象的属性:

```python
 if hasattr(my_object, 'foo'):
    some_var = getattr(my_object, 'foo')
```

现在，有了这个例子，一切似乎都很好。 但是考虑一下这个:

```python
some_file.py:
    A_CONSTANT = [
        'foo',
        'bar',
        'baz',
    ]
other_file.py:
    values = []
    for field in some_file.A_CONSTANT:
        values.append(getaattr(my_object, field))
```

当搜索代码时，你如何知道字段foo、bar和baz在这里被访问？ 没有明确的证据留给读者。 您不容易看到，因此也不容易验证哪些字符串用于访问对象的属性。 如果我们不是从常量中读取这些值，而是从远程过程调用请求消息或数据存储中读取它们呢？ 这种混淆代码可能会导致一个重要的安全缺陷，一个很难注意到的缺陷，只需错误地验证消息。 测试和验证这样的代码也很困难。

Python的动态特性允许这种行为，在非常有限的情况下，使用 hasattr() 和 getattr() 是有效的。 然而，在大多数情况下，它们只会引起混淆并引入bug。

虽然这些高级语言特性对于一个知道如何利用它们的专家来说可能完美地解决了一个问题，但是高级特性通常更难理解，并且没有被广泛使用。 我们需要所有能够在代码库中操作的工程师，而不仅仅是专家。 这不仅仅是对软件工程师新手的支持，对软件工程师来说也是一个更好的环境——如果一个 SRE 正在调试一个生产中断，他们会跳到任何可疑的代码中，甚至是用他们不熟悉的语言编写的代码。 我们更重视简化、简单、易于理解和维护的代码。

# 承认实用性

用拉尔夫·沃尔多·爱默生的话说:"愚蠢的一致性是心胸狭隘的人的大恶魔。" 在我们寻求一个一致、简化的代码库的过程中，我们不想盲目地忽略其他一切。 我们知道，我们的风格指南中的一些规则会允许遇到例外的情况，这没关系。 必要时，我们允许对可能与我们的规则冲突的优化和实用性做出让步。

性能很重要。 有时，即使这意味着牺牲一致性或可读性，也只是为了适应性能优化。 例如，虽然我们的C++风格指南禁止使用异常，但它包含了一个允许使用 noexcept 的规则，这是一种与异常相关的语言说明符，可以触发编译器优化。

互操作性也很重要。 为特定的非谷歌部分设计的代码，如果为其目标定制，可能会做得更好。 例如，我们的C++样式指南包含了一个通用骆驼拼写法命名准则的例外，该准则允许对模拟标准库特性的实体使用标准库的snake_case样式。 《C++风格指南》还允许对Windows编程进行豁免，在Windows编程中，与平台功能的兼容性需要多重继承，这是所有其他C++代码都明确禁止的。 我们的Java和JavaScript风格指南都明确指出，生成的代码(经常与项目所有权之外的组件交互或依赖于这些组件)超出了指南规则的范围。 一致性至关重要；适应是关键。

# 风格指南

那么，什么是语言风格指南呢？ 所有样式指南规则大致分为三类:

***避免危险的规则***

***实施最佳实践的规则***

***确保一致性的规则***

# 避免危险

首先也是最重要的，我们的风格指南包含了语言特性的规则，这些规则是出于技术原因而必须或不必须做的。我们有关于如何使用静态成员和变量的规则；关于使用lambda表达式的规则；关于处理异常的规则；关于构建线程、访问控制和类继承的规则。 我们讨论了使用哪些语言特性和避免哪些构造。 我们列出了可能使用的标准词汇类型以及使用目的。 我们特别包括难以使用和难以正确使用的规则——一些语言功能具有微妙的使用模式，这些模式可能不直观或不容易正确应用，从而导致潜在的漏洞。 对于《指南》中的每一项裁决，我们的目标是包括权衡的利弊，并对所达成的决定进行解释。 这些决策大多基于对时间弹性的需求，支持和鼓励可维护的语言使用。

# 实施最佳实践

我们的风格指南还包括一些执行编写源代码的最佳实践的规则。 这些规则有助于保持代码库健康和可维护。 例如，我们指定代码作者必须包含注释的位置和方式。 我们的注释规则涵盖了注释的一般约定，并扩展到包括必须包含代码内文档的特定情况——意图并不总是显而易见的情况，例如switch语句中的漏检、空异常捕获块和模板元编程。 我们也有详细说明源文件结构的规则，概述预期内容的组织。 我们有命名规则:包、类、函数、变量的命名。 所有这些规则都是为了指导工程师去实践支持更健康、更可持续的代码。

由我们的风格指南实施的一些最佳实践旨在使源代码更加易读。 许多格式规则都属于这一类别。 我们的样式指南指定了何时以及如何使用垂直和水平空白来提高可读性。 它们还包括线路长度限制和支架对齐。 对于某些语言，我们通过遵从自动套用格式工具来满足格式要求——gofmt for Go，dartfmt for Dart。逐项列出格式要求的详细列表或命名必须应用的工具，目标是相同的:我们有一套一致的格式规则，旨在提高我们应用于所有代码的可读性。

我们的风格指南还包括对新的以及尚未被很好理解的语言特性的限制。 我们的目标是在学习过程中，先发制人地围绕一个特性的潜在缺陷安装安全防护。 与此同时，在每个人都开始运行之前，限制使用给了我们一个观察使用模式的机会，这些模式从我们观察到的例子中开发和提取最佳实践。 对于这些新特性，在开始时，我们有时不确定要给出的正确指导。 随着采用的推广，希望以不同方式使用新功能的工程师与风格指南所有者讨论他们的例子，要求允许超出最初限制的额外用例。 看着弃权请求的到来，我们了解了这个特性是如何被使用的，并最终收集了足够的例子来总结好的实践。 在获得这些信息后，我们可以回到限制性裁决，并对其进行修改，以允许更广泛的使用。

# 案例研究:介绍 std::unique_ptr

当C++11引入std::unique_ptr(一种智能指针类型，表示动态分配对象的独占所有权，并在unique_ptr超出范围时删除该对象)时，我们的样式指南最初不允许使用。 对大多数工程师来说，unique_ptr的行为是不熟悉的，该语言引入的相关移动语义是非常新的，对大多数工程师来说，这非常混乱。 防止在代码库中引入std::unique_ptr似乎是更安全的选择。 我们更新了工具，以捕捉对不允许的类型的引用，并保持我们现有的指南推荐其他类型的现有智能指针。

时光流逝。 工程师们有机会适应移动语义的含义，我们越来越相信使用std::unique_ptr直接符合我们风格指南的目标。 std::unique_ptr在函数调用站点提供的关于对象所有权的信息使读者更容易理解代码。 引入这种新类型所增加的复杂性，以及随之而来的新颖的移动语义，仍然是一个强烈的关注点，但是代码库的长期整体状态的显著改善使得std::unique_ptr的采用成为一个值得权衡的问题。

# 建立一致性

我们的风格指南也包含了涵盖许多小东西的规则。 对于这些规则，我们制定和记录决策主要是为了制定和记录决策。 这一类别中的许多规则没有显著的技术影响。 命名惯例、缩进间距、导入顺序:一种形式相对于另一种形式通常没有明确的、可衡量的技术优势，这可能是技术社区倾向于不断讨论它们的原因。 通过选择一个，我们已经脱离了无休止的辩论循环，可以继续前进了。 我们的工程师不再花时间讨论两个空间还是四个空间。 这类规则的重要部分与其说是我们为给定的规则选择了什么，不如说是我们选择了这个事实。

# 对于其他一切...

尽管如此，我们的风格指南中还有很多东西没有包括在内。 我们试图关注对我们代码库健康影响最大的事情。 这些文档中绝对有未指明的最佳实践，包括许多好的工程建议的基本部分:不要聪明，不要分叉代码库，不要重新发明轮子，等等。 像我们的风格指南这样的文档不能让一个完全的新手完全理解软件工程——有些事情我们是假设的，这是有意的。

# 改变规则

我们的风格指南不是一成不变的。 和大多数事情一样，随着时间的推移，风格指导决策的环境和指导给定规则的因素可能会发生变化。 有时，情况的变化足以保证重新评估。 如果发布了新的语言版本，我们可能需要更新规则来允许或排除新的特性和习惯用法。 如果一个规则导致工程师投入精力来规避它，我们可能需要重新检查这个规则应该提供的好处。 如果我们用来执行规则的工具变得过于复杂，维护起来过于繁琐，那么规则本身可能已经衰退，需要重新审视。 注意到一个规则何时准备好了另一个外观是保持我们的规则集相关和最新的过程的重要部分。

在我们的风格指南中捕捉到的规则背后的决定是有证据支持的。 添加规则时，我们会花时间讨论和分析相关的利弊以及潜在的后果，试图验证给定的更改是否适合谷歌的运营规模。 谷歌风格指南中的大多数条目都包括这些考虑因素，列出了在此过程中权衡的利弊，并给出了最终裁决的理由。 理想情况下，我们优先考虑这个详细的推理，并将其包含在每个规则中。

记录一个给定决策背后的推理给了我们一个优势，那就是能够识别什么时候事情需要改变。 鉴于时间的推移和不断变化的条件，以前做出的好决定可能不是当前最好的决定。 随着影响因素被清楚地记录下来，我们能够识别与这些因素中的一个或多个相关的变化何时需要重新评估规则。

# 案例研究:骆驼案例命名

在谷歌，当我们为Python代码定义最初的风格指南时，我们选择使用骆驼命名法命名风格而不是snake_case命名风格来命名方法名。 虽然公共Python风格指南(PEP 8)和大多数Python社区都使用snake_case命名，但谷歌当时的大多数Python使用都是针对在C++代码基础上使用Python作为脚本层的C++开发人员。 许多已定义的Python类型都是对应的C++类型的包装器，而且因为谷歌的C++命名约定遵循CamelCase风格，所以跨语言的一致性被视为关键。

后来，我们达到了构建和支持独立的Python应用程序的地步。 最常使用Python的，是Python工程师用来开发Python项目，而不是C++工程师编写脚本。 我们给我们的Python工程师带来了一定程度的不顺和可读性问题，要求他们为我们的内部代码维护一个标准，但每次引用外部代码时都要不断地为另一个标准进行调整。 我们也让有Python经验的新员工更难适应我们的代码库规范。

随着Python项目的增长，我们的代码更频繁地与外部Python项目交互。 我们在一些项目中引入了第三方Python库，在我们的代码库中混合了我们自己的骆驼命名法格式和外部首选的snake_case样式。 当我们开始开源我们的一些Python项目时，在一个外部世界中维护它们，在这个世界中，我们的约定不符合规范，这增加了我们的复杂性，也增加了来自一个社区的戒心，这个社区发现我们的风格令人惊讶，有些奇怪。

有了这些论点，在讨论了成本(失去与其他谷歌代码的一致性，对习惯我们Python风格的谷歌人进行再教育)和好处(获得与大多数其他Python代码的一致性，允许第三方库已经泄漏的内容)之后，Python风格指南的风格仲裁器决定改变规则。 随着它作为一个文件范围的选择应用的限制，对现有代码的豁免，以及项目决定什么是最适合他们的自由，谷歌Python风格指南被更新以允许snake_case命名。

# 过程

认识到事情需要改变，考虑到我们的目标是长寿命和扩展能力，我们创建了一个更新规则的过程。 改变我们的风格指南的过程是基于解决方案的。 样式指南更新的建议就是基于这个观点，识别一个存在的问题，并提出建议的变更作为解决问题的方法。 在这个过程中，“问题”不是可能出错的假设例子；现有谷歌代码中发现的模式证明了问题。 给定一个演示的问题，因为我们有现有风格指南决策背后的详细推理，我们可以重新评估，检查不同的结论现在是否更有意义。

编写由样式指南管理的代码的工程师社区通常最容易注意到什么时候规则可能需要更改。 事实上，在谷歌，我们的风格指南的大部分变化都是从社区讨论开始的。 任何工程师都可以提问或提出修改建议，通常从专门用于风格指南讨论的特定语言邮件列表开始。

修改样式指南的建议可能是完全成形的，并建议了具体的、更新的措辞，也可能是关于某一规则的适用性的模糊问题。 收到的想法由社区讨论，从其他语言用户那里得到反馈。 一些提议被社区一致拒绝，被衡量不必要的、过于模糊的或无益的。 其他人得到了积极的反馈，这些反馈被认为是有价值的，或者是经过改进的。 这些提案，即那些通过机构群体审查的提案，都要经过最终决策批准。 

# 风格仲裁者

在谷歌，对于每种语言的风格指南，最终的决定和批准是由风格指南的所有者——我们的风格仲裁者——做出的。 对于每种编程语言，一组长期的语言专家是风格指南的所有者和指定的决策者。 给定语言的风格仲裁者通常是该语言库团队的高级成员和其他具有相关语言经验的长期谷歌人。

任何样式指南变更的实际决策都是对建议修改的工程权衡的讨论。 仲裁者在风格指南优化的商定目标的背景下做出决定。 改变不是根据个人喜好来做的；它们是权衡判断。 事实上，C++风格仲裁器组目前由四个成员组成。 这可能看起来很奇怪:委员会成员人数为奇数将防止在分裂决定的情况下票数相等。 然而，由于决策方法的性质，没有什么是“因为我认为应该这样”，一切都是一种权衡的评估，决策是通过协商一致而不是投票做出的。 这个四人小组运转良好。

# 例外

是的，我们的规则是法律，但是是的，有些规则允许例外。 我们的规则通常是为更大的一般情况而设计的。 有时，特定情况会受益于对特定规则的豁免。 当出现这种情况时，会咨询样式仲裁器，以确定是否存在授予特定规则的豁免的有效案例。

弃权不是轻易批准的。 在C++代码中，如果引入了宏API，样式指南要求使用特定于项目的前缀来命名它。 由于C++处理宏的方式，将它们视为全局命名空间的成员，从头文件导出的所有宏必须具有全局唯一的名称，以防止冲突。 关于宏命名的样式指南规则允许仲裁器对一些真正全局的实用宏进行豁免。 但是，当豁免请求背后要求排除特定项目前缀的原因归结为由于宏名称长度或项目一致性的偏好时，豁免被拒绝。 这里，代码库的完整性超过了项目的一致性。

在允许违规比避免违规更有利的情况下，允许有例外。 《C++风格指南》不允许隐式类型转换，包括单参数构造函数。 然而，对于被设计为透明包装其他类型的类型，其中底层数据仍然被精确地表示，允许隐式转换是完全合理的。 在这种情况下，可以放弃非隐含转换规则。 拥有如此明确的有效豁免案例可能表明，有关规则需要澄清或修正。 但是，对于此特定规则，收到了足够多的豁免请求，这些请求看似符合有效的豁免情形，但实际上并不符合——要么是因为所讨论的特定类型实际上不是透明的包装类型，要么是因为该类型是包装类型，但实际上并不需要——因此保持规则不变仍然是值得的。

但是，对于那些包含其他类型的构造函数，其仍需要保留基础数据
并把它们准确地表示出来，因此允许某些数据进行隐式转换是完全合理的。
在这种情况下，可以免除非隐式转换规则。又一个如此明确的例外案例的存在
可能表示相关规需要被修改。但是，对于该特定规则，似乎足够的豁免请求可以
使其符合例外的情况，但实际情况并非如此：因为所讨论的特定类型实际上并
不是一个含义清楚的包装类型，或者说即使此类型是包装类型，但实际上不是必需的，
因此可以保留现存的规则照仍然是合理的。
#### 指导
除规则外，我们还以各种形式提供编程指南，所涵盖的范围从
长期、深入地讨论复杂的主题，到针对最佳实践提供简短，针对性的并被我们所
认可的建议。

“指导”部分展示了我们工程经验的汇集，该部分总结了我们从整个课程中学到的
最佳实践。指导部分往往集中在这些事情上，比如我们观察到的人们经常会犯错的
的地方，不熟悉的新事物，这会造成事情的一团糟。如果规则是“musts”，那么我们的指导
就是“shoulds”。

我们所设计的“指导”部分的一个缩影就是针对我们所使用的主要语言的通识教育。
尽管我们的风格指南符合一定的规范，但是关于“语言风格”的使用与否，哪些语言的引言是
具有描述性的(比如，可以解释指南认可的功能)。他们的范围很广涵盖范围，涉及该语言的
新手工程师几乎涉及的每个主题在Google上使用时需要参考。他们没有深入研究给定的每个细节
主题，但它们提供了解释和建议的用法。当工程师需要时为了弄清楚如何应用他们想要使用的功能，
引物旨在充当入门指南。

几年前，我们发布了一系列C ++小帖士、小技巧，这些技巧融合了
普通语言建议和针对Google的特定提示。我们涵盖了事物-对象的生命周期，
复制和移动语义，依赖于参数的查找；C ++ 11功能在代码库中采用的特性，
预先采用了C ++ 17类型，例如string_view，可选和变体；以及需要
修正-提示者不要使用指令，以及用于寻找隐式布尔转换的警告。这些提示都是来自于
工程师所实际遇到的问题，可用于解决“样式指南”未涵盖的实际编程问题。他们的建议(提示)
与“样式指南”中的规则不同，建议不是真正的标准；它们仍然是在
“建议”的类别范畴而不是“规则”的类别范畴。但是，鉴于它们基于观察所得到的而不是凭空想象出来的，
它们广泛而直接的适用性使它们与众不同。这些提示相对关键并且简洁，用户阅读每个“提示”仅需几十秒。
这个“Tip of the week”系列在Google内部获得了极大的成功，目前正在进行代码审查和技术讨论。<sup>12</sup>

软件工程师进入一个新的项目或者他们即将要使用的语言的代码库时，他们会对如何
在Google内部使用该编程语言感到迷茫。为了弥合这一差距，
我们为每个被用到的编程语言提供了“<Language>@Google 101”课程。这些全日制课程集中于
是什么原因导致了Google内部的代码库与语言本身代码库的差异。它们涵盖了最常用的库和
习惯用法，内部偏好设置和自定义工具的使用情况。对于一个即将成为Google C++工程师的C++
工程师来说，此课程不仅会将造就他们成为一位优秀的工程师，也会帮助他们成为一位优秀的Google
工程师。

除了通过课程指导某个不了解工作流程的工程师快速熟悉工作，我们
也在更深层次上比如代码库中也是准备了很多的指导，从而可以更好地
帮助工程师成长。这些引用或者解释涵盖了我们所使用的语言。一些有用的参考
如下所示：
+ 针对特定领域的语言建议，这部分领域很难做得优秀（例如并发和哈希）。
+ 语言更新引入后相关新功能的详细细分以及有关如何在代码库中使用它们的建议。
+ 列出代码库中所提供的关键抽象以及数据结构。这可以使得我们避免重新塑造一个已经存在的数据结构。

### 运用规则
从本质上讲，规则在可执行时具有更大的价值。规则可以是
通过教学和培训以社会方式实施，或通过工具进行技术上的实施。我们有
Google提供的各种正式培训课程，涵盖了许多我们所要求的最佳实践。
我们还投入资源以使我们的文档保持最新，确保参考材料保持准确和最新。
当涉及到对于规则的知晓和理解时，我们总体训练方法的关键部分就是“代码审查”
所扮演的角色。在Google内部，对于使用特定语言的Google工程师，我们会基于“代码审查”
对该工程师进行指导，这有助于其养成良好的习惯和样式指南所要求的模式(详情观看 Chapter 3)。
这个过程是很重要的，可以帮助我们确保工程师切实学习了相关操作并将其付诸实践。
> 12 https://abseil.io/tips精选了一些我们最受欢迎的提示。

尽管一定程度的培训是不可避免的，但是工程师们必须学习这些规则，
以便他们可以编写遵循这些规则的代码从而达到合规性，而不是仅仅依赖于工程师的验证，我们
非常喜欢使用工具来自动执行。

自动化的规则实施可确保规则不会随着时间流逝或者组织规模的扩大而被丢失或遗忘。
新人加入；他们可能还不知道全部规则。规则会随着时间而变化；即使沟通良好，不是每个人都会
记住一切的当前状态。项目不断发展并增加了新功能；之前的规则突然不在适用。
工程师基于记忆或者文档来检查之前规则的兼容性，很可能会失败。但是如果我们将自动化工具持续更新，
并同步规则的更改，我们就知道所有工程师都将把规则应用到所有的项目之中。

自动化工具的另一个优势是最大程度地减少了规则的解释与应用。
当我们编写脚本或使用工具检查规则的兼容性时，我们根据一个固定的规则来验证所有的输入。
我们不会将解释权交给每个工程师。人类工程师难免会带有偏见的审查所有内容。有无刻意、
潜在的微妙甚至无害的偏见仍然会改变人们对事物的看法。这就会导致规则的非一致的解释与使用，
也会伴随着非一致的对于规则的期许。自动化工具做得越多，工程师对于事物潜在的偏见就会更少。

工具是具有扩展性。随着组织的发展，一个单一的团队
专家可以编写公司其余人员可以使用的工具。如果公司规模翻倍，
那么在整个组织内执行所有规则的工作总量就不会翻倍，并且费用与以前差不多。

即使我们整合相关工具获得了一定的方便，但是这并不意味着可以自动化执行所有的规则。
比如一些技术性规则明确要求“人为判断”。例如，在“C ++样式指南”中：“避免使用复杂
meta-programming。”“使用自动生成的类型名称而不要去特意为之命名，特别的命名是杂乱无章的、
也不利于读者理解。”“Composition通常是比inheritance更合适。”在Java样式指南中：“对于‘声明、初始化一个类的成员’没有唯一的方法，不同的类会以不同的方法声明自己类的内容。” “此外，重写‘Object.finalize’方法是极端罕见的”。
对于所有的规则来说，“评判”都是需要的，工具是不能代替的。

其他规则是社会类型的的而不是技术类型的，并且大多数情况下使用技术手段
去解决社会问题是不明智的。对于属于此类别的许多规则，细节往往定义不清，工具会变得复杂，
并且通常也是花费较高的。通常情况下最好将这些规则的执行权交给人类。
例如，当涉及到给定代码所更改规模的大小时（比如，受影响的文件数量
以及被修改的文件的行），我们建议工程师着眼于较小的更改。较小的变更对于
工程师来说审查起来会更容易，因此审查往往是更快的，也是更彻底的。
它们也不太可能引入错误，因为基于它们更容易推理出错误，对于较小变化的潜在影响也容易把握。
但是，small的定义是有点模糊的。在数百个文件之间传播相同文件的单行更新或许是很容易察觉的。
相比之下，文件中较小的20行变化可能会引入难以评估的极大的逻辑副作用。
我们认识到，有许多不同的测量方法，其中有一些测量方法在评估更改所带来的复杂性时会有很强的主观性。 
这就是为什么当更改超过行数限制的时候，我们没有任何工具可以自动拒绝。
当审查人员评定一个更改带来的影响太大了之后，他们可以撤回更改。
对于此规则，执行权由编写和审查代码的工程师自主解决。但是，当涉及到技术规则时，
只要可行，我们都倾向于技术执行。

### 错误检查
包含了语言用处的规则可以通过静态分析工具实现强化。事实上，在2018年中期一些
C++库的工作人员对C++的样式指南进行过非正式调查，该调查结果表明，大约90％
的规则都可以自动验证。“错误检查”工具采用一组规则或模式，并验证给定的代码示例是否完整
遵守。自动验证消除了记住代码作者所创建的适用规则所带来的负担。如果工程师只需要查找违规警告，
很多警告其中带有相关建议的修复程序，这些修复程序均来自涉及工作流较深的分析人员的代码审查工作，
我们最小化遵循这些规则所要付出的努力。当我们使用工具基于源代码去标识过期功能时，会同时显示警告和
修复提示，这样的话令人讨厌的过时API的新用法一夜之间就消失了。降低服从成本可以使工程师更愉快地遵守规则。

我们使用clang-tidy和Error Error Prone之类的工具来自动化规则的执行过程。有关方法的深入讨论，请参见第20章。

我们所使用的工具旨在支持我们所定义的规则。大多数支持规则的工具都是绝对的；每个人都必须遵守规则，所以
每个人都要使用工具。有时，当工具支持最佳实践时-在符合约定的灵活性更高的地方，是可以选择“退出机制”的，使得项目可以根据需要进行调整。

### 代码格式
在Google，我们通常使用自动样式检查器和格式来保持代码的一致性。一行代码长度的问题不再出现。
工程师只需要运行样式检查器，就可以继续前进。当代码每次都以相同的格式被规范时，
在“代码审查”过程中就不会产生问题，消除了原本用于查找，标记和审核的审核周期。

在管理有史以来最大的代码库时，我们有机会观察到了工程师所实现的“代码规范”结果
并与自动化工具所实现的“代码规范”结果进行了对比。大量实验表明，自动化工具比工程师所完成的工作好得多。
但是也有一些领域，在某些专业领域中人类通常会比一个通用的规范工具做的更好，比如设置领域矩阵的格式。自动化
样式检查器在规范代码方面很少会出错。

我们会在代码提交前的检查来使用这些“规范化”工具：在代码提交之前，会有一个服务来检查在代码上
运行“代码规范化”工具会不会产生不同。如果是这样，则该代码会被拒绝提交，与此同时，会给出如何运行规范化工具来修改代码
的相关指导。Google上的大多数代码都必须经过此类提交检查。对于我们的代码，在C ++中我们使用clang-format，在Python中我们使用
yapf，在Go中使用gofmt，在Dart中使用dartfmt；针对BUILD文件我们使用buildfier。

### 案例研究: gofmt
##### Sameer Ajmani
Google于2009年11月10日将Go编程语言作为开源发布，
从那时起，Go成为一种用于开发服务，工具和云基础设施和开源软件的语言。<sup>14</sup>

从第一天开始，我们就知道我们需要Go代码的标准格式。我们也知道
将Go语言开源发布以后去修改其标准的格式几乎是不可能实现的。因此，最初的Go发行版本包括gofmt（Go语言的规范化工具）。

>13 当您认为至少需要两名工程师进行讨论时，这种对话有可能在30,000多名工程师中间发生，“how many characters”
会是一个非常昂贵的问题。
>
>14 2018年12月，基于“pull requests”进行统计，Go语言是GitHub上排名第四的语言。
##### 动力
代码审查是软件工程的最佳实践，但是大家花费了太多时间在争论上而不是代码的“规范化”上。
尽管标准形式不能满足所有人的喜欢，但是“规范形式”工具可以消磨掉所浪费的时间。<sup>15</sup>

通过标准化格式，我们为规范化工具的使用打下了基础，其可以在无需创建差异性的情况下实现Go代码的升级：
机器所编辑的代码与工程师所编辑的代码是没有区别的。<sup>16</sup>

例如，在2012年推出Go 1.0之前的几个月中，Go团队使用了一种名称为gofi的工具，
其可以将1.0之前的Go代码自动更新为稳定版本的语言和语法库。多亏了gofmt，gofix所导致的差异仅包含
重要信息：更改语言和API的用法。这允许程序员
以便更轻松地查看更改并学习工具所实现的更改。

##### 影响
Go程序员希望所有Go代码都使用gofmt进行规范化。 gofmt没有配置旋钮，其行为很少改变。
所有主要的编辑器和IDE都使用gofmt工具或着模拟它的行为，因此几乎所有现有的Go代码都经过规范化。
刚开始，Go用户抱怨强制性的标准；现在，用户表示gofmt的存在是他们喜欢Go语言的重要原因。
即使阅读不熟悉的Go语言代码，规范标准也是很熟悉的。

成千上万的开源软件包读取并且编写Go语言代码。<sup>17</sup> 因为全部的编辑器和IDE遵从Go语法规范，
Go工具通过命令行也可以方便地集成到新的开发者环境或者工作流之中。

##### 重调整
2012年，我们决定使用新的规范化格式重新规范Google上的所有BUILD文件
这个规范化格式正是buildifier。 BUILD文件包含用于使用Blaze构建Google软件以及Google开发系统的规则。
标准的BUILD格式将使我们能够自动编辑BUILD文件而不需要干扰它们的规范，就像Go工具处理Go文件一样。

一位工程师花了六周的时间规范了Google中200000个BUILD文件，这些文件被不同的代码创建者所接受，
其中超过1000个文件每周都会被增添内容。并且，Google初期的针对大规模文件变化的基础设施也加速了这个过程的
实现。(详情见Chapter 22)

> 15 Robert Griesemer在2015年的演讲“he Cultural Evolution of gofmt”中详细介绍了gofmt在Go语言以及其他语言上的动机，设计及影响。
>
> 16 Russ Cox在2009年谈到gofmt是关于“自动更改”的：“因此我们具有一个程序操作最困难的部分，gofmt是我们可以使用的。接受
‘gofmt style’是我们在有限数量的代码中可以做的。”
>
> 17 Go AS和format软件包都有成千上万的用户。

### 结论
对于任何组织，尤其是对于拥有Google工程师这样工程能力的组织来说，
规则可以帮助我们管理复杂性并建立可维护的代码库。一种
共享的规则集构建了工程流程，以便它们可以扩展并
保持增长，同时保持代码库和组织在接下来长期一段时间中的可持续发展。

### TL;DRs
+ 规则和指南应旨在支持对于时间和规模的恢复能力。
+ 了解数据，以便可以调整规则。
+ 并非所有事情都应成为规则。
+ 一致性是关键。
+ 尽可能自动执行。

