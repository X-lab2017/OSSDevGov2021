# 第八章 样式指南和规则

*作者 Shaindel Schwartz* 

*编辑 Tom Manshreck*

大多数工程组织都有管理代码库的规则——关于源文件存储的位置的规则、关于代码格式的规则、关于命名、模式、异常和线程的规则。大多数软件工程师都在一组规定他们如何进行操作的策略下工作。在谷歌，为了管理我们的代码库，我们维护了一组定义规则的风格指南。

规则是法律。它们不仅仅是建议或推荐的规范，而是严格的、强制性的法律。因此，它们是普遍的强制执行的——除非确实有需要且经过批准，规则不能被忽视。与规则相反，指导提供建议和最佳实践。遵循这些规则是好的，甚至是非常明智的，但与规则不同的是，它们通常有一些变化的空间。

我们从我们的编程风格指南中收集我们定义的编写代码时必须遵循的注意事项，它们被视为规范。“风格”可能在这里有点用词不当，这意味着一个仅限于格式化实践的集合。我们的风格指南不仅仅是这些；它们是管理我们代码的一整套约定。这并不是说我们的风格指南是严格规定的；风格指南规则可能需要判断，比如使用"尽可能合理地描述"的命名的规则。相反，我们的风格指南作为规则的权威来源，工程师要对此负责。

我们为谷歌上使用的每种编程语言维护单独的风格指南<sup>1</sup>。在更高的层面，所有的指南都有相似的目标，旨在引导代码注重可持续性的发展。同时，它们之间在范围、长度和内容上也有很大的差异。在谷歌不断发展的代码存储库中，编程语言具有不同的优势、不同的特性、不同的优先级和不同的历史采用路径。因此，独立定制每种语言的指导方针要实用得多。我们的一些风格指南很简明，专注于一些总体原则，如命名和格式化，如我们的Dart、R和SHELL指南中所示。其他风格指南包括更详细的内容，深入研究特定的语言特性，并扩展到更长的文档——尤其是我们的C++、Python和Java指南。一些风格指南强调了非谷歌对该语言典型地使用——我们的Go风格指南非常短，只在总结指令中添加了一些规则，以遵守外部公认的惯例中概述的实践。其他规则包括从根本上不同于外部规范的规则；我们的C++规则不允许使用异常，这是一种在谷歌代码之外广泛使用的语言特性。

即使是我们自己的风格指南之间，差异也很大，这使得我们很难确定一个风格指南应该涵盖什么内容。引导谷歌风格指南发展的决策源于保持我们代码库可持续性的需要。其他组织的代码库本身就对可持续性有不同的要求，这需要一套不同的定制规则。本章讨论了指导我们规则和指南开发的原则和过程，主要从Google的C++、Python和Java风格指南中借鉴例子。

## 为什么要有规则？

那么，我们为什么要有规则呢？制定规则的目标是鼓励“好”地行为，并阻止“坏”的行为。对“好”和“坏”的解释因组织而不同，这取决于组织的关心内容。这样的设计并非普遍的偏好；好与坏是主观的，是根据需要量身定制的。对于某些组织来说，“好的”可能会促进支持少量内存占用，或优先考虑潜在的运行时优化的使用模式。在其他组织中，“好的”可能会促进使用新语言功能的选择。有时，一个组织最关心一致性，所以任何与现有模式不一致的东西都是“糟糕的”。我们必须首先认识到一个给定的组织所看重的，并使用规则和指南来鼓励和阻止相应的行为。

随着组织的发展，既定的规则和指导方针形成了编码的通用词汇表。通用词汇允许工程师集中于代码需要表达的内容，而不是怎么表达。通过构造这个词汇表，工程师会倾向于做一些“好的”事情，甚至是下意识地。因此，规则为我们提供了广泛的杠杆作用，以向期望的方向推动共同的开发模式。

## 正在创建这些规则

在定义一组规则时，关键问题不是“我们应该有什么规则？”，要问的问题是“我们试图推进什么目标？”。当我们关注规则将服务的目标时，确定哪些规则支持这一目标，会更容易地提炼一套有用的规则。在谷歌，风格指南是代码实践的法律，我们不会问，“风格指南是什么？”，而是问，“为什么要在风格指南中加入这些内容？”，通过拥有一套规则来规范代码的编写，我们的组织可以获得什么？

### 指南原则

让我们来看一看：谷歌的工程组织由3万多名工程师组成。这个工程群体在技能和背景上表现出巨大的差异。每天大约有6万条文件被提交到一个可能存在数十年的20多亿行代码的代码库上。我们正在为一套与大多数其他组织的需求不同的价值需要进行优化，但在某种程度上，这些问题无处不在——我们需要维持一个既能适应规模又能适应时间的工程环境。

在这种情况下，我们的规则的目标是管理我们的开发环境的复杂性，保持代码库的可管理性，同时仍然允许工程师高效地工作。我们在这里做出权衡：帮助我们实现这一目标的大量规则确实意味着我们正在限制选择。我们失去了一些灵活性，甚至可能冒犯一些人，但是，由权威标准提供的一致性和减少冲突的收益最终胜出。

鉴于这一观点，我们认识到一些指导我们的规则发展的首要原则，这些原则必须：

- 满足实际需要
- 为读者进行优化
- 保持一致
- 避免容易出错和令人惊讶的结构
- 必要时应遵守实际情况

#### 规则必须满足实际需要
并不是所有的东西都应该进入风格指南。要求组织中的所有工程师学习和适应任何设定的新规则都不是零成本的。由于规则过多<sup>2</sup>，不仅工程师在编写代码时更加难以记住所有的规则，新工程师也更加难以学习。更多的规则也使维护规则集更具有挑战性，代驾更昂贵。

为此目的，我们故意选择不在指南中包括那些应该不言自明的规则。谷歌的风格指南并不是为了以合法的方式来解释；仅仅因为某些东西没有被明确禁止，并不意味着它是合法的。比如，C++风格指南没有规则禁止使用goto。C++程序员已经倾向于避免它，因此在规则指南中包括进一个禁止它的明确规则将会引入不必要的开销。如果只有一两个工程师出了问题，通过创造新规则来增加每个人的精神负担是行不通的。

#### 为读者进行优化

我们的规则的另一个原则是为代码的读者而不是作者进行优化。随着时间的推移，我们的代码被阅读频率将比编写要频繁得多。我们宁愿输入冗长乏味的代码，也不愿难以阅读它。在我们的Python风格指南中，当讨论条件表达式时，我们认识到它们比如果语句更短，因此对代码作者更方便。然而，由于它们对读者来说比任何陈述都更难理解，我们限制了它们的使用。我们重视“简单易读”而不是“简单易写”。“我们在这里进行权衡：当工程师必须重复输入变量和类型的描述性名称时，可能会花费更高的成本。我们选择为它为所有未来读者提供的可读性支付这个成本。

作为优先级的一部分，我们还要求工程师在他们的代码中留下关于预期行为的明确证据。我们希望读者在阅读该代码时能清楚地了解该代码在做什么。例如，我们的Java、JavaScript和C++会指示每当方法重写超类方法时，强制使用覆盖注释或关键字。如果没有明确的设计证据，读者可能会弄清楚这个意图，尽管每个读者理解代码时需要更深入的挖掘。

意图行为的证据在可能令人相对吃惊的时候变得更加重要，在C++中，有时仅仅通过读取代码片段就很难跟踪指针的所有权。如果将指针传递给一个函数，而不熟悉该函数的行为，我们就无法确定将会发生什么。调用者仍然拥有这个指针吗？这个函数拥有所有权了吗？我可以在函数返回后继续使用指针吗?或者它可能已经被删除了?为了避免这个问题，我们的C++风格指南更喜欢在打算进行所有权转移时使用std::unique_ptr。unique_ptr是管理指针所有权的结构，确保指针只有一个副本。当函数将unique_ptr作为参数并打算获取指针的所有权时，调用者必须显式地调用转移语义：

```c++
// Function that takes a Foo* and may or may not assume ownership of
// the passed pointer.
void TakeFoo(Foo* arg);
// Calls to the function don’t tell the reader anything about what to
// expect with regard to ownership after the function returns.
Foo* my_foo(NewFoo());
TakeFoo(my_foo);
```

请将其与以下内容进行比较：
```c++
// Function that takes a std::unique_ptr<Foo>.
void TakeFoo(std::unique_ptr<Foo> arg);
// Any call to the function explicitly shows that ownership is
// yielded and the unique_ptr cannot be used after the function
// returns.
std::unique_ptr<Foo> my_foo(FooFactory());
TakeFoo(std::move(my_foo));
```

鉴于风格指南规则，我们保证所有调用处都将包括明确的所有权转移证据，无论何时应用。有了这个信号，代码的代码的阅读者就不需要理解每个函数调用的行为了。我们在API中提供了足够的信息来解释它的交互作用。调用点行为文档确保了代码片段保持可读性和可理解性。我们的目标是进行局部推理，其目标是清楚地了解在调用点上发生的事情，而不需要查找和引用其他代码，包括函数的实现。

大多数涵盖评论的风格指南规则也被设计为支持为读者提供适当证据的目标。文档注释（添加到给定文件前面的块注释、类或函数的块注释）描述了以下代码的设计或意图。实现注释（散布在代码本身中的注释）证明或突出了不明显的选择，解释了棘手的部分，并强调了代码的重要部分。

我们的风格指南的规则涵盖了这两种类型的注释，要求工程师提供另一个工程师在阅读代码时可能会寻找的解释。

#### 保持一致
我们对代码库中一致性的看法与我们应用于谷歌办公机构的理念相似。由于有大量分散的工程人员，团队被分成办公机构，谷歌员工经常发现自己去了其他站点。虽然每个办公机构都保持着其独特的个性，拥抱着当地的风俗和风格，但对于任何完成工作所必需的事情，一切都刻意保持不变。来访的谷歌员工的ID卡刷当地的读卡器；任何谷歌设备都可以使用WiFi; 任何会议室的视频会议设置都具有相同的界面。一个谷歌员工不需要花时间学习如何建立这一切；他们知道，无论他们在哪里，这一切都将是一样的。在办公机构之间移动，仍然很容易完成工作。

这就是我们在源代码中所争取的。一致性是让任何工程师永远不会跳进代码库中不熟悉的部分，并相当快地开始工作的原因。一个本地项目可以有它独特的个性，但它的工具是一样的，它的技术是一样的，它的库是一样的，而且这一切都只是工作。

#### 一致性的优势
尽管不允许办公室定制读卡器或视频会议界面可能会觉得有限制，但一致性的好处远远超过了我们失去的创造性自由。代码也是一样：保持一致有时可能会感到紧张，但这意味着更多的工程师可以用更少的精力完成更多的工作<sup>3</sup>：

- 当代码库在内部的风格和规范保持一致时，编写代码和其他阅读代码的工程师可以关注正在做的事情，而不是如何表示它。在很大程度上，这种一致性允许专家分块<sup>4</sup>。当我们用相同的接口解决问题并以一致的方式格式化代码时，专家们更容易查看一些代码，忽略当前的内容，并了解它在做什么。它还使模块化代码和点复制更容易。由于这些原因，我们非常关注一致的命名约定、公共模式的一致使用以及一致的格式设置和结构。还有许多规则会对一个似乎非常小的问题做出决定，仅仅是为了保证事情只能以一种方式完成。例如，选择用于缩进的空格数或行长度的限制<sup>5</sup>。有一个答案的一致性而不是答案本身才是这里有价值的部分。

- 支持扩展的一致性。工具是组织规模缩放的关键，而一致性代码可以使构建能够理解、编辑和生成代码的工具更容易。如果每个人都有少量不同的代码，那么依赖于一致性的工具的全部好处就无法得到应用——如果一个工具可以通过添加缺少的导入或删除未使用的包含来更新源文件，如果不同的项目为它们的导入列表选择不同的排序策略，那么该工具可能无法在所有地方工作。当每个人都使用相同的组件，当每个人的代码都遵循相同的结构和组织规则时，我们可以投资于在任何地方都能工作的工具，为我们的许多维护任务构建自动化。如果每个团队都需要为同一工具的定制版本进行单独投资，为他们独特的环境量身定制，我们就会失去这种优势。

- 在扩展组织的人力部分时，一致性也会有帮助。随着一个组织的增长，研究代码库的工程师的数量也会增加。保持每个人正在工作的代码尽可能一致，可以提高跨项目的移动性，最大限度地减少工程师切换团队的适应时间，并增强组织随着员工需求波动而灵活调整和适应的能力。不断增长的组织还意味着担任其他角色的人员会与代码进行交互，例如，SREs、库工程师和代码管理员。在谷歌，这些角色通常跨越多个项目，这意味着不熟悉某个团队项目的工程师可能会直接参与该项目的代码工作。跨代码库的一致体验使其更有效。

- 一致性还确保了对时间的弹性。随着时间的推移，工程师们离开项目，新的人加入，所有权转移，项目合并或分裂。努力建立一个一致的代码库可以确保这些转换是低成本的，并允许我们对代码和为此工作的工程师具有几乎不受约束的流动性，从而简化了长期维护所必需的过程。

*5 See 4.2 Block indentation: +2 spaces, Spaces vs. Tabs, 4.4 Column limit:100 and Line Length.*


---
## 大规模地

几年前，我们的C风格指南承诺几乎永远不会改变使旧代码不一致的风格指南规则：“在某些情况下，改变某些风格规则可能有很好的理由，但我们仍然为了保持一致性。”

当码库较小，角落较少时，这是有意义的。

当代码库越来越大时，这就不再是一件需要优先考虑的事情了。这(至少对我们的C风格指南背后的仲裁者来说)是一个有意识的改变：在触及这一点时，我们明确声明C代码库永远不会再完全一致，我们甚至也没有达到这个目标。

不仅将规则更新到当前的最佳实践，而且要求我们将这些规则应用于所有编写的一切，这将是太大的负担。我们的大规模更改工具和流程允许我们更新几乎所有的代码，以遵循几乎每一种新的模式或语法，以便大多数旧代码显示其最新批准的样式（见第22章）。然而，这些机制并不完美；当代码库尽可能大时，我们不能确定所有的旧代码都能符合新的最佳实践。要求完美的一致性已经达到了价值成本过多的程度。

---

**正在设定标准。** 当我们提倡一致性时，我们倾向于关注内部一致性。有时，地方会议在全球会议通过之前就会出现，调整一切以匹配是不合理的。在这种情况下，我们提倡一个更严格的一致性体系：“保持一致性”从本地开始，即给定文件中的规范先于给定团队的规范，先于较大的项目的规范，先于整个代码库的规范。事实上，样式指南包含了一些明确地遵从本地约定的规则，6重视这种本地一致性，而不是科学的技术选择。

然而，一个组织要创建并坚持一组内部约定并不总是不够的。有时，应考虑到外部社区所采用的标准。


# 计算空间

谷歌的Python风格指南最初要求我们所有的Python代码都有两个空格的缩进。外部Python社区使用的标准Python样式指南使用四个空格的缩进。早期的Python开发大多直接支持我们的C++项目，而不是实际的Python应用程序。因此，我们选择使用两个空格的缩进来与我们的C++代码保持一致，因为我们的c++代码已经用这种方式格式化了。随着时间的推移，我们发现这个理论并不成立。 编写Python代码的工程师阅读和编写其他Python代码的频率比阅读和编写C++代码的频率高得多。每当我们的工程师需要查找一些东西或引用外部代码片段时，我们就要花费他们额外的精力。每次我们试图将代码片段导出到开源时，我们都会经历很多痛苦，花时间来协调我们的内部代码和我们想要加入的外部世界之间的差异。

当 *Starlark* (一种在谷歌设计的基于Python的语言，作为构建描述语言)拥有自己的风格指南的时候，我们选择使用四个空格的缩进来与外部世界保持一致。

-----

如果约定已经存在，那么组织与外界保持一致通常是个好主意。 对于小的、独立的和短暂的努力，这可能不会有什么不同；内部一致性比项目有限范围之外发生的任何事情都更重要。 一旦时间的流逝和潜在的可伸缩性成为因素，你的代码与外部项目交互甚至最终出现在外部世界的可能性就会增加。 从长远来看，坚持广泛接受的标准可能会有回报。

# 避免容易出错和令人惊讶的构造

我们的风格指南限制了我们使用的语言中一些更令人惊讶、不寻常或棘手的结构的使用。复杂的特征往往有细微的陷阱，乍一看并不明显。使用这些特性而不彻底理解它们的复杂性，很容易误用它们并引入bug。即使一个构造被项目的工程师很好地理解，未来的项目成员和维护者也不能保证有相同的理解。

这种推理是在我们的Python风格指南规则的背后，以避免使用反射等强大的功能。反射Python函数 hasattr() 和 getattr() 允许用户使用字符串访问对象的属性:

```python
 if hasattr(my_object, 'foo'):
    some_var = getattr(my_object, 'foo')
```

现在，有了这个例子，一切似乎都很好。 但是考虑一下这个:

```python
some_file.py:
    A_CONSTANT = [
        'foo',
        'bar',
        'baz',
    ]
other_file.py:
    values = []
    for field in some_file.A_CONSTANT:
        values.append(getaattr(my_object, field))
```

当搜索代码时，你如何知道字段foo、bar和baz在这里被访问？ 没有明确的证据留给读者。 您不容易看到，因此也不容易验证哪些字符串用于访问对象的属性。 如果我们不是从常量中读取这些值，而是从远程过程调用请求消息或数据存储中读取它们呢？ 这种混淆代码可能会导致一个重要的安全缺陷，一个很难注意到的缺陷，只需错误地验证消息。 测试和验证这样的代码也很困难。

Python的动态特性允许这种行为，在非常有限的情况下，使用 hasattr() 和 getattr() 是有效的。 然而，在大多数情况下，它们只会引起混淆并引入bug。

虽然这些高级语言特性对于一个知道如何利用它们的专家来说可能完美地解决了一个问题，但是高级特性通常更难理解，并且没有被广泛使用。 我们需要所有能够在代码库中操作的工程师，而不仅仅是专家。 这不仅仅是对软件工程师新手的支持，对软件工程师来说也是一个更好的环境——如果一个 SRE 正在调试一个生产中断，他们会跳到任何可疑的代码中，甚至是用他们不熟悉的语言编写的代码。 我们更重视简化、简单、易于理解和维护的代码。

# 承认实用性

用拉尔夫·沃尔多·爱默生的话说:"愚蠢的一致性是心胸狭隘的人的大恶魔。" 在我们寻求一个一致、简化的代码库的过程中，我们不想盲目地忽略其他一切。 我们知道，我们的风格指南中的一些规则会允许遇到例外的情况，这没关系。 必要时，我们允许对可能与我们的规则冲突的优化和实用性做出让步。

性能很重要。 有时，即使这意味着牺牲一致性或可读性，也只是为了适应性能优化。 例如，虽然我们的C++风格指南禁止使用异常，但它包含了一个允许使用 noexcept 的规则，这是一种与异常相关的语言说明符，可以触发编译器优化。

互操作性也很重要。 为特定的非谷歌部分设计的代码，如果为其目标定制，可能会做得更好。 例如，我们的C++样式指南包含了一个通用骆驼拼写法命名准则的例外，该准则允许对模拟标准库特性的实体使用标准库的snake_case样式。 《C++风格指南》还允许对Windows编程进行豁免，在Windows编程中，与平台功能的兼容性需要多重继承，这是所有其他C++代码都明确禁止的。 我们的Java和JavaScript风格指南都明确指出，生成的代码(经常与项目所有权之外的组件交互或依赖于这些组件)超出了指南规则的范围。 一致性至关重要；适应是关键。

# 风格指南

那么，什么是语言风格指南呢？ 所有样式指南规则大致分为三类:

***避免危险的规则***

***实施最佳实践的规则***

***确保一致性的规则***

# 避免危险

首先也是最重要的，我们的风格指南包含了语言特性的规则，这些规则是出于技术原因而必须或不必须做的。我们有关于如何使用静态成员和变量的规则；关于使用lambda表达式的规则；关于处理异常的规则；关于构建线程、访问控制和类继承的规则。 我们讨论了使用哪些语言特性和避免哪些构造。 我们列出了可能使用的标准词汇类型以及使用目的。 我们特别包括难以使用和难以正确使用的规则——一些语言功能具有微妙的使用模式，这些模式可能不直观或不容易正确应用，从而导致潜在的漏洞。 对于《指南》中的每一项裁决，我们的目标是包括权衡的利弊，并对所达成的决定进行解释。 这些决策大多基于对时间弹性的需求，支持和鼓励可维护的语言使用。

# 实施最佳实践

我们的风格指南还包括一些执行编写源代码的最佳实践的规则。 这些规则有助于保持代码库健康和可维护。 例如，我们指定代码作者必须包含注释的位置和方式。 我们的注释规则涵盖了注释的一般约定，并扩展到包括必须包含代码内文档的特定情况——意图并不总是显而易见的情况，例如switch语句中的漏检、空异常捕获块和模板元编程。 我们也有详细说明源文件结构的规则，概述预期内容的组织。 我们有命名规则:包、类、函数、变量的命名。 所有这些规则都是为了指导工程师去实践支持更健康、更可持续的代码。

由我们的风格指南实施的一些最佳实践旨在使源代码更加易读。 许多格式规则都属于这一类别。 我们的样式指南指定了何时以及如何使用垂直和水平空白来提高可读性。 它们还包括线路长度限制和支架对齐。 对于某些语言，我们通过遵从自动套用格式工具来满足格式要求——gofmt for Go，dartfmt for Dart。逐项列出格式要求的详细列表或命名必须应用的工具，目标是相同的:我们有一套一致的格式规则，旨在提高我们应用于所有代码的可读性。

我们的风格指南还包括对新的以及尚未被很好理解的语言特性的限制。 我们的目标是在学习过程中，先发制人地围绕一个特性的潜在缺陷安装安全防护。 与此同时，在每个人都开始运行之前，限制使用给了我们一个观察使用模式的机会，这些模式从我们观察到的例子中开发和提取最佳实践。 对于这些新特性，在开始时，我们有时不确定要给出的正确指导。 随着采用的推广，希望以不同方式使用新功能的工程师与风格指南所有者讨论他们的例子，要求允许超出最初限制的额外用例。 看着弃权请求的到来，我们了解了这个特性是如何被使用的，并最终收集了足够的例子来总结好的实践。 在获得这些信息后，我们可以回到限制性裁决，并对其进行修改，以允许更广泛的使用。

# 案例研究:介绍 std::unique_ptr

当C++11引入std::unique_ptr(一种智能指针类型，表示动态分配对象的独占所有权，并在unique_ptr超出范围时删除该对象)时，我们的样式指南最初不允许使用。 对大多数工程师来说，unique_ptr的行为是不熟悉的，该语言引入的相关移动语义是非常新的，对大多数工程师来说，这非常混乱。 防止在代码库中引入std::unique_ptr似乎是更安全的选择。 我们更新了工具，以捕捉对不允许的类型的引用，并保持我们现有的指南推荐其他类型的现有智能指针。

时光流逝。 工程师们有机会适应移动语义的含义，我们越来越相信使用std::unique_ptr直接符合我们风格指南的目标。 std::unique_ptr在函数调用站点提供的关于对象所有权的信息使读者更容易理解代码。 引入这种新类型所增加的复杂性，以及随之而来的新颖的移动语义，仍然是一个强烈的关注点，但是代码库的长期整体状态的显著改善使得std::unique_ptr的采用成为一个值得权衡的问题。

# 建立一致性

我们的风格指南也包含了涵盖许多小东西的规则。 对于这些规则，我们制定和记录决策主要是为了制定和记录决策。 这一类别中的许多规则没有显著的技术影响。 命名惯例、缩进间距、导入顺序:一种形式相对于另一种形式通常没有明确的、可衡量的技术优势，这可能是技术社区倾向于不断讨论它们的原因。 通过选择一个，我们已经脱离了无休止的辩论循环，可以继续前进了。 我们的工程师不再花时间讨论两个空间还是四个空间。 这类规则的重要部分与其说是我们为给定的规则选择了什么，不如说是我们选择了这个事实。

# 对于其他一切...

尽管如此，我们的风格指南中还有很多东西没有包括在内。 我们试图关注对我们代码库健康影响最大的事情。 这些文档中绝对有未指明的最佳实践，包括许多好的工程建议的基本部分:不要聪明，不要分叉代码库，不要重新发明轮子，等等。 像我们的风格指南这样的文档不能让一个完全的新手完全理解软件工程——有些事情我们是假设的，这是有意的。

# 改变规则

我们的风格指南不是一成不变的。 和大多数事情一样，随着时间的推移，风格指导决策的环境和指导给定规则的因素可能会发生变化。 有时，情况的变化足以保证重新评估。 如果发布了新的语言版本，我们可能需要更新规则来允许或排除新的特性和习惯用法。 如果一个规则导致工程师投入精力来规避它，我们可能需要重新检查这个规则应该提供的好处。 如果我们用来执行规则的工具变得过于复杂，维护起来过于繁琐，那么规则本身可能已经衰退，需要重新审视。 注意到一个规则何时准备好了另一个外观是保持我们的规则集相关和最新的过程的重要部分。

在我们的风格指南中捕捉到的规则背后的决定是有证据支持的。 添加规则时，我们会花时间讨论和分析相关的利弊以及潜在的后果，试图验证给定的更改是否适合谷歌的运营规模。 谷歌风格指南中的大多数条目都包括这些考虑因素，列出了在此过程中权衡的利弊，并给出了最终裁决的理由。 理想情况下，我们优先考虑这个详细的推理，并将其包含在每个规则中。

记录一个给定决策背后的推理给了我们一个优势，那就是能够识别什么时候事情需要改变。 鉴于时间的推移和不断变化的条件，以前做出的好决定可能不是当前最好的决定。 随着影响因素被清楚地记录下来，我们能够识别与这些因素中的一个或多个相关的变化何时需要重新评估规则。

# 案例研究:骆驼案例命名

在谷歌，当我们为Python代码定义最初的风格指南时，我们选择使用骆驼命名法命名风格而不是snake_case命名风格来命名方法名。 虽然公共Python风格指南(PEP 8)和大多数Python社区都使用snake_case命名，但谷歌当时的大多数Python使用都是针对在C++代码基础上使用Python作为脚本层的C++开发人员。 许多已定义的Python类型都是对应的C++类型的包装器，而且因为谷歌的C++命名约定遵循CamelCase风格，所以跨语言的一致性被视为关键。

后来，我们达到了构建和支持独立的Python应用程序的地步。 最常使用Python的，是Python工程师用来开发Python项目，而不是C++工程师编写脚本。 我们给我们的Python工程师带来了一定程度的不顺和可读性问题，要求他们为我们的内部代码维护一个标准，但每次引用外部代码时都要不断地为另一个标准进行调整。 我们也让有Python经验的新员工更难适应我们的代码库规范。

随着Python项目的增长，我们的代码更频繁地与外部Python项目交互。 我们在一些项目中引入了第三方Python库，在我们的代码库中混合了我们自己的骆驼命名法格式和外部首选的snake_case样式。 当我们开始开源我们的一些Python项目时，在一个外部世界中维护它们，在这个世界中，我们的约定不符合规范，这增加了我们的复杂性，也增加了来自一个社区的戒心，这个社区发现我们的风格令人惊讶，有些奇怪。

有了这些论点，在讨论了成本(失去与其他谷歌代码的一致性，对习惯我们Python风格的谷歌人进行再教育)和好处(获得与大多数其他Python代码的一致性，允许第三方库已经泄漏的内容)之后，Python风格指南的风格仲裁器决定改变规则。 随着它作为一个文件范围的选择应用的限制，对现有代码的豁免，以及项目决定什么是最适合他们的自由，谷歌Python风格指南被更新以允许snake_case命名。

# 过程

认识到事情需要改变，考虑到我们的目标是长寿命和扩展能力，我们创建了一个更新规则的过程。 改变我们的风格指南的过程是基于解决方案的。 样式指南更新的建议就是基于这个观点，识别一个存在的问题，并提出建议的变更作为解决问题的方法。 在这个过程中，“问题”不是可能出错的假设例子；现有谷歌代码中发现的模式证明了问题。 给定一个演示的问题，因为我们有现有风格指南决策背后的详细推理，我们可以重新评估，检查不同的结论现在是否更有意义。

编写由样式指南管理的代码的工程师社区通常最容易注意到什么时候规则可能需要更改。 事实上，在谷歌，我们的风格指南的大部分变化都是从社区讨论开始的。 任何工程师都可以提问或提出修改建议，通常从专门用于风格指南讨论的特定语言邮件列表开始。

修改样式指南的建议可能是完全成形的，并建议了具体的、更新的措辞，也可能是关于某一规则的适用性的模糊问题。 收到的想法由社区讨论，从其他语言用户那里得到反馈。 一些提议被社区一致拒绝，被衡量不必要的、过于模糊的或无益的。 其他人得到了积极的反馈，这些反馈被认为是有价值的，或者是经过改进的。 这些提案，即那些通过机构群体审查的提案，都要经过最终决策批准。 

# 风格仲裁者

在谷歌，对于每种语言的风格指南，最终的决定和批准是由风格指南的所有者——我们的风格仲裁者——做出的。 对于每种编程语言，一组长期的语言专家是风格指南的所有者和指定的决策者。 给定语言的风格仲裁者通常是该语言库团队的高级成员和其他具有相关语言经验的长期谷歌人。

任何样式指南变更的实际决策都是对建议修改的工程权衡的讨论。 仲裁者在风格指南优化的商定目标的背景下做出决定。 改变不是根据个人喜好来做的；它们是权衡判断。 事实上，C++风格仲裁器组目前由四个成员组成。 这可能看起来很奇怪:委员会成员人数为奇数将防止在分裂决定的情况下票数相等。 然而，由于决策方法的性质，没有什么是“因为我认为应该这样”，一切都是一种权衡的评估，决策是通过协商一致而不是投票做出的。 这个四人小组运转良好。

# 例外

是的，我们的规则是法律，但是是的，有些规则允许例外。 我们的规则通常是为更大的一般情况而设计的。 有时，特定情况会受益于对特定规则的豁免。 当出现这种情况时，会咨询样式仲裁器，以确定是否存在授予特定规则的豁免的有效案例。

弃权不是轻易批准的。 在C++代码中，如果引入了宏API，样式指南要求使用特定于项目的前缀来命名它。 由于C++处理宏的方式，将它们视为全局命名空间的成员，从头文件导出的所有宏必须具有全局唯一的名称，以防止冲突。 关于宏命名的样式指南规则允许仲裁器对一些真正全局的实用宏进行豁免。 但是，当豁免请求背后要求排除特定项目前缀的原因归结为由于宏名称长度或项目一致性的偏好时，豁免被拒绝。 这里，代码库的完整性超过了项目的一致性。

在允许违规比避免违规更有利的情况下，允许有例外。 《C++风格指南》不允许隐式类型转换，包括单参数构造函数。 然而，对于被设计为透明包装其他类型的类型，其中底层数据仍然被精确地表示，允许隐式转换是完全合理的。 在这种情况下，可以放弃非隐含转换规则。 拥有如此明确的有效豁免案例可能表明，有关规则需要澄清或修正。 但是，对于此特定规则，收到了足够多的豁免请求，这些请求看似符合有效的豁免情形，但实际上并不符合——要么是因为所讨论的特定类型实际上不是透明的包装类型，要么是因为该类型是包装类型，但实际上并不需要——因此保持规则不变仍然是值得的。
