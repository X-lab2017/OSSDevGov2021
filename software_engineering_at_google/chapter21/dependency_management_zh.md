# 从理论上讲，依赖管理

在了解了依赖管理的困难之处以及它会如何出错之后，让我们更具体地讨论一下我们正在试图解决的问题以及我们可能如何着手解决它们。在这一章中，我们回顾了“我们如何管理来自我们组织外部的代码 或者我们不能完全控制的代码):我们如何更新它，我们如何管理它所依赖的东西?”我们需要清楚的是，任何好的解决方案都要避免任何形式的需求冲突，包括菱角依赖版本冲突，即使是在一个动态的生态系统中，其中可能会添加新的依赖或其他需求(在网络中的任何位置)。我们还需要意识到时间的影响:所有软件都有错误，其中一些是安全关键，因此我们的部分依赖关系在足够长的一段时间内更新是至关重要的。

因此，一个稳定的依赖管理方案必须在时间和规模上灵活:我们不能假定依赖图中的任何特定节点具有无限的稳定性，也不能假定没有添加新的依赖(无论是在我们控制的代码中还是在我们依赖的代码中)。如果依赖项管理的解决方案可以防止依赖项之间的需求冲突问题，那么这就是一个好的解决方案。如果这样做时没有假定依赖项版本的稳定性或依赖项的扇形输出、组织之间的协调或可见性，或重要的计算资源，那么这是一个很好的解决方案。

当提出依赖管理的解决方案时，我们知道有四个常见的选择，它们至少显示了一些适当的属性:永远不改变，语义版本控制，捆绑你需要的所有东西(不是协调每个项目，而是每个发行版)，或者Live at Head。

# 没有任何改变(也就是静态依赖模型)

确保稳定依赖关系的最简单方法是永远不要改变它们:不要改变API，不要改变行为，什么都不要。只有在不破坏用户代码的情况下，才允许进行错误修复。这将兼容性和稳定性置于其他一切之上。显然，由于存在不定稳定性的假设，这种方案并不理想。如果，以某种方式，我们进入了一个安全问题和bug修复不再是问题，依赖关系不变的世界，那么Nothing Changes模型将非常吸引人:如果我们从可满足的约束开始，我们将能够无限期地维护该属性。

虽然这在长期内是不可持续的，但实际上，这是每个组织开始的地方:直到您证明了项目的预期寿命足够长，以至于有必要进行更改，我们很容易生活在一个假设没有任何更改的世界中。同样需要注意的是:对于大多数新组织来说，这可能是正确的模型。相对来说，很少有人知道您正在启动一个将存在几十年的项目，并且需要能够平稳地更新依赖项。更合理的做法是，希望稳定性是一个真正的选择，并假装依赖关系在项目的前几年是完全稳定的。

这种模式的缺点是，在足够长的一段时间内，它是错误的，而且没有明确的迹象表明你可以在多长时间内假装它是合法的。我们没有针对安全漏洞或其他可能迫使你升级依赖关系的关键问题的长期早期预警系统——而且由于依赖关系链，从理论上讲，一次升级可能会成为对整个依赖关系网络的强制升级。

在这个模型中，版本选择很简单:不需要做任何决定，因为没有版本。

# 语义版本控制

“今天我们如何管理依赖网络?”是语义版本控制(SemVer)SemVer是使用三个十进制分隔的整数(如2.4.72或1.1.4)表示某些依赖项(特别是库)的版本号的普遍做法。在最常见的惯例中，三个组件号代表主要版本、次要版本和补丁版本，这意味着改变的主版本号表示对现有API的改变，可能会破坏现有的使用，改变的次要版本号表示纯添加的功能，不应该破坏现有的使用，更改后的补丁版本保留给非影响api的实现细节和bug修复，这些被认为风险特别低。

通过SemVer对主要/次要/补丁版本的分离，假设版本需求通常可以表示为“任何更新的”，除非api不兼容的更改(主要版本更改)。通常，我们会看到“要求libbase≥1.5”，这个要求将兼容1.5的任何libbase，包括1.5.1，以及1.6以后的任何libbase，但不兼容libbase 1.4.9(缺少1.5中引入的API)或2。x (libbase中的一些api发生了不兼容的更改)。主要版本的变化是一个重大的不兼容性:因为现有的功能块已经改变(或被删除)，所有依赖项都存在潜在的不兼容性。每当一个依赖项使用另一个依赖项时，版本需求就会存在(显式或隐式):我们可能会看到“liba要求libbase≥1.5”和“libb要求libbase≥1.4.7”。

如果我们形式化这些需求，我们可以将依赖网络概念化为软件组件(节点)和它们之间的需求(边)的集合。这个网络中的边缘标签随着源节点版本的变化而变化，或者随着依赖项的添加(或删除)，或者由于源节点的变化而更新了SemVer需求(例如，需要在依赖项中添加新特性)。因为整个网络是随着时间的推移而异步变化的，因此找到一组相互兼容的依赖项来满足应用程序的所有传递性需求的过程是很有挑战性的SemVer的版本可满足性求解器在逻辑和算法研究中非常类似于sat求解器:给定一组约束(依赖边的版本要求)，我们能找到一组满足所有约束的节点版本吗?大多数包管理生态系统都构建在这些类型的图之上，由它们的SemVer sat解决方案管理。

SemVer及其sat解决程序并没有以任何方式保证存在一组给定依赖约束的解决方案。依赖约束不能被满足的情况会不断出现，正如我们已经看到的:如果一个低级组件(libbase)产生了主要数量的变化，并且依赖于它的一些库(libb而不是liba)升级了，我们就会遇到钻石依赖问题。

依赖管理的SemVer解决方案通常基于sat解决方案。版本选择就是运行一些算法来为网络中满足所有版本需求约束的依赖项找到一个版本分配。当不存在这样令人满意的版本分配时，我们通俗地称之为“依赖地狱”。

我们将在本章后面更详细地研究SemVer的一些限制。

# 捆绑分布模型

作为一个行业，几十年来我们已经看到了管理依赖项的强大模型的应用:一个组织收集一组依赖项，找到一组相互兼容的依赖项，并将该集合作为单个单元发布。这就是发生的情况，例如，在Linux发行版中——不能保证发行版中包含的各个部分在同一时间点被删除。事实上，更有可能的是，较低级别的依赖关系比较高级别的依赖关系更早一些，这只是为了考虑到集成它们所需要的时间。

这种“画一个更大的盒子，然后发布集合”的模式引入了全新的参与者:发行商。尽管所有独立依赖项的维护者可能对其他依赖项了解很少或根本不了解，但这些高级分发者参与了查找、修补和测试要包含的相互兼容版本集的过程。分销商是负责提出一组捆绑在一起的版本，测试这些版本以找到依赖树中的bug，并解决任何问题的工程师。

对于外部用户来说，只要您能够正确地依赖于这些捆绑发行版中的一个，这就可以很好地工作。这实际上与将依赖网络更改为单个聚合依赖并给出版本号是相同的。不是说，“我依赖于这些版本的这72个库”，而是“我依赖于RedHat版本N”，或者“我依赖于时间t的NPM图中的部分”。

在捆绑发行方式中，版本选择由专用发行方处理。

# Live at Head

我们Google中的一些人一直在推动的模式在理论上是合理的，但却给依赖网络的参与者带来了新的、昂贵的负担。它完全不像今天存在于OSS生态系统中的模型，而且作为一个产业，它不清楚如何从这里到那里。在像谷歌这样的组织范围内，这是昂贵但有效的，我们觉得它把大部分的成本和激励放到了正确的地方。我们称这种模式为“Live at Head”。它可以看作是基于干线开发的依赖管理扩展:在基于干线开发讨论源代码控制策略的地方，我们也在扩展该模型以应用于上游依赖关系。

Live at Head假定我们可以解除依赖关系，删除SemVer，并在提交之前依赖依赖提供商对整个生态系统进行测试。Live at Head是一个明确的尝试，试图从依赖管理的问题中拿出时间和选择:总是依赖于所有东西的当前版本，并且永远不要以一种让依赖者难以适应的方式改变任何东西。(无意中)改变API或行为的更改通常会被下游依赖项上的CI捕获，因此不应该提交。对于必须发生这种更改的情况(即出于安全原因)，只有在更新了下游依赖项或提供了自动工具来执行适当的更新之后，才应该进行这种中断。(此工具对于闭源下游消费者至关重要:其目标是允许任何用户在不了解使用或API的专业知识的情况下更新API的使用。这一特性显著减轻了破坏更改的“多数旁观者”成本。)在开源生态系统中，这种责任哲学上的转变一开始很难激发:让API提供者承担对其所有下游客户进行测试和更改的负担，是对API责任的重大修订提供者。

“我认为这是安全的或不安全。”相反，测试和CI系统被用来测试可见的依赖项，以从实验上确定一个更改有多安全。因此，对于只改变效率或实现细节的更改，所有可见的受影响的测试都可能通过，这表明没有明显的方法使该更改影响用户—提交是安全的。修改API中更明显的可观察部分(语法上或语义上)的更改通常会导致数百甚至数千个测试失败。然后，由提议变更的作者来决定解决这些失败所涉及的工作是否值得提交变更的结果价值。如果做得好，作者将与他们所有的依赖者一起提前解决测试失败(例如，解开测试中脆弱的假设)，并可能创建一个工具来尽可能多地执行必要的重构。

这里的激励结构和技术假设与其他情况有本质上的不同:我们假设存在单元测试和CI，我们假设API提供者将受到下游依赖是否会被打破的约束，我们假设API使用者将保持他们的测试通过，并以支持的方式依赖于他们的依赖。这在开源生态系统中(可以提前发布修复程序)比在隐藏/封闭源代码依赖项中工作得更好。API提供者在进行更改时受到激励，以便以一种可以顺利迁移到的方式进行更改。API消费者被鼓励保持他们的测试工作，以避免被标记为低信号测试和可能被跳过，减少该测试提供的保护。

在Live at Head方法中，版本选择是通过询问“所有内容的最新稳定版本是什么?”如果供应商负责任地做出改变，一切都会顺利进行。

# SemVer的局限性

Live at Head方法可能建立在公认的版本控制实践(基于主干的开发)上，但在很大程度上还没有得到规模化的验证。SemVer是目前依赖项管理的事实上的标准，但正如我们所建议的，它并非没有局限性。因为这是一种非常流行的方法，所以值得对其进行更详细的研究，并强调我们认为它可能存在的缺陷。

在SemVer的定义中，有很多东西需要解包，来解释点三层版本号的真正含义。这是承诺吗?或者为一个发布选择的版本号是一个估计?也就是说，当libbase的维护者剪掉一个新版本并选择是主要版本、次要版本还是补丁版本时，他们会说什么?是否可以证明从1.1.4升级到1.2.0是安全且容易的，因为只增加了API并修复了bug ?当然不是。在面对一个“简单的”API添加时，libbase的不良用户可能会做很多事情，导致构建中断或行为改变从根本上说，如果只考虑源API，就无法证明兼容性;你必须知道你问的是哪些东西的兼容性。

然而，当我们谈到依赖网络和应用于这些网络的sat解决程序时，这种“估计”兼容性的想法开始减弱。这个公式的基本问题是传统SAT中的节点值和SemVer依赖图中的版本值之间的差异。三sat图中的节点要么为True，要么为False。依赖关系图中的版本值(1.1.14)由维护者提供，作为对使用前一个版本的代码的新版本兼容性的估计。我们把所有版本满意的逻辑建立在一个不稳固的基础之上，把估计和自我认证当作绝对的。正如我们将看到的，即使这在有限的情况下行得通，总的来说，它不一定有足够的精确度来支撑一个健康的生态系统。

如果我们承认SemVer是一个有损耗的估计，并且只代表可能变化范围的一个子集，我们就可以开始把它看作是一个生硬的工具。从理论上讲，它作为一种速记方式工作得很好。在实践中，尤其是当我们在sat解决方案的基础上构建sat解决方案时，SemVer可能(也确实)会因为过度约束和保护不足而让我们失败。

# SemVer可能过度承诺

另一方面，SemVer的应用程序明确地假设API提供者对兼容性的估计是完全可预测的，更改分为三部分:破坏(通过修改或删除)、严格添加或不影响API。如果SemVer通过对语法和语义更改进行分类，完全忠实地表示更改的风险，那么我们如何描述给对时间敏感的API增加了一毫秒延迟的更改?或者，更有可能的是:我们如何描述改变日志输出格式的更改?或者改变我们导入外部依赖的顺序?或者改变结果在“无序”流中返回的顺序?仅仅因为这些更改不是相关API的语法或契约的一部分，就认为这些更改是“安全的”，这是否合理?如果文档上写着“这在将来可能会改变”怎么办?或者这个API被命名为“forinternalusebylibbaseonlydonottouchthisisireallymeanit ?”

从理论上讲，SemVer补丁版本只是改变实现细节，是“安全的”改变，这与谷歌的Hyrum定律相冲突——“当用户数量足够多时，你系统的每一个可观察的行为都会被某些人所依赖。”改变依赖项的导入顺序，或者改变“无序”生产者的输出顺序，就一定程度而言，会打破某些消费者(可能是错误地)所依赖的假设。“中断更改”这个术语本身是误导性的:有些更改在理论上是中断的，但在实践中是安全的(删除未使用的API)。还有一些修改在理论上是安全的，但在实践中会破坏客户端代码(任何我们早期Hyrum’s Law的例子)。我们可以看到这在任何SemVer /依赖关系管理系统的版本号要求系统允许补丁数量限制:如果你可以说仙女镇李坝社区需要libbase > 1.1.14而不是仙女镇李坝社区需要libbase 1.1,这显然是一个补丁版本中承认存在显著的差异。

隔离中的更改不具有破坏性或非破坏性——该语句只能在使用它的上下文中进行评估。“这是一个突破性的改变”的概念没有绝对的真理;可以看到，更改只会破坏(已知或未知)一组现有用户和用例。我们如何评估一个变更的现实本质上依赖于依赖项管理的SemVer公式中不存在的信息:下游用户如何使用这个依赖项?

正因为如此，SemVer约束求解器可能会报告你的依赖项在它们没有协同工作的时候协同工作，要么是因为bump被错误地应用了，要么是因为依赖项网络中的某些东西具有Hyrum’s Law依赖性，而这些依赖项并不被认为是可观察API表面的一部分。在这些情况下，您可能会有构建错误或运行时错误，它们的严重性没有理论上的上限。

# 动机

还有一个进一步的争论是SemVer并不总是激励稳定代码的创建。对于任意依赖项的维护者来说，不进行破坏性更改和破坏主要版本的系统激励是可变的。有些项目非常注重兼容性，会尽量避免主要版本的冲突。其他人则更激进，甚至有意在固定的时间表上修改主要版本。问题是，任何给定依赖项的大多数用户都是间接用户——他们没有任何重要的理由来意识到即将到来的变化。甚至大多数直接用户也不订阅邮件列表或其他发布通知。

所有这一切都表明，无论有多少用户会因为对一个流行的API进行不兼容的更改而感到不便，维护者要承担版本碰撞的一小部分成本。对于同样是用户的维护者来说，也可能存在破坏的动机:在没有遗留约束的情况下，总是更容易设计出更好的界面。这就是为什么我们认为项目应该发布关于兼容性、使用和破坏更改的明确的意图声明的部分原因。即使这些是最努力的，非绑定的，或被许多用户忽略的，它仍然为我们提供了一个出发点，在不引入这些冲突的激励结构的情况下，来判断一个破坏性的变更/主要版本碰撞是否“值得”。

Go和Clojure都很好地处理了这一点:在它们的标准包管理生态系统中，一个相当于主要版本碰撞的版本有望是一个全新的包。这有一种公正的感觉:如果您愿意打破您的包的向后兼容性，为什么我们要假装这是同一组api ?对提供商进行重新打包和重命名似乎是一项合理的工作，以换取他们接受核选项并抛弃向后兼容性。

最后，在这个过程中，人难免会犯错。一般来说，SemVer版本颠簸应该应用于语义变化，就像应用于语法变化一样;改变API的行为和改变它的结构一样重要。虽然可以开发工具来评估任何特定版本是否涉及到对一组公共api的语法更改，但识别是否存在有意义和有意的语义更改在计算上是不可实现的实际上，即使是识别语法变化的潜在工具也是有限的。在几乎所有情况下，对于任何给定的更改，都取决于API提供者的判断，是使用主要版本、次要版本还是补丁版本。如果您只依赖少数专业维护的依赖项，那么您对这种SemVer文书错误的预期暴露可能很低如果你的产品下面有一个由数千个依赖项组成的网络，你应该为人为错误造成的一些混乱做好准备。

# 最低版本选择

2018年，作为为Go编程语言构建包管理系统的系列文章的一部分，谷歌自己的Russ Cox描述了SemVer依赖管理的一个有趣的变体:最小版本选择(MVS)。当更新依赖网络中某些节点的版本时，可能需要将其依赖项更新为更新版本，以满足更新后的SemVer需求——这可能会触发进一步的更改。在大多数约束满足/版本选择公式中，会选择那些下游依赖项的最新可能版本:毕竟，您最终需要更新到这些新版本，对吗?

MVS做出了相反的选择:当liba的规范要求libbase≥1.7时，我们将直接尝试libbase 1.7，即使有1.8可用。这“产生高保真的构建，其中用户构建的依赖关系与作者开发的依赖关系尽可能接近。”在这一点上有一个非常重要的事实:当liba说它要求libbase≥1.7时，这几乎肯定意味着liba的开发者安装了libbase 1.7。假设维护者在发布之前执行了基本的测试，15我们至少有关于那个版本liba和版本1.7的互操作性测试的传闻证据。它不是CI或所有东西都经过了单元测试的证明，但它是某种东西。

如果没有来自对未来100%准确预测的准确输入约束，最好是尽可能实现最小的跳跃。就像在你的项目中投入一个小时的工作比一次性投入一年的工作更安全一样，在依赖更新中更小的步骤也更安全。MVS只是在每个受影响的依赖项需要的时候向前走，然后说，“好吧，我已经向前走了足够远，可以得到你想要的东西(而不是更远)。你为什么不做些测试看看情况是否良好?”

MVS思想的固有之处是承认新版本在实践中可能引入不兼容性，即使理论上的版本号不是这样说的。这是认识到SemVer的核心问题，无论是否使用MVS:在将软件更改压缩为版本号的过程中，会有一些保真度的损失。MVS提供了一些额外的实际保真度，试图产生最接近那些可能已经一起测试过的版本。这可能足以推动更大的依赖网络正常运行。不幸的是，我们还没有找到一个很好的方法来验证这个想法。陪审团仍然不确定是否MVS使SemVer“足够好”，没有解决基本的理论和激励问题的方法，但我们仍然相信，它代表了一个明显的改进，在SemVer约束的应用，因为他们今天使用。

# 那么，SemVer有用吗?

SemVer在有限的范围内运行良好。然而，认识到它实际上在说什么，不能说什么是非常重要的。SemVer将工作良好，只要:

•您的依赖提供商是准确和负责任的(以避免在SemVer碰撞中的人为错误)
•您的依赖关系是细粒度的(以避免错误的过度约束，当您的依赖关系中未使用/不相关的api被更新时，以及不满足SemVer需求的相关风险)
•所有api的所有使用都在预期的使用范围内(以避免被一个假设兼容的变化打破，无论是直接的还是在你依赖的代码传递)

如果依赖关系图中只有几个精心选择和维护良好的依赖关系，那么SemVer可能是一个非常合适的解决方案。

然而，我们在谷歌的经验表明，你不太可能拥有这三个属性中的任何一个，并让它们随着时间不断工作。规模往往是显示SemVer弱点的东西。随着依赖网络的扩大，每个依赖的大小和依赖的数量(以及由多个项目依赖于同一外部依赖网络产生的单一效应)，SemVer中复合保真度的损失将开始占主导地位。这些失败既表现为假阳性(理论上应该可以工作的实际上不兼容的版本)，也表现为假阴性(sat解决程序不允许兼容的版本，从而导致依赖地狱)。
