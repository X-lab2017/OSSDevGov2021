[toc]



# 依赖管理

依赖关系管理（我们无法控制的库，程序包和依赖关系网络的管理）是软件工程中最难理解且最具挑战性的问题之一。 依赖关系管理关注以下问题：如何在外部依赖关系的版本之间进行更新？ 为此，我们如何描述版本？ 我们的依存关系中允许或预期进行哪些类型的更改？ 我们如何决定何时明智地依赖于其他组织生成的代码？

为了进行比较，这里最相关的主题是源代码控制。 这两个领域都描述了我们如何使用源代码。 源代码管理涵盖了更简单的部分：我们在哪里检入内容？ 我们如何将事情纳入构建？ 在我们接受基于主干的开发的价值之后，对于组织而言，大多数日常源代码控制问题都相当平凡：“我有新东西，我要将其添加到哪个目录？”

依赖管理在时间和规模增加了额外的复杂性。在基于主干源控制问题，当你做出改变，你需要运行测试，而不是打破现有的代码是相当清楚的。这是预测对你在一个共享代码库的工作思路，具有可见性是如何被使用的东西，并且可以触发构建和运行测试。依赖管理的重点出现的变化时，正在使你的组织之外，没有完全访问或可见性的问题。因为你的上游依赖性不能与专用代码协调，他们更有可能打破你的构建，使你的测试失败。我们如何管理的？难道我们不应该采取外部依赖性？我们是否应该要求外部依赖版本之间的更大一致性？我们什么时候更新到新版本？

Scale意识到我们并不是真正在谈论单个依赖项的导入，而通常情况下，我们依赖于整个外部依赖项网络，这使所有这些问题变得更加复杂。当我们开始处理网络，很容易在你的组织使用两个附属在某个时间点变得不可满足的结构方案。通常，发生这种情况是因为一个依赖项在没有某些要求的情况下会停止工作，1而另一个依赖项则与该要求不兼容。有关如何管理一个单一的外部依赖简单的解决方案通常没有考虑到管理一个大型网络的现实。我们会花很多本章讨论各种形式的这些相互矛盾的要求的问题。

源代码控制和依赖项管理是由以下问题分隔开的相关问题：“我们的组织是否控制此子项目的开发/更新/管理？”例如，如果公司中的每个团队都有各自的存储库，目标和开发实践，则这些团队生成的代码的交互和管理将与依赖管理更多地关系，而不是源代码控制。另一方面，具有（虚拟？）单个存储库（monorepo）的大型组织可以通过源代码控制策略进一步扩大规模，这是Google的方法。单独的开源项目当然可以视为单独的组织：未知项目与不必要协作项目之间的相互依赖关系是一个依赖关系管理问题。也许我们在此主题上最有力的建议是：在其他条件相同的情况下，与依赖关系管理问题相比，更喜欢源代码控制问题。如果您可以选择更广泛地重新定义“组织”（整个公司而不是一个团队），那通常是一个很好的权衡。与依赖关系管理相比，源代码控制问题更容易考虑，并且处理起来也便宜得多。

随着开放源代码软件（OSS）模型的不断发展和扩展到新的领域，以及许多流行项目的依赖关系图随着时间的推移不断扩展，依赖关系管理可能已成为软件工程策略中最重要的问题。我们不再是在API之外的一层或两层上建立的不连接孤岛。现代软件是建立在高耸的依赖支柱上的。但是，仅仅因为我们可以建立这些支柱，并不意味着我们已经弄清楚了如何使它们随着时间的推移保持稳定。

在本章中，我们将研究依赖管理的特殊挑战，探索解决方案（常见和新颖）及其局限性，并研究使用依赖的现实情况，包括我们在Google中的处理方式。首先要承认所有这些，这一点很重要：我们已经为这个问题投入了大量的思想，并且在重构和维护问题方面拥有丰富的经验，这些问题表明了现有方法的实际缺陷。我们没有第一手证据表明解决方案在整个组织中都能很好地发挥作用。在某种程度上，本章总结了我们所知道的行不通（或者至少在更大范围内行不通）以及我们认为有可能取得更好成绩的摘要。我们绝对不能声称这里有所有答案；如果可以的话，我们不会将其称为软件工程中最重要的问题之一。

## 为什么依赖管理这么困难？

甚至定义依赖性管理问题也提出了一些不同寻常的挑战。在这个领域中，许多半熟的解决方案都集中在一个过于狭窄的问题表述上：“我们如何导入本地开发的代码可以依赖的程序包？”这是必要但不充分的表述。诀窍不只是找到一种管理依赖关系的方法，还在于如何管理依赖关系及其随时间变化的网络。第一方代码直接需要该网络的某些子集，其中某些仅由传递性依赖项引入。在足够长的时间内，该依赖项网络中的所有节点都将具有新版本，并且其中一些更新将很重要。2我们如何管理其余依赖项网络的升级结果级联？或者，特别是，如果我们不控制那些依赖关系，那么我们如何使找到所有依赖关系的相互兼容版本变得容易呢？我们如何分析依赖网络？我们如何管理该网络，尤其是面对不断增长的依赖关系图时？

### 需求的冲突和diamond dependencies

依赖管理中的中心问题突出了从依赖网络而不是单个依赖进行思考的重要性。许多困难源于一个问题：当依赖关系网络中的两个节点有冲突的需求，而您的组织同时依赖于这两个节点时，会发生什么？出现这种情况的原因有很多，从平台考虑因素（操作系统[OS]，语言版本，编译器版本等）到版本不兼容的更为平凡的问题。版本不兼容作为无法满足的版本要求的典型示例是菱形依赖问题。尽管我们通常不会在依赖关系图中包括“正在使用哪个版本的编译器”之类的东西，但是这些冲突的需求问题中的大多数都是同构的，就是要向代表此需求的依赖关系图中“添加（隐藏）节点”。 ”因此，我们将主要就菱形依赖项讨论冲突的需求，但请记住，libbase实际上绝对是与依赖关系网络中的两个或多个节点的构建有关的任何软件。钻石依赖关系问题以及其他形式的冲突需求，至少需要三层依赖关系，如图21-1所示。

在此简化模型中，liba和libb都使用libbase，更高级别的组件libuser都使用liba和libb。 如果libbase曾经进行过不兼容的更改，则liba和libb作为独立组织的产品，有可能不会同时更新。 如果liba依赖于新的libbase版本，而libb依赖于旧版本，则libuser（也就是您的代码）没有通用的方式将所有内容组合在一起。 这种菱形可以任意规模形成：在依赖关系的整个网络中，如果有一个低层节点需要同时处于两个不兼容的版本中（由于存在来自较高层的两条路径） 这两个版本的节点），就会出现问题。

不同的编程语言在不同程度上容忍了钻石依赖问题。对于某些语言，可以在一个版本中嵌入依赖关系的多个（隔离的）版本：从liba调用libbase可能会调用与从libb调用libbase相同的API的不同版本。例如，Java提供了相当完善的机制来重命名此类依赖关系提供的符号。3同时，C ++在正常构建中对菱形依赖关系的容忍度几乎为零，并且它们很可能触发任意错误和未定义的行为（UB ），因为它明显违反了C ++的“一个定义规则”。您最多可以使用与Java底纹类似的方法，将某些符号隐藏在动态链接库（DLL）中，或者在您分别构建和链接的情况下使用。但是，在我们所知道的所有编程语言中，这些解决方案充其量只是部分解决方案：可以通过调整函数名称来嵌入多个版本，但如果在依赖关系之间传递了类型，所有赌注都没有了。例如，根本没有办法将libbase v1中定义的映射以语义一致的方式通过某些库传递给libbase v2提供的API。在单独编译的库中隐藏或重命名实体的特定于语言的黑客可以为菱形依赖问题提供一定的缓冲，但在一般情况下不是解决方案。

如果遇到冲突的需求问题，唯一简单的答案是在这些依赖项的版本中向前或向后跳过，以查找兼容的东西。 如果不可能，我们必须求助于本地修补有问题的依赖关系，这特别具有挑战性，因为首先发现不兼容的工程师可能不知道提供商和使用者之间不兼容的原因。 这是固有的：liba开发人员仍在与libbase v1兼容，并且libb开发人员已升级到v2。 只有同时参与这两个项目的开发人员才有机会发现问题，并且当然不能保证他们对libbase和liba足够熟悉，可以完成升级。 较简单的答案是降级libbase和libb，但是如果最初由于安全性问题而强制升级，则不可以这样做。

用于依赖性管理的策略和技术系统主要归结为以下问题：“我们如何在避免冲突需求的同时仍允许非协调组之间进行更改？” 如果您有解决钻石依赖问题的一般形式的解决方案，并且可以在网络的各个级别上不断更改需求（依赖关系和平台需求），那么您已经描述了依赖关系的有趣部分- 管理解决方案。

## 引入依赖

用编程的术语来说，重用一些现有的基础结构显然比自己构建它更好。 这是显而易见的，并且是技术基础前进的一部分：如果每个新手都必须重新实现自己的JSON解析器和正则表达式引擎，我们将一事无成。 重用是健康的，特别是与从头开始开发高质量软件的成本相比。 只要您不下载木马软件，如果您的外部依赖关系满足编程任务的要求，则应使用它。

### 兼容性承诺

当我们开始考虑时间时，情况会出现一些复杂的取舍。 仅仅因为您避免了开发成本，并不意味着导入依赖项是正确的选择。 在意识到时间和变化的软件工程组织中，我们还需要注意其持续的维护成本。 即使我们导入了无意升级的依赖关系，无论我们的意图如何，发现的安全漏洞，不断变化的平台以及不断发展的依赖关系网络都可以合谋强迫升级。 那天到来的时候，价格会是多少？ 对于仅使用该依赖项的预期维护成本，某些依赖项比其他依赖项更明确：假定了多少兼容性？ 假设进化了多少？ 如何处理变更？ 支持发行多长时间？

我们建议依赖提供者应更清楚地了解这些问题的答案。 考虑由拥有数百万用户的大型基础架构项目设置的示例及其兼容性承诺。

#### C++

对于C ++标准库，该模型是几乎不确定的向后兼容性之一。针对较早版本的标准库构建的二进制文件有望与较新的标准建立并链接：该标准不仅提供API兼容性，而且还为二进制工件提供持续的向后兼容性，即ABI兼容性。各个平台对这种支持的重视程度各不相同。对于Linux上的gcc用户而言，大多数代码在大约十年的时间内都可以正常工作。该标准并未明确表示其对ABI兼容性的承诺-那时还没有面向公众的政策文件。但是，该标准确实发布了标准文档8（SD-8），该标准召集了标准库可以在版本之间进行的一小组更改类型，隐式定义了要准备的更改类型。 Java是类似的：源在语言版本之间是兼容的，并且旧版本中的JAR文件将可以与新版本一起使用。

#### Go

并非所有语言都优先考虑相同程度的兼容性。 Go编程语言明确承诺大多数版本之间的源兼容性，但没有二进制兼容性。 您不能使用一种语言版本在Go中构建库，也不能将该库链接到使用另一种语言版本构建的Go程序中。

#### Abseil

Google的Abseil项目与Go十分相似，但需要注意一些重要的时间。我们不愿无限期地致力于兼容性：Abseil是我们内部大多数计算最繁重的服务的基础，我们认为这些服务可能会在未来许多年内使用。这意味着我们会谨慎保留更改的权利，尤其是在实施细节和ABI中进行更改，以便获得更好的性能。我们已经经历了太多的API实例，事实证明它们令人困惑并且容易出错。在无限的将来将这种已知的错误发布给成千上万的开发人员感到不对。在内部，我们已经有大约2.5亿行C ++代码依赖此库，我们不会轻易对API进行更改，但必须做到这一点。为此，Abseil明确不承诺与ABI兼容，但承诺与API兼容的形式略有限制：我们不会在不提供重大破坏的情况下更改API，除非还提供了将代码从旧API转换为新API的自动重构工具。透明地。我们认为，这极大地改变了意外成本的风险，使用户受益：无论依赖项针对哪个版本编写，该依赖项的用户和Abseil都应该能够使用最新版本。成本最高的应该是“运行此工具”，并且大概将生成的补丁发送给中级依赖项（liba或libb，继续前面的示例）。实际上，该项目足够新，因此我们无需进行任何重大的API重大更改。我们无法说这对整个生态系统的效果如何，但从理论上讲，这似乎在稳定性和易于升级之间取得了很好的平衡。

#### Boost

相比之下，Boost C ++库不保证版本之间的兼容性。当然，大多数代码都不会改变，但是“许多Boost库都得到了积极的维护和改进，因此并不总是能够与以前的版本向后兼容。”建议用户仅在项目生命周期中的某个阶段进行升级，在此期间某些更改不会引起问题。 Boost的目标与标准库或Abseil根本不同：Boost是实验性的试验场。 Boost流中的特定发行版可能非常稳定，适合在许多项目中使用，但是Boost的项目目标并未优先考虑版本之间的兼容性-其他长期存在的项目可能会遇到一些摩擦。 Boost开发人员与标准库的开发人员一样都是专家4-这都不关乎技术专长：这完全取决于项目是否承诺或确定优先级。

查看讨论中的库，很重要的一点是要认识到这些兼容性问题是软件工程问题，而不是编程问题。您可以下载不带兼容性保证的Boost等内容，并将其深深地嵌入到组织中最关键，使用寿命长的系统中；它会很好地工作。这里所有的关注点都是这些依赖关系将如何随着时间变化，跟上更新的步伐，以及使开发人员担心维护而不只是使功能正常运行的困难。在Google内部，源源不断地向我们的工程师提供指导，以帮助他们考虑“我让它开始工作”与“正在以一种受支持的方式工作”之间的区别。这不足为奇：毕竟，它是Hyrum定律的基本应用。

概括地说：重要的是要认识到，依赖管理在编程任务和软件工程任务中具有完全不同的性质。如果您处于一个需要长期维护的问题空间中，则依赖管理很困难。如果您纯粹是为当今的解决方案而开发，而无需进行任何更新，那么完全可以合理地获取任意数量的随时可用的依赖项，而无需考虑如何负责任地使用它们或计划升级。通过违反SD-8中的所有内容并依赖Boost和Abseil的二进制兼容性来使您的程序今天可以正常工作……只要您不升级标准库，Boost或Abseil，并且不依赖您的任何内容。

### 导入依赖时考虑的问题

导入要在编程项目中使用的依赖项几乎是免费的：假设您已花时间确保它能够满足您的需要，并且不是秘密的安全漏洞，那么与重新实现功能相比，重用通常总是便宜的。即使该依赖项已采取步骤澄清其所承诺的兼容性，只要我们从未进行过升级，无论您在使用过程中违反了多少规则，只要在依赖项快照之上构建的任何内容都是可以的该API。但是，当我们从编程转向软件工程时，这些依赖性变得更加昂贵，并且存在许多隐藏的成本和需要解决的问题。希望您在导入之前考虑了这些成本，并且希望知道您是在进行编程项目时还是在进行软件工程项目时。

当Google的工程师尝试导入依赖项时，我们鼓励他们首先提出以下（不完整的）问题列表：

- 项目是否有可以运行的测试？
- 这些测试通过了吗？

- 谁在提供这种依赖性？ 即使在“无担保暗示”的OSS项目中，也有大量的经验和技能集—依赖于C ++标准库或Java的Guava库的兼容性与从GitHub中选择一个随机项目或与之随机选择是非常不同的事情。 npm。 声誉不是一切，但值得研究。
- 该项目希望实现什么样的兼容性？
- 项目是否详细说明了预期将支持哪种使用方式？
- 这个项目有多受欢迎？
- 我们将依赖这个项目多长时间？
- 项目多久进行一次重大更改？

此外，还选择了一些内部关注的问题：

- 在Google中实施该功能有多复杂？
- 我们必须采取什么激励措施来保持这种依赖关系的最新状态？
- 谁来执行升级？
- 我们期望执行升级有多困难？

我们自己的拉斯考克斯已经更广泛地写了这一点。我们不能给决定何时它在长期内对进口便宜重新实现一个完美的公式;我们不能在这个自己，往往不是。

### Google是如何导入依赖的

简而言之：我们可以做得更好。

任何给定的Google项目中绝大多数依赖都是内部开发的。这意味着我们内部依赖管理的绝大部分故事并不是真正的依赖管理，而是源代码控制（通过设计）。正如我们已经提到的，当提供者和使用者是同一组织的一部分并且具有适当的可见性和持续集成（CI；请参阅第23章）时，管理和控制添加依赖项所涉及的复杂性和风险要容易得多。当您可以准确了解代码的使用方式并确切了解任何给定更改的影响时，依赖性管理中的大多数问题就不再是问题了。源代码控制（当您控制有问题的项目时）比依赖项管理（当您不这样做时）要容易得多。

在处理外部项目时，这种易用性开始失败。对于我们从OSS生态系统或商业合作伙伴导入的项目，这些依赖项被添加到我们的monorepo的单独目录中，该目录标记为third_party。让我们研究一下如何将新的OSS项目添加到third_party。

Google的软件工程师Alice正在从事一个项目，并意识到有可用的开源解决方案。她真的很想尽快完成这个项目并进行演示，以便在度假前摆脱它。然后选择是从头开始重新实现该功能，还是下载OSS程序包并将其添加到third_party。爱丽丝很可能认为更快的开发解决方案有意义：她下载了程序包，并遵循了我们的第三方政策中的一些步骤。这是一个非常简单的清单：确保使用我们的构建系统进行构建，确保该软件包没有现有版本，并确保至少有两名工程师以所有者的身份注册，以在任何情况下维护该软件包维护是必要的。爱丽丝让她的队友鲍勃说：“是的，我会帮忙。”他们俩都不需要具有任何维护第三方软件包的经验，并且他们方便地避免了需要了解有关此软件包的实现的任何知识。作为使用它来解决预备演示问题的一部分，他们最多在其界面上获得了一点经验。

从那时起，该软件包通常可供其他Google团队在其自己的项目中使用。添加其他依赖项的行为对Alice和Bob完全透明：他们可能完全不知道他们下载并承诺维护的软件包已经流行。巧妙地，即使他们正在监视其包的新直接使用，他们也不一定会注意到其包的可传递使用量的增长。如果他们将其用于演示，而Charlie则从我们的Search基础架构内添加了依赖性，则该软件包将突然从相当无害的状态转变为重要Google系统的关键基础结构。但是，当查理（Charlie）考虑是否要添加此依赖项时，我们没有发现任何特别的信号。

现在，这种情况很可能很好。也许这种依赖关系写得很好，没有安全漏洞，也不受其他OSS项目的依赖。它可能会运行很多年而不进行更新。这样做不一定是明智的选择：外部更改可能对其进行了优化或添加了重要的新功能，或者在发现CVEs5之前清除了安全漏洞。程序包存在的时间越长，就可能产生更多的依赖关系（直接和间接）。该软件包保持的稳定性越强，我们越有可能使Hyrum Law更加依赖于检入third_party的版本的细节。

有一天，爱丽丝和鲍勃被告知升级至关重要。可能是软件包本身或依赖于它的OSS项目中的一个安全漏洞被迫升级。鲍勃（Bob）已过渡到管理人员，并且有一段时间没有接触过代码库了。自演示以来，爱丽丝已移至另一个团队，并且不再使用此软件包。没有人更改OWNERS文件。成千上万的项目间接依赖于此-我们不能在不破坏Search和其他十二个大团队的构建的情况下删除它。没有人对该程序包的实现细节有任何经验。爱丽丝不一定是一支拥有丰富经验的团队，可以克服随着时间的推移而累积的希鲁姆法则的微妙之处。

所有这些都是要说的：Alice和此软件包的其他用户都在进行昂贵且困难的升级，而安全团队则施加压力以立即解决此问题。在这种情况下，没有人会执行升级的实践，并且升级特别困难，因为它涵盖了许多较小的发行版，涵盖了从最初将软件包引入第三方到安全披露之间的整个时期。

我们的第三方政策不适用于这些不幸的常见情况。 我们大致理解，我们需要更高的所有权限制，我们需要使定期更新变得更容易（并且更有意义），并且更难以同时孤立第三方包装并使其变得重要。 困难之处在于，代码库维护人员和第三方专家很难说：“不，您不能使用可以完美解决您的开发问题的东西，因为我们没有资源来不断地更新每个人的新版本。” 受欢迎且没有兼容性承诺（例如Boost）的项目尤其危险：我们的开发人员可能非常熟悉使用该依赖关系来解决Google外部的编程问题，但是让它根深蒂固地融入我们的代码库结构是一个很大的挑战 风险。 目前，我们的代码库的预期寿命为数十年：未明确优先考虑稳定性的上游项目存在风险。