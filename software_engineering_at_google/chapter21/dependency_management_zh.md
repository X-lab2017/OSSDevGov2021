## 无限资源的依赖性管理

在考虑依赖性管理解决方案时，有一个有用的思想实验：如果我们都能获得无限的计算资源，依赖性管理会是什么样子？也就是说，如果我们不受资源限制，而只受限于组织间的可见性和薄弱的协调，我们能期望的最好结果是什么？正如我们目前所看到的，该行业依赖SemVer的原因有三个。

- 它只需要本地信息（API供应商不需要知道下游用户的具体信息）

- 它不需要假设测试的可用性（在行业中还没有普及，但在未来十年肯定会向这个方向发展）、运行测试的计算资源或监测测试结果的CI系统的可用性。

- 这是现有的做法

对本地信息的 "要求 "并不是真正必要的，特别是因为依赖网络往往只在两种环境下形成。

- 在一个组织内

- 在开放源码软件生态系统内，即使项目不一定合作，源码也是可见的。

在这两种情况下，关于下游使用的重要信息都是可用的，即使它今天没有被轻易暴露或采取行动。也就是说，SemVer的有效主导地位的部分原因是我们选择忽略了理论上我们可以获得的信息。如果我们能够获得更多的计算资源，并且依赖性信息能够很容易地浮出水面，那么社区可能会找到它的用途。

尽管一个开放源码软件包可以有无数的闭源依赖，但常见的情况是，受欢迎的开放源码软件包在公开和私下都很受欢迎。依赖网络不会（不能）积极地混合公共和私人依赖关系：一般来说，有一个公共子集和一个单独的私人子图。

接下来，我们必须记住SemVer的意图。"据我估计，这种变化将很容易（或不容易）被采纳"。是否有更好的方式来传达这一信息？是的，以实践经验的形式，证明该变化易于采用。我们如何获得这种经验呢？如果我们大部分（或者至少是有代表性的样本）的依赖关系是公开的，那么我们就在每一个提议的改变中对这些依赖关系进行测试。有了足够多的这样的测试，我们至少有了一个统计学上的论据，即从实际的Hyrum's-Law意义上来说，这个变化是安全的。测试仍然通过，变化是好的--这并不重要，无论这是对API的影响，还是对bug的修复，或者是介于两者之间的东西；没有必要进行分类或估计。

想象一下，如果开放源码软件的生态系统转移到一个变化伴随着它们是否安全的证据的世界里。如果我们把计算成本排除在外，"这有多安全 "的真相来自于在下游依赖中运行受影响的测试。

即使没有正式的CI应用于整个OSS生态系统，我们当然也可以使用这样的依赖关系图和其他次要信号来做一个更有针对性的提交前分析。优先处理大量使用的依赖关系中的测试。优先考虑维护良好的依赖关系中的测试。优先考虑那些有提供良好信号和高质量测试结果历史的依赖关系中的测试。除了根据有可能给我们提供最多实验性变化质量信息的项目来确定测试的优先级外，我们还可以利用变化作者的信息来帮助估计风险和选择适当的测试策略。如果目标是 "任何人依赖的东西都不会以破坏的方式改变"，运行 "所有受影响 "的测试在理论上是必要的。如果我们认为目标更符合 "风险缓解"，那么统计论证就会成为一种更有吸引力（和成本效益）的方法。

在第12章中，我们确定了四种变化，从纯粹的重构到对现有功能的修改。考虑到基于CI的依赖性更新模型，我们可以开始将这些变化种类映射到类似于SemVer的模型上，对于这种模型，变化的作者估计风险并应用适当的测试水平。例如，仅修改内部API的纯重构变化可能被认为是低风险的，并证明仅在我们自己的项目和重要的直接依赖者中运行测试。另一方面，删除一个废弃的接口或改变可观察到的行为的变化可能需要我们进行尽可能多的测试。

为了应用这样的模式，我们需要对开放源码软件的生态系统进行哪些改变？不幸的是，有很多。

- 所有的依赖关系必须提供单元测试。尽管我们正不可阻挡地走向一个单元测试被广泛接受和无处不在的世界，但我们还没有到那一步。

- 大多数开放源码软件生态系统的依赖网络已经被理解。目前还不清楚是否有任何机制可以在该网络上进行图谱算法--信息是公开的，可用的，但实际上并没有被普遍索引或使用。许多软件包管理系统/依赖性管理生态系统允许你看到项目的依赖性，但不能看到反向的边缘，即依赖者。

- 用于执行CI的计算资源的可用性仍然非常有限。大多数开发人员没有机会使用构建和测试的计算集群。

- 依赖关系通常是以钉子的方式来表达的。作为 libbase 的维护者，如果 liba 和 libb 的依赖关系明确地依赖于 libbase 的特定固定版本，那么我们就不能通过测试来实验性地运行一个变化。

- 我们可能希望在 CI 计算中明确地包括历史和声誉。一个提议的修改会破坏一个有长期测试持续通过历史的项目，与一个最近才加入的、有因不相关原因而破坏的项目相比，它给了我们不同形式的证据。

这里面有一个规模问题：你要针对网络中每个依赖的哪些版本来测试预提交的变化？如果我们针对所有历史版本的完整组合进行测试，我们将燃烧一个真正惊人的计算资源，即使以谷歌的标准。这个版本选择策略的最明显的简化似乎是 "测试当前的稳定版本"（毕竟基于主干的开发是目标）。因此，在资源无限的情况下，依赖性管理的模式实际上就是 "活在当下 "的模式。悬而未决的问题是，该模型是否可以有效地适用于更实际的资源可用性，以及API提供者是否愿意承担更大的责任来测试其变化的实际安全性。认识到我们现有的低成本设施是对我们正在寻找的难以计算的真相的过度简化，仍然是一项有益的工作。

## 导出依赖关系

到目前为止，我们只谈到了承担依赖关系；也就是说，依赖于其他人编写的软件。同样值得思考的是，我们如何构建可以作为依赖的软件。这不仅仅是将软件打包并上传到资源库的机械性问题：我们需要考虑提供软件的好处、成本和风险，对我们和我们的潜在依赖者都是如此。

像 "开源库 "这种无害的、希望是慈善的行为，有两种主要的方式会成为一个组织可能的损失。首先，如果实施不力或维护不当，它最终会成为你的组织的声誉的阻力。正如Apache社区的说法，我们应该优先考虑 "社区大于代码"。如果你提供了很好的代码，但却是一个糟糕的社区成员，这仍然会对你的组织和更广泛的社区造成伤害。其次，如果你不能保持同步，一个善意的发布会成为工程效率的负担。只要有时间，所有的分叉都会变得昂贵。

### 例子：开源gflags

对于声誉的损失，可以考虑像谷歌在2006年左右的经验，开放我们的C++命令行标志库的情况。当然，回馈开源社区是一个纯粹的善举，不会回来困扰我们，对吗？遗憾的是，不是。一系列的原因合谋使这一善举变成了肯定会伤害我们的声誉，也可能会损害开放源码社区。

- 当时，我们没有能力进行大规模的重构，所以所有内部使用该库的东西都必须保持原样--我们不能把代码移到代码库的新位置。

- 我们将我们的资源库隔离成 "内部开发的代码"（如果需要分叉，可以自由复制，只要正确重命名）和 "可能有法律/许可问题的代码"（可能有更细微的使用要求）。

- 如果一个开放源码软件项目接受来自外部开发者的代码，这通常是一个法律问题--项目发起人并不拥有该贡献，他们只拥有该贡献的权利。

因此，gflags 项目注定是一个 "扔到墙外 "的版本，或者是一个断开连接的分叉。贡献给项目的补丁不能被重新纳入谷歌内部的原始源码，我们不能在我们的monorepo中移动项目，因为我们还没有掌握这种形式的重构，我们也不能让内部的一切都依赖于开放源码版本。

此外，像大多数组织一样，我们的优先级也随着时间的推移而转移和改变。在最初发布那个旗帜库的时候，我们对传统领域（网络应用、搜索）以外的产品感兴趣，包括像谷歌地球这样的产品，它有一个更传统的发布机制：为各种平台预编译的二进制文件。在21世纪末，在我们的monorepo中的一个库，特别是像flags这样的低级的东西，被用在各种平台上，这是不寻常的，但也不是没有。随着时间的推移和谷歌的成长，我们的关注点逐渐缩小，除了我们内部配置的工具链之外，很少有任何库是用其他东西构建的，然后部署到我们的生产机群。对于正确支持像旗帜这样的开放源码软件项目来说，"可移植性 "问题几乎是不可能维持的：我们的内部工具根本不支持这些平台，而我们的普通开发人员也不需要与外部工具互动。为了保持可移植性，这是一场持久战。

随着最初的作者和开放源码软件的支持者转到新的公司或新的团队，最终发现内部没有人真正支持我们的开放源码软件旗帜项目--没有人可以将这种支持与任何特定团队的优先事项联系起来。鉴于这不是某个团队的工作，也没人能说清楚为什么它很重要，所以我们基本上让这个项目在外部烂掉也就不奇怪了。随着时间的推移，内部和外部的版本慢慢地发生了分歧，最终一些外部的开发者把外部的版本分叉了，给了它一些适当的关注。

除了最初的 "哦，看，谷歌为开源世界贡献了一些东西 "之外，没有任何一部分让我们看起来很好，然而考虑到我们工程组织的优先级，每一个小部分都是有意义的。我们这些接近它的人已经学会了，"如果没有一个长期支持它的计划（和授权），就不要发布东西"。整个谷歌工程部是否已经学会了这一点，还有待观察。这是个大组织。

除了模糊的 "我们看起来很糟糕 "之外，这个故事还有一些部分说明了我们是如何受制于拙劣的发布/拙劣的维护的外部依赖所带来的技术问题。虽然flags库被共享但被忽视，但仍有一些谷歌支持的开源项目，或需要在我们的monorepo生态系统之外共享的项目。不出所料，那些其他项目的作者能够识别该库的内部和外部分叉之间的共同API子集。因为这个共同的子集在两个版本之间长期保持着相当的稳定性，对于那些在2008年到2017年之间有不寻常的可移植性要求的少数团队来说，它默默地成为 "这样做的方式"。他们的代码可以在内部和外部生态系统中构建，根据环境切换出分叉版本的标志库。

然后，由于不相关的原因，C++库团队开始调整内部标志实现中可观察但未记录的部分。在这一点上，所有依赖于不支持的外部分叉的稳定性和等价性的人都开始尖叫，他们的构建和发布突然被破坏了。一个价值在谷歌整个舰队的数千个聚合CPU的优化机会被大大推迟了，不是因为难以更新2.5亿行代码所依赖的API，而是因为极少数项目依赖于未承诺的、意想不到的东西。海勒姆法则再一次影响了软件的变化，在这种情况下，甚至是由不同组织维护的分叉API。

## 案例研究：AppEngine

一个更严重的将我们自己暴露在意外的技术依赖性的更大风险中的例子来自于发布谷歌的AppEngine服务。这项服务允许用户在现有框架的基础上用几种流行的编程语言之一编写他们的应用程序。只要应用程序是用适当的存储/状态管理模型编写的，AppEngine服务允许这些应用程序扩展到巨大的使用水平：备份存储和前端管理是由谷歌的生产基础设施按需管理和克隆的。

最初，AppEngine对Python的支持是使用旧版本的Python解释器运行的32位构建。AppEngine系统本身（当然）是在我们的monorepo中实现的，并与我们其他的通用工具一起构建，用Python和C++来支持后端。2014年，我们开始对Python运行时进行重大更新，同时安装C++编译器和标准库，其结果是我们有效地将 "用当前C++编译器构建的代码 "与 "使用更新的Python版本的代码 "联系起来--一个项目如果升级了这些依赖中的一个，就同时升级了另一个。对于大多数项目来说，这并不是一个问题。对于少数项目，由于边缘案例和Hyrum's Law，我们的语言平台专家最终做了一些调查和调试，以解除过渡的障碍。在一个可怕的Hyrum's Law与商业实际相结合的例子中，AppEngine发现它的许多用户，即我们的付费客户，不能（或不愿）更新：要么他们不想改变到较新的Python版本，要么他们负担不起从32位到64位Python的资源消耗变化。因为有一些客户为AppEngine的服务支付了大量的费用，AppEngine能够提出一个强有力的商业案例，即必须推迟强制切换到新的语言和编译器版本。这就意味着AppEngine的依赖关系中的每一段C++代码都必须与旧的编译器和标准库版本兼容：对该基础设施的任何错误修复或性能优化都必须跨版本兼容。这种情况持续了近三年。

有了足够多的用户，你的系统的任何 "可观察性 "都会被某个人所依赖。在谷歌，我们将所有的内部用户限制在我们的技术堆栈的范围内，并确保他们的使用与monorepo和代码索引系统的可见性，所以更容易确保有用的改变是可能的。当我们从源码控制转向依赖性管理，并失去了对代码使用情况的可见性，或者受到来自外部团体（尤其是那些付钱给你的团体）的竞争性优先权的影响时，要做出纯粹的工程权衡就变得更加困难。发布任何类型的API都会使你暴露在竞争性的优先级和外部人员不可预见的限制的可能性中。这并不是说你不应该发布API；这只是为了提醒你：API的外部用户比内部用户的维护成本高得多。

与外部世界分享代码，无论是作为开放源码发布还是作为闭源库发布，都不是一个简单的慈善问题（在开放源码的情况下）或商业机会（在闭源的情况下）。你无法监控的依赖性用户，在不同的组织中，有不同的优先级，最终会对该代码施加某种形式的海勒姆法则的惯性。特别是当你工作的时间尺度较长时，你不可能准确地预测可能成为有价值的必要或有用的变化的集合。当评估是否要发布一些东西时，要意识到长期的风险：外部共享的依赖关系随着时间的推移，修改的成本往往要高得多。

## 结论

依赖关系管理在本质上是一种挑战--我们正在寻找管理复杂的API表面和依赖关系网络的解决方案，这些依赖关系的维护者通常很少或根本没有协调的假设。管理依赖关系网络的事实上的标准是语义版本管理（SemVer），它对采用任何特定变化的感知风险提供了有损的总结。SemVer的前提是，在不知道有关的API是如何被消费的情况下，我们可以先验地预测变化的严重性。海勒姆定律告诉我们并非如此。然而，SemVer在小规模下工作得足够好，当我们包括MVS方法时，甚至更好。随着依赖网络规模的扩大，SemVer中的Hyrum定律问题和保真度损失使得管理新版本的选择越来越困难。

然而，我们有可能走向这样一个世界：维护者提供的兼容性估计（SemVer版本号）被放弃，而采用经验驱动的证据：运行受影响的下游包的测试。如果API供应商承担起更大的责任，针对他们的用户进行测试，并明确宣传预期的变化类型，我们就有可能在更大的范围内建立更高保真的依赖性网络。

## TL;DRs

- 更倾向于源控制问题，而不是依赖性管理问题：如果你能从你的组织中获得更多的代码，以获得更好的透明度和协调，这些都是重要的简化。

- 对于一个软件工程项目来说，添加一个依赖关系并不是免费的，建立一个 "持续的 "信任关系的复杂性是具有挑战性的。将依赖关系导入你的组织需要谨慎行事，并了解持续支持的成本。

- 依赖关系是一个合同：有付出就有收获，提供者和消费者在该合同中都有一些权利和责任。供应商应该清楚地了解他们在一段时间内试图承诺什么。

- SemVer是对 "人类认为这一变化的风险有多大 "的一种有损压缩的速记估计。SemVer与软件包管理器中的SAT解算器一起，将这些估计值升级为绝对值。这可能会导致过度约束（依赖性地狱）或不足约束（应该一起工作的版本却没有）。

- 相比之下，测试和CI提供了一组新版本是否能一起工作的实际证据。

- SemVer/包管理中的最小版本更新策略的保真度更高。这仍然依赖于人类能够准确地评估增量版本的风险，但明显提高了API提供者和消费者之间的联系已经被专家测试的机会。

- 单元测试、CI和（廉价）计算资源有可能改变我们对依赖性管理的理解和方法。这一阶段性变化要求从根本上改变业界对依赖性管理问题的看法，以及提供者和消费者的责任。

- 提供依赖性并不是免费的。"把它扔到墙上，然后忘掉 "会使你失去声誉，并成为兼容性的挑战。支持它的稳定性会限制你的选择并降低内部使用。没有稳定性的支持可能会损失商誉，或者使你面临重要的外部团体通过海勒姆法则依赖某些东西的风险，并使你的 "无稳定性 "计划陷入困境。
