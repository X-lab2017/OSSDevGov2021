**情景：没有明确的真相来源**

设想一下，您的团队充分遵循DVCS理念，避免将特定的分支+存储库定义为真相的最终来源。

在某些方面，这让人想起演示v5-final-redlines-Josh的v2版模型在您从队友的存储库中提取之后，不一定清楚哪些更改存在哪些不存在。在某些方面，它比这更好，因为DVCS模型以比那些特殊命名方案更精细的粒度跟踪单个补丁的合并，但是DVCS知道合并了哪些更改，并且每个工程师都确保他们表示了所有过去/相关的更改，这两者之间存在差异。

考虑如何确保发布版本包含每个开发人员在过去几周内开发的所有特性。有什么（非集中的、可扩展的）机制可以做到这一点？我们能设计出比让每个人签字都好的政策吗？随着团队规模的扩大，是否存在只需要次线性人工努力的问题？随着团队中开发人员数量的增加，这种情况还会继续吗？据我们所知：可能不是。如果没有一个真实的中心来源，有人会保留一个列表，列出哪些特性可能会被包含在下一个版本中。最终，簿记复制了拥有一个集中的真相来源的模式。

进一步设想：当一个新的开发人员加入团队时，他们从哪里得到一个新的、已知的好的代码副本？

DVCS支持许多优秀的工作流和有趣的使用模型。但是，如果您关心的是如何找到一个系统，随着团队的发展，它需要次线性的人力来管理，那么将一个存储库（和一个分支）实际定义为真相的最终来源是非常重要的。

在这个真理的来源中有一些相对性。也就是说，对于一个给定的项目，真理的来源对于不同的组织可能是不同的。这个警告很重要：对于Google或RedHat的工程师来说，Linux内核补丁有不同的真实来源是合理的，但仍然不同于Linus（Linux内核维护者）自己。当组织和它们的真相来源是等级的（并且组织外部的人看不见的）时，DVCS工作得很好------这也许是DVCS模型最实用的效果。RedHat工程师可以提交到本地的真相来源库，并且可以周期性地将更改从那里推到上游，而Linus对什么是真相的来源有完全不同的概念。只要没有选择或不确定的地方，改变应该推动，我们可以避免一大类混沌标度问题的DVCS模型。

在所有这些想法中，我们赋予主干分支特殊的意义。但当然，风投中的"主干"只是技术默认值，一个组织可以在此基础上选择不同的策略。也许默认的分支已经被放弃了，所有的工作实际上都发生在一些定制开发分支上，除了需要在更多的操作中提供一个分支名称之外，这种方法没有内在的缺陷；只是不规范。在讨论版本控制时有一个（经常说不出的）事实：对于任何给定的组织，技术只是其中的一部分；除此之外，几乎总是有等量的策略和使用约定。

版本控制中没有比讨论如何使用和管理分支更具策略性和惯例性的话题了。我们将在下一节更详细地介绍分支管理。

##### 版本控制与依赖关系管理

关于版本控制策略和依赖关系管理的讨论在概念上有很多相似之处（见第21章）。区别主要有两种形式：VCS策略主要是关于如何管理自己的代码，而且通常粒度要细得多。依赖关系管理更具挑战性，因为我们主要关注由其他组织以更高的粒度管理和控制的项目，这些情况意味着您没有完美的控制。我们将在本书后面讨论更多这些高层次的问题。

#### 分支机构管理

能够在版本控制中跟踪不同的修订为如何管理这些不同的版本提供了多种不同的方法。总的来说，这些不同的方法属于术语分支管理，而不是单一的主干

##### 正在进行的工作类似于一个分支

一个组织关于分支管理策略的任何讨论至少应该承认组织中每一项正在进行的工作都等同于一个分支。这在DVCS中更为明显，在DVCS中，开发人员更有可能在返回到上游真相源之前进行大量本地暂存提交。集中式VCS仍然如此：未提交的本地更改在概念上与分支上提交的更改没有区别，只是可能更难找到和区分。一些集中式系统甚至明确了这一点。例如，在使用Perforce时，每个更改都会给出两个修订号：一个表示创建更改的隐式分支点，另一个表示重新提交更改的位置，如图16-1所示。Perforce用户可以查询查看对给定文件有未完成更改的用户，检查其他用户未提交更改中的挂起更改，等等。

![](images\16-1.png)

*图16-1。Perforce中的两个修订号*

这种"未提交的工作类似于分支"的想法在考虑重构任务时尤其重要。假设一个开发人员被告知，"将Widget重命名为OldWidget"。这取决于组织的分支管理策略和理解，什么是分支，哪些分支重要，这可能有几种解释：

•重命名真相资源库中主干分支上的小部件

•重命名真相资源库中所有分支上的小部件

•重命名真相资源库中所有分支上的Widget，并查找对引用Widget的文件有未完成更改的所有dev

如果我们推测，试图支持"在任何地方重命名此文件，甚至在未完成的更改中"用例是为什么商业集中式VCS倾向于跟踪"哪个工程师打开此文件进行编辑？"（我们不认为这是执行重构任务的可伸缩方式，但我们理解这种观点。）

##### 开发分支

在一致性单元测试之前的时代（见第11章），当引入任何给定的更改都有很高的风险使系统中其他地方的功能退化时，特别对待trunk是有意义的。"你的技术负责人可能会说："在新的变化经过一轮完整的测试之前，我们不会承诺使用trunk。"。我们的团队使用特定于功能的开发分支。"

一个开发分支（通常是"dev分支"）是介于"这已经完成但还没有承诺"和"这是新工作的基础"之间的一个中间点。这些分支试图解决的问题（产品的不稳定性）是一个合法的问题，但是我们发现，通过更广泛地使用测试、持续集成（CI）（见第23章）和质量强制实践（如彻底的代码审查），可以更好地解决问题。

我们认为，一个版本控制政策，使广泛使用开发分支作为一种手段，对产品的稳定性是固有的误导。同一组提交最终将被合并到trunk。小的合并比大的合并容易。编写这些更改的工程师所做的合并要比批处理不相关的更改并稍后进行合并（如果团队共享一个开发分支，则最终会发生这种情况）容易得多。如果对合并进行的预提交测试发现了任何新问题，那么同样的论点也适用：如果只涉及一个工程师，则更容易确定谁的更改是导致回归的原因。合并一个大的dev分支意味着该测试运行中发生了更多的更改，使得故障更难隔离。分类和根源问题困难；修复它更糟糕。

除了缺乏专业知识和合并单个分支时的固有问题之外，依赖dev分支时还有很大的扩展风险。对于软件组织来说，这是一个非常常见的生产力消耗。当有多个分支被长时间孤立地开发时，协调合并操作的成本会明显高于基于主干的开发。

**我们为何沉迷于开发分支？**

很容易看出组织是如何落入这个陷阱的：他们看到，"合并这个长期存在的开发分支会降低稳定性"并得出结论，"分支合并是有风险的。"而不是用"更好的测试"和"不要使用基于分支的开发策略"来解决这个问题，他们专注于减缓和协调症状：分支合并。团队开始在其他飞行中分支的基础上开发新分支。在一个长期存在的开发分支上工作的团队可能会也可能不会定期将该分支与主开发分支同步。随着组织规模的扩大，开发分支的数量也随之增加，并且在协调分支合并策略上投入了更多的精力。在分支合并的协调上投入了越来越多的精力，这是一项本质上不可伸缩的任务。一些不走运的工程师成为构建主控/合并协调器/内容管理工程师，专注于充当单点协调器来合并组织中所有不同的分支。定期安排的会议试图确保组织已经"制定了本周的合并策略"。<sup>8</sup>没有选择合并的团队通常需要在每次大型合并之后重新同步和重新测试。

合并和重新测试的所有工作都是纯粹的开销。另一种方法需要不同的范例：基于主干的开发，严重依赖于测试和CI，保持构建为绿色，并在运行时禁用不完整/未测试的特性。每个人都有责任同步到trunk并提交；没有"合并战略"会议，没有大型/昂贵的合并。而且，对于应该使用哪种版本的库，没有激烈的讨论------只能有一个版本。真相必须只有一个来源。最后，将有一个单一的版本用于发布：缩小到一个单一的真相来源只是"左移"的方法，以确定什么是和不包括在内。

> [8] 最近的Twitter非正式调查显示，大约25%的软件工程师已经参加了“定期安排的”合并战略会议。

##### 释放分支

如果产品的发布间隔（或发布生存期）长于几个小时，那么创建一个发布分支来表示进入产品的发布版本的确切代码可能是明智的。如果在该产品的实际发布和下一个发布周期之间发现了任何关键缺陷，那么可以从主干到您的发布分支仔细挑选修复（一种最小的、有针对性的合并）。

与dev分支相比，release分支通常是良性的：麻烦的不是分支的技术，而是用法。dev分支和release分支之间的主要区别是预期的结束状态：dev分支预期会合并回trunk，甚至可能被另一个团队进一步分支。预计最终会放弃一个发布分支。

在谷歌的DevOps研究和评估（DORA）组织确定的功能最高的技术组织中，发布分支实际上是不存在的。那些已经实现了连续部署（CD）的组织------每天从主干中多次发布的能力------可能倾向于跳过发布分支：简单地添加修复和重新部署就容易多了。因此，樱桃采摘和树枝似乎是不必要的开销。显然，这更适用于以数字方式部署（如web服务和应用程序）的组织，而不是那些向客户推送任何形式的有形发布的组织；一般来说，准确地知道推给客户的是什么是很有价值的。

同一项DORA研究还表明，"基于集群的开发"、"没有长期存在的开发分支"和良好的技术成果之间有很强的正相关关系。这两种想法的基本思想似乎都很清楚：分支机构拖累了生产力。在许多情况下，我们认为复杂的分支和合并策略是一个安全的支柱，试图保持主干稳定。正如我们在这本书中看到的，还有其他的方法来实现这个结果。

#### 谷歌的版本控制

在Google，我们的绝大多数资源都在一个由大约50000名工程师共享的存储库（monorepo）中管理。除了Chromium和Android等大型开源项目外，几乎所有由Google拥有的项目都在那里。这包括面向公众的产品，如搜索、Gmail、我们的广告产品、我们的谷歌云平台产品，以及支持和开发所有这些产品所必需的内部基础设施。

我们依赖于内部开发的集中式VCS，称为Piper，构建为在我们的生产环境中作为分布式微服务运行。这使我们能够使用Google标准的存储、通信和计算即服务技术，为全球提供存储超过80tb内容和元数据的VCS。Piper monorepo每天都被成千上万的工程师同时编辑和发布。在使用版本控制（或改进签入VCS的内容）的人工和半自动化流程之间，我们将在每个工作日定期处理60000到70000个对存储库的提交。二进制工件非常常见，因为完整的存储库不会被传输，因此二进制工件的正常成本并不适用。由于从最早的概念开始就关注Google规模，这个风投生态系统中的操作在人类规模上仍然是廉价的：在trunk上创建一个新的客户端、添加一个文件以及向Piper提交一个（未查看的）更改可能总共需要15秒。这种低延迟的交互和良好理解/设计的扩展简化了许多开发人员的体验。

由于Piper是一个内部产品，我们能够定制它并执行我们选择的任何源代码控制策略。例如，我们在monorepo中有一个粒度所有权的概念：在文件层次结构的每个级别上，我们都可以找到所有者文件，这些文件列出了允许在存储库的子树中批准提交的工程师的用户名（除了树中更高级别列出的所有者）。在具有许多存储库的环境中，这可能是通过使用文件系统权限强制控制提交访问的单独存储库来实现的，或者通过Git"commit hook"（在提交时触发的操作）来执行单独的权限检查。通过控制VCS，我们可以使所有权和批准的概念更加明确，并在尝试提交操作期间由VCS强制执行。该模型也很灵活：所有权只是一个文本文件，不与存储库的物理分离相联系，因此在团队转移或组织重组的结果中进行更新很简单。

##### 一个版本

单凭Piper令人难以置信的伸缩能力是无法实现我们所依赖的那种协作的。正如我们前面说过的：版本控制也是关于策略的。除了我们的风投，Google版本控制策略的一个关键特性就是我们所说的"一个版本"。这扩展了我们之前看到的"单一真实来源"的概念，确保开发人员知道哪个分支和存储库是他们的真实来源，比如"对于存储库中的每个依赖项，必须只有一个版本的依赖项可供选择。<sup>9</sup>对于第三方包，这意味着在稳定状态下，这个包只能有一个单独的版本签入我们的存储库。"<sup>10</sup>对于内部包，这意味着没有重新打包/重命名就没有分叉：在技术上必须安全地将原始和分叉混合到同一个项目中，而无需特别的努力。对于我们的生态系统来说，这是一个强大的特性：很少有像"如果你包含这个包（A），你就不能包含其他包（B）"这样的限制

将一个副本放在一个存储库中的一个分支上作为真相的来源这一概念很直观，但在应用中也有一些微妙的深度。让我们研究一个场景，在这个场景中，我们有一个monorepo（因此可以说已经实现了关于单一真相来源的法律条文），但是允许我们的库的分叉在主干上传播。

##### 场景：多个可用版本

想象一下下面的场景：某个团队在公共基础架构代码中发现了一个bug（在我们的例子中是Abseil或Guava之类的）。团队没有将其修复到位，而是决定分叉该基础结构并对其进行调整，以便在不重命名库或符号的情况下解决该缺陷。它会通知附近的其他团队，"嘿，我们在这里签入了Abseil的一个改进版本：签出它。"其他一些团队构建了依赖于这个新fork的库。

正如我们将在第21章看到的，我们现在处于危险的境地。如果代码库中的任何项目同时依赖Abseil的原始版本和分叉版本，那么在最佳情况下，构建失败。在最坏的情况下，我们会遇到难以理解的运行时错误，这些错误源于链接到同一库的两个不匹配的版本。"fork"有效地为代码库添加了一个着色/分区属性：任何给定目标的可传递依赖集必须正好包含这个库的一个副本。从代码库的"原始风格"分区添加到"新fork"分区的任何链接都可能会破坏某些东西。这意味着最终像"添加一个新的依赖项"这样简单的操作可能需要对整个代码库运行所有测试，以确保我们没有违反这些分区要求之一。这是昂贵的，不幸的，而且不能很好地扩展。

> [9]例如，在升级操作期间，可能签入了两个版本，但如果开发人员在现有包上添加新的依赖项，则不应该选择依赖哪个版本。
>
> [10]也就是说，我们在很多情况下都失败了，因为外部包有时会在源代码版本中绑定它们自己的依赖项的副本。你可以在第21章读到更多关于这一切是如何出错的。

在某些情况下，我们可能能够以一种允许生成的可执行文件正确运行的方式将这些东西组合在一起。例如，Java有一个相对标准的做法，称为shading，它调整库的内部依赖项的名称，以便对应用程序的其余部分隐藏这些依赖项。在处理函数时，这在技术上是合理的，即使理论上有点像黑客。当处理可以从一个包传递到另一个包的类型时，着色解决方案在理论上和实践中都不起作用。据我们所知，任何允许一个库的多个独立版本在同一个二进制文件中运行的技术伎俩都有一个共同的局限性：这种方法适用于函数，但是没有一个好的（有效的）解决方案来处理着色类型，任何提供词汇表类型（或任何更高级别的构造）的库的多个版本都会失败。着色和相关的方法正在修补基础问题：同一依赖关系的多个版本是需要(我们将在第21章中讨论如何将其最小化。）

任何允许在同一个代码库中使用多个版本的策略系统都允许存在这些代价高昂的不兼容性。有可能你会侥幸逃脱一段时间（我们当然有一些小违反这项政策），但一般来说，任何多版本的情况都有非常现实的可能导致大问题。

##### "一个版本"规则

记住这个例子，在单一真实源模型的基础上，我们有希望理解这个看似简单的源代码控制和分支管理规则的深度：

开发人员决不能选择"我应该依赖哪个版本的组件？"

通俗地说，这类似于"一个版本规则"。在实践中，"一个版本"并不难<sup>11</sup>，但在添加新依赖项时，围绕限制可以选择的版本来表达这一点，传达了一种非常强大的理解。

对于单个开发人员来说，缺乏选择似乎是一个任意的障碍。然而，我们一次又一次地看到，对于一个组织来说，它是高效扩展的关键组成部分。一致性在组织的各个层面都具有深远的重要性。从一个角度看，这是讨论一致性和确保能够利用一致的"瓶颈"的直接副作用

> [11]例如，如果有定期更新的外部/第三方库，那么在单个原子更改中更新该库并更新其所有使用可能是不可行的。因此，通常需要添加该库的新版本，防止新用户添加对旧库的依赖，并逐步地从旧库切换到新库。