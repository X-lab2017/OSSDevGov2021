
![](./images/17-3.png)
图17-3 栈框架中的代码搜索集成
编译错误和测试通常还会返回到代码位置（例如，测试X在文件中的行位置）。鉴于大多数开发都发生在特定的对云可见的工作空间中，因此可以将这些链接链接起来，即使未提交的代码也可以通过代码搜索访问和搜索。

最后，codelab和其他文档引用了API，示例和实现的链接。此类链接可以是引用特定类或函数的搜索查询，当文件结构更改时，这些查询仍然有效。对于代码片段，可以将最新的实现轻松地嵌入到文档页面中，如图17-4所示，而无需使用其他文档标记来污染源文件。
![](./images/17-4.png)
图17-4 文档中的代码搜索集成
### API公开
代码搜索将其搜索，交叉引用和语法高亮API公开给工具，因此工具开发人员可以将这些功能引入其工具中，而无需重新实现它们。此外，已经编写了插件来为vim，emacs和IntelliJ等编辑器和IDE提供搜索和交叉引用。这些插件恢复了由于无法在本地对代码库进行索引而造成的部分功能损失，并降低了开发人员的工作效率。

## 规模对设计的影响
在上一节中，我们研究了代码搜索UI的各个方面，以及为什么值得使用一个单独的工具来浏览代码的原因。在以下各节中，我们将稍微看一下实现的背后。首先，我们讨论了主要的挑战-扩展-然后讨论了使大规模组合成为搜索和浏览代码的良好产品的一些复杂方法。之后，我们详细介绍了如何应对其中的一些挑战，以及在构建代码搜索时进行了哪些权衡。

搜索代码的最大扩展挑战是语料库大小。对于只有几兆字节的小型存储库，可以使用grep搜索进行强力搜索。当需要搜索数百兆字节时，简单的本地索引可以将搜索速度提高一个数量级或更多。当需要搜索千兆字节或TB级的源代码时，具有多台计算机的云托管解决方案可以使搜索时间保持合理。中央解决方案的实用性随使用它的开发人员数量和代码空间的大小而增加。

### 搜索查询延迟

尽管我们认为快速响应的UI对用户更好，但低延迟并不是免费的。为了证明这项工作的合理性，可以将其与所有用户节省的工程时间进行权衡。在Google内部，我们每天在“代码搜索”中处理来自开发人员的搜索查询超过一百万次。对于一百万个查询，每个搜索请求仅增加一秒钟，相当于每天约有35位空闲的专职工程师。相反，搜索后端可以由大约十分之一的工程师来构建和维护。这意味着每天大约有100,000个查询（相当于少于5,000个开发人员），只有一秒钟的延迟参数才可以达到收支平衡点。

实际上，生产效率损失并不是随延迟线性增长的。如果延迟低于200毫秒，UI被认为是响应性的。但是仅仅一秒钟后，开发人员的注意力往往开始漂移。如果再过10秒，开发人员很可能完全切换上下文，通常认为上下文具有较高的生产效率代价。保持开发人员处于生产“流”状态的最佳方法是将所有频繁操作的端到端延迟设置为低于200毫秒，并投资相应的后端。

为了浏览代码库，执行了大量的代码搜索查询。理想情况下，只需单击一下“下一个”文件（例如，对于包含的文件或符号定义），但是对于常规导航，而不是使用传统的文件树，只需搜索所需文件或符号，理想情况下无需完全指定它，并且为部分文本提供了建议。随着代码库（和文件树）的增长，这一点变得越来越正确。

正常导航到另一个文件夹或项目中的特定文件需要几次用户交互。通过搜索，只需几次点击就足以到达相关文件。为了使搜索有效，可以将有关搜索上下文的其他信息（例如，当前查看的文件）提供给搜索后端。上下文可以将搜索限制在特定项目的文件中，或者通过优先选择与其他文件或目录接近的文件来影响排名。在代码搜索UI中，用户可以预定义多个上下文，并根据需要在它们之间快速切换。在编辑器中，打开或编辑的文件被隐式用作上下文，以优先考虑在它们附近的搜索结果。

可以考虑将搜索查询语言的功能（例如，使用正则表达式指定文件）作为另一条件；我们将在本章稍后的“权衡”部分中对此进行讨论。

### 索引延迟

大多数时候，开发人员不会注意到索引何时过时。他们只关心一小部分代码，即使如此，他们通常也不知道是否有更新的代码。但是，对于他们编写或审查相应更改的情况，不同步可能会引起很多混乱。更改是小的修正，重构还是全新的代码通常无关紧要-开发人员只是期望一致的视图，例如他们在IDE中对小型项目的体验。

编写代码时，应立即索引已修改的代码。添加新文件，函数或类后，无法找到它们令人沮丧，并且破坏了用于完善交叉引用的开发人员的常规工作流程。另一个示例是基于搜索和替换的重构。当删除的代码立即从搜索结果中消失时，这不仅更加方便，而且随后的重构必须考虑新的状态，这一点也很重要。使用集中式VCS时，如果先前的更改不再是本地修改的文件集的一部分，则开发人员可能需要立即为提交的代码建立索引。

相反，有时能够及时返回到以前的代码快照很有用；换句话说，就是发布。在事件发生期间，索引和运行代码之间的差异可能尤其成问题，因为它可能隐藏真正的原因或引起无关紧要的注意力。对于交叉引用而言，这是一个问题，因为目前以Google规模构建索引的技术仅需花费数小时，而复杂性意味着仅保留了索引的一个“版本”。尽管可以进行一些修补以使新代码与旧索引对齐，但这仍然是一个要解决的问题。

## Google的实现
Google针对代码搜索的特定实现方式是针对其代码库的独特特征量身定制的，上一节概述了我们为创建健壮且响应迅速的索引而进行的设计约束。以下部分概述了代码搜索小组如何实施并将其工具发布给Google开发人员。

### 搜索索引
由于其庞大的规模，Google的代码库对于“代码搜索”来说是一个特殊的挑战。在早期，采用了基于三字母组的方法。拉斯·考克斯（RussCox）随后开源了简化版本。当前，代码搜索索引大约1.5TB的内容，每秒处理大约200个查询，其中服务器端搜索延迟的中位数小于50毫秒，索引编制延迟的中位数（介于代码提交和索引可见性之间的时间）小于10秒。

让我们粗略估计使用基于grep的暴力解决方案来实现此性能所需的资源。RE2库用于正则表达式匹配过程，用于RAM中的数据约100MB/秒。给定一个50毫秒的时间窗口，将需要300,000个内核来处理1.5TB的数据。因为在大多数情况下，简单的子字符串搜索就足够了，所以可以用一种特殊的子字符串搜索来替换正则表达式，该子字符串搜索在某些条件下可以以大约1GB/秒的速度进行处理，从而将内核数减少了10倍。到目前为止，我们仅研究了在50毫秒内处理单个查询的资源需求。如果我们每秒收到200个请求，则其中的10个将同时在50毫秒的窗口中处于活动状态，从而使我们回到300,000个内核，仅用于子字符串搜索。

尽管此估计忽略了一旦找到一定数量的结果，搜索就可以停止，或者可以比内容搜索更有效地评估文件限制，但是它不会占用通信开销，排名或将粉丝分散到成千上万机器都考虑在内。但这很好地显示了所涉及的规模，以及Google的代码搜索团队为何不断投资以改善索引编制。多年来，我们的索引从最初的基于三字母组的解决方案，通过基于自定义后缀数组的解决方案，变为当前的稀疏n-gram解决方案。这一最新解决方案的效率比暴力解决方案高500倍以上，同时还能够以惊人的速度回答正则表达式搜索。

我们从基于后缀数组的解决方案转向基于令牌的n-gram解决方案的一个原因是，利用了Google的主要索引和搜索栈。使用基于后缀数组的解决方案，构建和分配自定义索引本身就是一个挑战。通过利用“标准”技术，我们将从核心搜索团队在反向索引构建，编码和服务方面的所有进步中受益。即时索引是标准搜索栈中存在的另一个功能，而在大规模解决它时，它本身就是一个很大的挑战。

依靠标准技术是实现简单性和性能之间的权衡。即使Google的代码搜索实施是基于标准反向索引的，但实际的检索，匹配和评分还是高度定制和优化的。否则，某些更高级的代码搜索功能将无法实现。为了对文件修订历史进行索引，我们提出了一种自定义压缩方案，其中对整个历史进行索引仅使资源消耗增加了2.5倍。

在早期，“代码搜索”提供了内存中的所有数据。随着索引大小的增加，我们将倒排索引移至闪存。尽管闪存至少比内存便宜一个数量级，但其访问延迟至少要高两个数量级。因此，当从闪存中提供服务时，在内存中运行良好的索引可能不适合。例如，原始的Trigram索引不仅需要从Flash中获取大量的反向索引，而且还需要获取相当大的反向索引。使用n-gram方案时，可以减少反索引的数量及其大小，但要以较大的索引为代价。

为了支持本地工作空间（从全局存储库中获取较小的增量），我们有多台机器进行简单的暴力搜索。工作区数据在第一个请求上加载，然后通过侦听文件更改保持同步。当内存不足时，我们将从计算机中删除最近的工作空间。使用我们的历史索引搜索未更改的文档。因此，搜索隐式限于工作空间同步到的存储库状态。
### 排名
对于非常小的代码库，排名并不能带来太多好处，因为总的来说结果并不多。但是代码库越大，发现的结果就越多，排名也越重要。在Google的代码库中，任何简短的子字符串都会出现数千次（即使不是数百万次）。如果不进行排名，用户要么必须检查所有这些结果以找到正确的结果，要么必须进一步细化查询，直到结果集减少为少数文件为止。两种选择都浪费了开发人员的时间。

排名通常从评分功能开始，该功能将每个文件的一组功能（“信号”）映射到某个数字：分数越高，结果越好。然后，搜索的目标是尽可能高效地找到前N个结果。通常，可以区分两种信号：仅依赖于文档的信号（“独立于查询”）和依赖于搜索查询及其与文档的匹配方式的信号（“依赖于查询”）。文件名的长度或文件的编程语言将是与查询无关的信号的示例，而匹配是函数定义还是字符串文字则是与查询相关的信号。

#### 查询独立信号
一些最重要的与查询无关的信号是文件视图的数量和对文件的引用数量。文件视图很重要，因为它们指示开发人员认为哪些文件很重要，因此更有可能要查找。例如，基本库中的实用程序功能具有很高的视图计数。该库是否已经稳定并且不再更改，或者该库是否正在积极开发都无关紧要。该信号最大的缺点是它产生的反馈环路。通过对经常查看的文档评分更高，开发人员查看它们的机会会增加，而其他文档进入前N名的机会也会减少。此问题被称为“开发与探索”，存在各种解决方案（例如，高级A/B搜索实验或训练数据的整理）。在实践中，高分的项目似乎并没有什么害处：当它们不相关时，它们将被简单地忽略；如果需要通用的示例，则将其取而代之。但是，这对于新文件来说是个问题，因为新文件还没有足够的信息来发出良好的信号。
通过将Web链接替换为大多数语言中存在的各种“包含/导入”语句，我们还使用了与原始页面排名算法相似的文件引用数量。我们可以将概念扩展到构建依赖关系（库/模块级别的引用），再扩展到函数和类。这种全球相关性通常被称为文档的“优先级”。

在使用参考进行排名时，必须意识到两个挑战。首先，您必须能够可靠地提取参考信息。早期，Google的代码搜索使用简单的正则表达式提取包含/导入语句，然后应用启发式将其转换为完整的文件路径。随着代码库的复杂性不断增长，这种启发式方法变得容易出错，并且难以维护。在内部，我们用Kythe图中的正确信息替换了此部分。

大规模重构，例如开源核心库，提出了第二个挑战。此类更改不会在单个代码更新中自动发生；相反，它们需要分多个阶段推出。通常，会引入间接寻址，例如，隐藏使用情况中的文件移动。这些类型的间接操作会降低已移动文件的页面排名，并使开发人员更难发现新位置。此外，文件视图通常在文件移动时丢失，从而使情况更糟。由于此类代码库的全局重组相对较少（大多数接口很少移动），因此最简单的解决方案是在此类过渡期间手动增强文件。（或者等到迁移完成并等待自然过程将文件升级到新位置。）

#### 查询相关信号
可以独立地计算与查询无关的信号，因此尽管成本可能很高，但计算成本并不是主要问题。例如，对于“页面”排名，信号取决于整个语料库，并且需要类似MapReduce的批处理来计算。必须为每个查询计算的与查询相关的信号，计算起来应该便宜。这意味着它们仅限于可从索引快速访问的查询和信息。

与网络搜索不同，我们不仅匹配令牌。但是，如果存在干净的令牌匹配项（即，搜索项与带有某种形式的中断的内容（例如，空格）相匹配），则会进一步提高匹配度并考虑区分大小写。举例来说，这意味着搜索“point”相对于“point *p”的得分要高于“被任命为理事会的得分”。

为了方便起见，除实际文件内容外，默认搜索还匹配文件名和合格符号。用户可以指定特定的匹配类型，但不必指定。评分提高了符号和文件名的匹配度，超过了常规内容的匹配度，以反映开发人员的推断意图。