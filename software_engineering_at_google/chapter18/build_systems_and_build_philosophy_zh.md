### 第十八章 构建系统和构建哲学


如果您问Google工程师，他们在Google工作时最喜欢什么（除了免费的食物和凉爽的产品），您可能会听到一些令人惊讶的消息：工程师喜欢构建系统。为了确保我们的工程师能够快速可靠地编写代码，谷歌在其一生中花费了大量的工程努力，从头开始创建自己的构建系统。这项工作非常成功，构建系统的主要组成部分Blaze已经被离开公司的前谷歌员工重构了好几次。2015年，Google最终开源了名为Bazel的Blaze实现。

#### 构建系统的目的
从根本上说，所有构建系统都有一个直接的目的: 它们将工程师编写的源代码转换为可由机器读取的可执行二进制文件。一个好的构建系统通常会针对两个重要属性进行优化:

快：开发人员应该能够键入单个命令来运行构建并取回生成的二进制文件，通常只需几秒钟。
准确：每次开发人员在任何计算机上运行构建时，他们都应获得相同的结果（假设源文件和其他输入相同）。

许多较早的构建系统都试图通过采取可能导致构建不一致的捷径来在速度和正确性之间做出权衡。Bazel 的主要目标是避免在速度和正确性之间做出选择，提供一个构建系统结构，以确保始终能够有效和一致地构建代码。
构建系统不仅仅适合人类。 它们还允许机器自动创建构建，无论是用于测试还是用于生产发布。实际上，Google的大多数构建都是自动触发的，而不是由工程师直接触发的。几乎我们所有的开发工具都以某种方式与构建系统相结合，为我们的代码库工作人员提供了巨大的价值。

下面是一个利用我们的自动构建系统的工作流程的小例子:

- 代码是自动生成、测试和推送到生产环境中的，不需要任何人工干预。不同的团队以不同的速度执行此操作：一些团队每周推进，另一些团队每天推进，而其他团队则尽可能快地创建和验证新版本。(请参阅第24章)
- 将开发人员的代码更改更改发送给审阅者进行代码审核时(请参阅第19章)，系统会对其进行自动测试，以便作者和审阅者都可以立即看到由更改引起的任何构建或测试问题。
- 在将更改合并到主干之前，会立即再次测试更改，这使得提交突发更改变得更加困难。
- 低级库的作者能够在整个代码库中测试其更改，从而确保其更改在数百万个测试和二进制文件中是安全的。
- 工程师能够创建大规模的更改(LSCs) ，每次触及数以万计的源文件(例如，重命名一个公共符号) ，同时仍然能够安全地提交和测试这些更改。(请参阅第22章)

这一切之所以成为可能，仅仅是因为谷歌在其构建系统上的投资。尽管Google的规模可能是独一无二的，但任何规模的组织都可以通过适当使用现代构建系统来实现类似的收益。

### 没有构建系统会发生什么？

构建系统使您的开发可以扩展。正如我们将在下一节中说明的那样，在没有适当的构建环境的情况下，我们会遇到扩展问题。

### 但是我所需要的只是一个编译器！

对构建系统的需求可能不会立即显现出来。毕竟，当我们第一次学习编码时，我们大多数人可能没有使用过构建系统——我们可能首先从命令行直接调用gcc或javac之类的工具，或者在集成开发环境（IDE）中调用了类似的工具 。只要我们所有的源代码都在同一个目录中，这样的命令就可以正常工作：
```
javac *.java
```
这指示Java编译器获取当前目录中的每个Java源文件，并将其转换为二进制类文件。 在最简单的情况下，这就是我们所需要的。

然而，一旦我们的代码扩展，事情就变得更加复杂。javac非常聪明，可以在当前目录的子目录中查找要导入的代码。但是它没有办法找到存储在文件系统其他部分的代码(可能是我们的几个项目共享的库)。显然，它也只知道如何构建Java代码。大型系统通常包含用不同编程语言编写的不同部分，这些部分之间存在依赖关系，这意味着没有一个单一语言的编译器可以构建整个系统。

一旦我们不得不处理来自多种语言或多个编译单元的代码时，构建代码就不再是一个一步到位的过程了。现在我们需要考虑我们的代码依赖于什么，并按照正确的顺序构建这些部分，可能对每个部分使用不同的工具集。如果更改任何依赖项，则需要重复此过程以避免依赖过时的二进制文件。对于即使是中等规模的代码库，这个过程也会很快变得冗长乏味并且容易出错。

编译器也不知道如何处理外部依赖关系，比如 Java 中的第三方 JAR 文件。在没有构建系统的情况下，我们能做的最好的事情就是从互联网上下载依赖项，把它放在硬盘上的一个lib文件夹中，然后配置编译器从该目录读取库。随着时间的推移，我们很容易忘记我们在那里放置了什么库，它们从哪里来，以及它们是否仍在使用。当库维护人员发布新版本时，希望他们能保持最新。

### 使用Shell脚本来解决？

假设您的喜爱项目开始时非常简单，您可以使用一个编译器来构建它，但是您开始遇到前面描述的一些问题。也许您仍然不认为需要一个真正的构建系统，可以使用一些简单的 shell 脚本来自动化那些繁琐的部分，这些脚本可以按照正确的顺序进行构建。这会帮上一阵子，但是很快您就会遇到更多问题：

- 这就变得乏味了。随着系统变得越来越复杂，开始在构建脚本上花费的时间几乎与在实际代码上花费的时间一样多。随着越来越多的代码被层层叠加，调试shell脚本是非常痛苦的。
- 为了确保您不会意外地依赖陈旧的库，您可以在每次运行构建脚本时按顺序构建每个依赖项。这太慢了。您考虑添加一些逻辑来检测需要重建的部分，但这听起来非常复杂，并且脚本容易出错。或者你考虑指定每次哪些部分需要重建，然后你又回到原点。
- 好消息：是时候发布了！最好找出所有需要传递给 jar 命令以完成最终构建的参数。记住如何上传它，并将其推送到中央存储库。构建和推送文档更新，并向用户发送通知。嗯，也许这需要另一个脚本...
- 糟糕！您的硬盘驱动器崩溃了，现在您需要重新创建整个系统。您足够聪明，可以将所有源文件保存在版本控制中，但是您下载的那些库呢？你能再次找到它们并确保它们与你第一次下载它们时的版本相同吗？您的脚本可能依赖于在特定位置安装的特定工具——您能够恢复相同的环境以便脚本能够再次工作吗？很久以前为了让编译器正常工作而设置的环境变量又忘记了怎么办呢？
- 尽管存在这些问题，但是你的项目已经足够成功，你可以开始雇佣更多的工程师。现在您意识到，以前的问题不会造成灾难——每当新开发人员加入您的团队时，您都需要经历同样痛苦的引导过程。尽管您已尽力而为，但每个人的系统仍然存在细微的差异。通常，在一个人的机器上工作的东西在另一个人的机器上不工作，并且每次都要花费几个小时的调试工具路径或库版本来找出差异所在。
- 您决定需要自动化构建系统。理论上，这很简单，只需获得一台新计算机，并使用 cron 将其设置为每天晚上运行构建脚本。你仍然需要经历痛苦的设置过程，但是现在你没有人类大脑能够检测和解决小问题的好处。现在，每天早上，当您进入时，您都会看到昨晚的构建失败了，因为昨天开发人员进行了可在其系统上使用但未在自动构建系统上运行的更改。每次都是简单的修复，但这种情况经常发生，以至于你每天都要花很多时间去发现和应用这些简单的修复。
- 随着项目的增长，构建会变得越来越慢。有一天，在等待构建完成的同时，您悲哀地注视着正在休假的同事的闲置桌面，并希望有办法利用所有浪费的计算能力。

你遇到了一个经典的规模问题。对于一个开发人员来说，最多花一两周时间编写几百行代码(这可能是刚从大学毕业的初级开发人员迄今为止的全部经验) ，一个编译器就足够了。脚本可能会使您更进一步。但是，一旦您需要跨多个开发人员和他们的机器进行协调，即使是一个完美的构建脚本也是不够的，因为要考虑到这些机器之间的细微差别会变得非常困难。至此，这种简单的方法崩溃了，该是时候投资一个真正的构建系统了。

#### 现代构建系统

幸运的是，现有通用构建系统已经解决了许多我们开始遇到的所有问题。从根本上说，它们与我们之前提到的基于脚本的 DIY 方法没有什么不同: 它们运行相同的编译器，而且您需要理解这些底层工具，以便能够知道构建系统到底在做什么。但是这些现有的系统已经经过了多年的开发，使得它们比您可能尝试自己编写的脚本更加健壮和灵活。

#### 关键在于依赖

在回顾前面提到的问题时，有一个主题反复出现:管理您自己的代码非常简单，但是管理其依赖关系要困难得多（第21章专门介绍此问题）。有各种各样的依赖关系: 有时依赖于一个任务(例如，“在我将一个发布标记为完成之前推动文档”)，有时依赖于一个工件(例如，“我需要计算机视觉库的最新版本来构建我的代码”)。有时，您对代码库的另一部分有内部依赖，有时您对另一个团队(无论是在您的组织中还是第三方)拥有的代码或数据有外部依赖。但是，在任何情况下，“我需要那个，然后我才能拥有这个”的想法在构建系统的设计中反复出现，并且管理依赖性可能是构建系统最基本的工作。

#### 基于任务的构建系统

我们在上一节中开始开发的 shell 脚本是基于任务的基本构建系统的一个示例。在基于任务的构建系统中，基本的工作单元是任务。每个任务都是某种类型的脚本，可以执行任何类型的逻辑，任务将其他任务指定为必须在其之前运行的依赖项。目前使用的大多数主要构建系统，如 Ant、 Maven、 Gradle、 Grunt 和 Rake，都是基于任务的。

大多数现代构建系统都要求工程师创建描述如何执行构建的构建文件，而不是 shell 脚本。以 Ant 手册中的这个例子为例:
```xml 
<project name="MyProject" default="dist" basedir=".">
    <description>
        simple example build file
    </description>
<!-- set global properties for this build -->
<property name="src" location="src"/>
<property name="build" location="build"/>
<property name="dist" location="dist"/>

<target name="init">
    <!-- Create the time stamp -->
    <tstamp/>
    <!-- Create the build directory structure used by compile -->
<mkdir dir="${build}"/>
</target>

<target name="compile" depends="init" description="compile the source">
    <!-- Compile the Java code from ${src} into ${build} -->
    <javac srcdir="${src}" destdir="${build}"/>
</target>

<target name="dist" depends="compile" description="generate the distribution">
    <!-- Create the distribution directory -->
    <mkdir dir="${dist}/lib"/>

    <!-- Put everything in ${build} into the MyProject-${DSTAMP}.jar file -->
    <jar jarfile="${dist}/lib/MyProject-${DSTAMP}.jar" basedir="${build}"/>
</target>

<target name="clean" description="clean up">
    <!-- Delete the ${build} and ${dist} directory trees -->
    <delete dir="${build}"/>
    <delete dir="${dist}"/>
    </target>
</project>
```

构建文件是用 XML 编写的，它定义了一些关于构建的简单元数据以及一个任务列表(XML中的<target>标记)。每个任务执行由 Ant 定义的可能命令列表，其中包括创建和删除目录、运行 javac 和创建 JAR 文件。用户提供的插件可以对这组命令进行扩展，以涵盖任何类型的逻辑。每个任务还可以通过依赖属性定义它所依赖的任务。这些依赖关系形成了一个非循环图(参见图18-1)。

![显示依赖关系的非循环图](/image/part-1/figure18-1.png)
图18-1 显示依赖关系的非循环图

用户通过向 Ant 的命令行工具提供任务来执行构建。例如，当用户输入 Ant dist 时，Ant 会执行以下步骤:

1. 在工作目录中加载一个名为 build.xml 的文件，并解析它来创建/n图18-1所示的图形结构。
2. 查找命令行上提供的名为dist的任务，并发现该任务与名为compile的任务有关。
3. 查找名为compile的任务，并发现它对名为init的任务具有依赖性。
4. 查找名为init的任务，并发现它没有依赖项。
5. 执行init任务中定义的命令。
6. 假设所有任务的依赖项都已运行，则执行在编译任务中定义的命令。
7. 假设所有任务的依赖项都已运行，则执行dist任务中定义的命令。

最后，Ant在运行dist任务时执行的代码等效于以下shell脚本：
```shell
./createTimestamp.sh
mkdir build/
javac src/* -d build/
mkdir -p dist/lib/
jar cf dist/lib/MyProject-$(date --iso-8601).jar build/*
```

当语法被剥离时，构建文件和构建脚本实际上并没有太大的不同。但是通过这样做我们已经获得了很多好处。 我们可以在其他目录中创建新的构建文件并将它们链接在一起。我们可以很容易地以任意和复杂的方式添加依赖于现有任务的新任务。我们只需要将单个任务的名称传递给 ant 命令行工具，它将负责确定需要运行的所有内容。

Ant 是一个非常古老的软件，最初发布于2000年——不是今天许多人认为的“现代”构建系统！在过去的几年中，其他工具（例如Maven和Gradle）在Ant上进行了改进，并通过添加诸如自动管理外部依赖项和更简洁的语法（无需任何XML）之类的功能实质上替代了它。但是这些新系统的本质是一样的: 它们允许工程师以一种有原则的、模块化的方式编写构建脚本作为任务，并为执行这些任务和管理它们之间的依赖关系提供工具。

#### 基于任务的构建系统的缺点

因为这些工具本质上允许工程师将任何脚本定义为一项任务，它们非常强大，允许您用它们做几乎任何您能想象到的事情。但是这种能力也有缺点，随着构建脚本变得越来越复杂，基于任务的构建系统可能变得难以使用。这种系统的问题在于，它们实际上给工程师提供了太多的权力，而给系统提供的权力却不够。因为系统不知道脚本在做什么，所以性能会受到影响，因为它必须非常保守地安排和执行构建步骤。而且系统没有办法确认每个脚本正在做它应该做的事情，所以脚本往往会变得越来越复杂，最终成为另一件需要调试的事情。

#### 难以并行化构建步骤

现代开发工作站通常非常强大，具有多个核心，理论上应该能够并行执行多个构建步骤。但是基于任务的系统通常无法并行执行任务，即使看起来他们应该能够这样做。假设任务A依赖于任务B和C。因为任务B和任务C之间没有依赖关系，同时运行它们是否安全，以便系统能够更快地到达任务A？也许吧，如果他们不碰任何相同的资源。但也许不是——也许两者都使用同一个文件来跟踪他们的状态，同时运行这些状态会导致冲突。一般情况下，系统是不可能知道的，因此要么必须承担这些冲突的风险(导致罕见但非常难以调试的构建问题) ，要么必须将整个构建限制在单个进程中的单个线程上运行。这对于功能强大的开发机器来说是一种巨大的浪费，而且它完全排除了在多台机器之间分发构建的可能性。

#### 执行增量构建的困难

一个好的构建系统将允许工程师执行可靠的增量构建，这样一个小的更改不需要从头开始重建整个代码库。如果构建系统运行缓慢，并且由于上述原因无法将构建步骤并行化，那么这一点尤为重要。但不幸的是，基于任务的构建系统在这方面也很困难。因为任务可以做任何事情，所以通常没有办法检查它们是否已经完成。许多任务只是获取一组源文件并运行编译器来创建一组二进制文件;因此，如果底层源文件没有更改，它们就不需要重新运行。但是，如果没有额外的信息，系统就不能肯定地这么说——也许任务会下载一个可能已经更改的文件，或者它所写的时间戳在每次运行时可能不同。为了保证正确性，系统通常必须在每次构建期间重新运行每个任务。

有些构建系统尝试通过让工程师指定需要重新运行任务的条件来启用增量构建。有时这是可行的，但通常这是一个比看起来更棘手的问题。例如，在像C++这样允许文件被其他文件直接包含的语言中，如果不解析输入源，就不可能确定需要监视的整个文件集。工程师通常会最终选择捷径，而这些捷径会导致罕见而令人沮丧的问题，即使任务结果不应该重复使用，任务结果也会被重复使用。当这种情况频繁发生时，工程师就会养成习惯，在每次构建之前运行干净的代码，以获得一个新的状态，这完全违背了增量的目的，一开始就是建造。弄清楚一个任务何时需要重新运行是很困难的，比起人类，机器更适合处理这种工作。

#### 难以维护和调试脚本。

最后，基于任务的构建系统强加的构建脚本通常很难处理。尽管构建脚本经常受到较少的审查，但它们就像正在构建的系统一样是代码，也是 bug 容易隐藏的地方。下面是一些在使用基于任务的构建系统时常见的bug的例子:
- 任务A依赖任务B生成特定的文件作为输出。任务B的所有者没有意识到其他任务依赖于它，因此他们将任务B改为在不同的位置生成输出。在有人尝试运行任务A并发现任务A失败之前，无法检测到此问题。
- 任务A依赖于任务B，而任务B依赖于任务C，任务C正在生成特定文件作为任务A所需的输出。任务B的所有者决定不再需要依赖任务C，即使任务B根本不关心任务C，这也会导致任务A失败！
- 新任务的开发人员意外地对运行任务的机器做出假设，例如工具的位置或特定环境变量的值。这个任务在他们的机器上可以运行，但是每当其他开发人员尝试时就会失败。
- 任务包含不确定性组件，例如从Internet下载文件或向构建添加时间戳。现在，人们每次运行构建都将获得不同的结果，这意味着工程师将永远无法重现并修复彼此的故障或自动构建系统中发生的故障。
- 具有多个依赖项的任务可以创建竞争条件。如果任务A同时依赖于任务B和任务C，并且任务B和C都修改了同一文件，则任务A将获得不同的结果，具体取决于任务B和C中的哪一个先完成。

在这里提出的基于任务的框架中，没有通用的方法来解决这些性能、正确性或维护能力问题。只要工程师可以编写在构建过程中运行的任意代码，系统就不会拥有足够的信息来始终能够快速正确地运行构建。为了解决这个问题，我们需要从工程师手中拿走一些权力，把它放回到系统的手中，并且重新定义系统的角色，不是作为运行任务，而是作为产品。这是Google对Blaze和Bazel采取的方法，下一部分将对此进行介绍。