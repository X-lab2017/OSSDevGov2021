## 第十章
# 文档

*作者 汤姆·曼施莱克* 

*编辑 里奥娜·麦克纳马拉*

在大多数工程师对编写、使用和维护代码的抱怨中，一个常见的问题是缺乏高质量的文档。“这种方法的副作用是什么？”“我在第三步之后出现了一个错误。”“这个缩写是什么意思?”“这份文件是最新的吗?”每个软件工程师在他们的职业生涯中都抱怨过文档的质量、数量或缺乏文档，谷歌的软件工程师也不例外。

技术文档撰写人和项目经理可能会提供帮助，但软件工程师总是需要自己编写大部分文档。因此，工程师需要适当的工具和奖励措施来有效地做到这一点。介绍操作和工具是使他们更容易编写高质量文档的关键，这些操作和工具可以随组织扩展，并与他们现有的工作流相结合。

总的来说，2010年代后期的工程文档状态和1980年代后期的软件测试状态类似。每个人都认识到需要更多的努力来改进它，但组织还没有认识到它的关键好处。这种情况正在改变，尽管速度很慢。在谷歌，我们最成功的工作是将文档视为代码，并整合到传统的工程工作流中，使工程师更容易编写和维护简单的文档。


## 文档的定义是什么?
当我们提到“文档”时，我们谈论的是工程师为完成他们的工作而需要编写的每一份补充文本:不仅是独立的文档，还有代码注释。(事实上，谷歌工程师会以代码注释的方式书写大部分的文档)我们将在本章中进一步讨论各种类型的工程文档。

## 为什么需要文档?
有质量的文档对于工程组织来说有巨大的好处。代码和api变得更容易理解，甚至减少了错误。当项目团队的设计目标和团队目标被清楚地表述时，他们会更加集中。如果对步骤进行了清晰的概述，人工处理就更容易执行。如果流程有清晰的文档记录，那么新成员进入团队或代码库就会花费更少的精力。

但是由于文档的好处都是处于下游的，所以它们通常不会给作者带来直接的好处。测试(正如我们将看到的)可以很快地为程序员提供好处，而文档通常需要提前付出更多的努力，直到后来才会为作者提供明确的好处。但是，就像在测试方面的投资一样，在文档方面的投资将会随着时间的推移而得到回报。毕竟，你可能只编写了一次文档，但之后它将被读取数百次，甚至数千次；它的初始成本摊销到所有未来的读者上。文档不仅会随着时间的推移而扩展，而且它对组织的其他部分的扩展也很关键。它可以很好的回答以下问题:

- 为什么要做出这些设计决定?

- 为什么我们要以这种方式实现这段代码?

- 如果你两年后再看自己的代码，为什么我要以这种方式实现这段代码？

如果文档准确传达了这些好处，为什么工程师通常认为它“很差”?正如我们上文所提到的，其中一个原因是这些好处不是立竿见影的，尤其是对作者而言。但还有其他几个原因:

- 工程师通常把写作视为一种独立的技能，而不是编程。(我们将试图说明情况并非如此，即使是这样，它也不一定是一项与软件工程技能相分离的技能)

- 一些工程师不觉得自己是有能力的作家。但是你不需要非常熟练地掌握英语来生成可操作的文档。你只需要稍微走出自己的角度，从观众的角度来看问题。

- 很少的工具支持或集成到开发人员的工作流程中，这使得编写文档更加困难。

- 文档被视为一种额外的负担——需要维护的东西，而不是使现有代码维护更容易的东西。

并不是每个工程团队都需要技术文档撰写者(即使是这样，他们也不够多)。这意味着工程师们将会自己编写大部分的文档。因此，我们不应该强迫工程师成为技术文档撰写者，而是应该考虑如何让工程师更容易地编写文档。决定在文档上投入多少精力是你的组织在某些时候需要做出的决定。

文档化有利于几个不同的组之间的协作，即使对作者来说，文档化也提供了以下好处:

- 它有助于制定API。编写文档是确定API是否有意义的最可靠方法之一。通常，文档的编写本身会导致工程师重新评估设计的决策，从而使它不会受到质疑。如果你不能解释它，也不能定义它，那你可能设计得还不够好。

- 提供维护路线图和历史记录。在任何情况下，代码中的技巧都应该避免，但是当你盯着两年前编写的代码，试图找出错误所在时，好的注释会帮上很大的忙。

- 它使你的代码看起来更专业，并推动流量。开发人员会很自然地认为文档化良好的API就是设计得更好的API。情况并非总是如此，但它们通常是高度相关的。虽然这个好处听起来只是表面文章，但实际上并非如此:一个产品是否拥有良好的文档，通常是一个非常好的指标，表明该产品将被维护得有多好。

- 它将从其他用户那里获得更少问题的反馈。随着时间的推移，这可能是编写文档的人最大的好处。如果你必须向某人多次解释某件事，那么记录这个过程通常是有意义的。

这些好处对于文档的作者来说是巨大的，文档的大部分好处自然会留给读者。谷歌的C++风格指南强调了“为读者优化”的原则。这一准则不仅适用于代码，也适用于代码周围的注释，或者附加到API的文档集。与测试非常相似，编写好的文档将在其生命周期中获得很多好处。随着时间的推移，文档是至关重要的，并且随着组织规模的扩大，对于特别关键的代码会获得巨大的好处。

## 文档就像代码

用一种单一的、主要的编程语言编写的软件工程师仍然经常使用不同的语言来解决特定的问题。工程师可能会编写shell脚本或Python脚本来运行命令行任务，或者他们可能会用C++编写大部分后端代码，但用Java编写一些中间件代码等。每种语言都是工具箱中的工具。

文档也是一样的:它是用不同的语言(通常是英语)编写的工具，用于完成特定的任务。编写文档与编写代码没有太大区别。像编程语言一样，它也有规则、特定的语法和样式决定，通常是为了实现与代码中类似的目的:加强一致性、提高清晰度和避免(理解)错误。在技术文档中，语法很重要，不是因为需要规则，而是为了规范，避免混淆或分散读者的注意力。出于这个原因，谷歌要求它的许多语言都有特定的注释样式。

像代码一样，文档也应该有所有者。没有所有者的文档会变得陈旧并且难以维护。清晰的所有权也使得通过现有的开发人员工作流(bug跟踪系统、代码审查工具等等)来处理文档变得更加容易。当然，不同所有者的文档仍然可能相互冲突。在这些情况下，重要的是指定规范文档:确定主源并将其他相关文档合并到该主源中(或弃用重复文档)。

谷歌上“go/links”(见第3章)的普遍使用使这个过程更容易。带有直接go/links的文档常常成为权威的真理来源。促进规范文档的另一种方法是将它们直接与它们所记录的代码关联起来，方法是将它们直接置于源代码控制之下，并与源代码本身一起。

文档通常与代码紧密耦合，因此应该尽可能地将其视为代码。也就是说，你的文档应该:

- 必须遵守公司内部的政策或规定

- 置于源代码控制之下

- 对文件的维护有明确的所有权

- 对变更(以及代码文档的变更)进行审查

- 跟踪问题，因为bug是在代码中跟踪的

- 定期评估(在某些方面是测试)

- 如果可能的话，对准确性、新鲜度等方面进行测量(工具还没有跟上)

越多的工程师将文档作为软件开发的必要任务之一，他们就会越少的怨恨编写的前期成本，并且他们将获得更多的长期利益。此外，简化文档工作可以降低前期成本。

## 案例研究:谷歌Wiki

当谷歌规模小、精简的时候，它几乎没有技术文档撰写者。分享信息最简单的方式是通过我们自己的内部wiki (GooWiki)。起初，这似乎是一个合理的方法；所有工程师共享一个单一的文档集，并可以根据需要更新它。

但随着谷歌规模的扩大，维基式方法的问题变得明显起来。由于文件没有真正的主人，许多文件都过时了。由于没有设置添加新文档的流程，重复的文档和文档集开始出现。GooWiki有一个扁平的名称空间，人们不擅长将任何层次结构应用到文档集。曾经有一段时间，有7到10个关于设置Borg(我们的生产计算环境)的文档(取决于你如何计算它们)，只有少数文档被维护，而且大多数都是特定于具有特定权限和假设的特定团队。

随着时间的推移，GooWiki的另一个问题变得越来越明显：能够修复文档的人并不是使用它们的人。发现错误文档的新用户要么无法确认文档是错误的，要么没有简单的方法报告错误。他们知道有些地方出了问题(因为文档不再有效)，但是他们不能“修复”它。相反地，能够最好地修改文档的人在文档编写完成后通常不需要查阅它们。随着谷歌的发展，文档变得如此糟糕，以至于在我们的年度开发者调查中，文档质量成为谷歌对开发者的头号抱怨。

改善这种情况的方法是将重要的文档移到用于跟踪代码更改的源代码控制中。文档开始有了自己的所有者，在源代码树中的规范位置，以及识别bug和修复bug的流程；文档开始显著改善。此外，编写和维护文档的方式开始与编写和维护代码的方式相同。文档中的错误可以在我们的错误跟踪软件中报告。对文档的更改可以使用现有的代码评审过程来处理。最终，工程师们开始自己修复文档，或者将更改发送给作者(他们通常是文档的所有者)。

将文档转移到源代码控制最初遇到了很多争议。许多工程师都认为，放弃GooWiki这个信息自由的堡垒，会导致质量低下，因为文档的门槛会更高(需要审查，要求文档所有者等等)。但事实并非如此。文档变得更好了。

Markdown作为一种通用文档格式化语言的引入也很有帮助，因为它使工程师更容易理解如何编辑文档，而不需要HTML或CSS方面的专门知识。谷歌最终引入了自己的框架，用于在代码中嵌入文档:g3doc。有了这个框架，文档得到了进一步的改进，因为在工程师的开发环境中，文档与源代码同时存在。现在，工程师可以在相同的变更中更新代码及其相关文档(我们仍在尝试改进这种做法)。

关键的区别是，维护文档变成了维护代码的类似体验:工程师归档错误，在变更列表中更改文档，将更改发送给专家评审等。利用现有的开发人员工作流，而不是创建新的工作流，是一个关键的好处。

## 了解你的听众

在编写文档时，工程师所犯的一个最重要的错误是只为自己编写文档。这样做是很自然的，而且为自己编写代码也不是没有价值的:毕竟，几年后你可能需要查看这些代码，并尝试弄清你曾经的意思。你也可能与阅读你的文档的人拥有大致相同的技能。但是，如果你只为自己编写，那么你将做出某些假设，并且考虑到你文档可能会被非常广泛的读者(所有工程人员、外部开发人员)阅读，即使是少数读者丢失也会带来很大的成本。随着组织的发展，文档中的错误会变得更加突出，而你的假设通常并不适用。

相反，在你开始写作之前，你应该(正式或非正式地)确定你的文件需要满足的读者。设计文件可能需要说服决策者。教程可能需要向完全不熟悉你的代码库的人提供非常明确的说明。API可能需要为该API的任何用户提供完整和准确的参考信息，无论他们是专家还是新手。始终要努力确定一个主要受众，并向这个受众写信。

好的文档不需要打磨或“完美”。工程师在编写文档时犯的一个错误是，他们认为自己需要成为更好的作者。按照这个标准，很少有软件工程师会去写。你可以像对待测试或其他任何你作为工程师需要做的过程一样思考写作。写信给你的听众，用他们期待的声音和风格。如果你能读，你就能写。记住，你的听众站在你曾经站过的地方，但没有你新的领域知识。所以你不需要成为一个伟大的作家；你只需要找一个像你一样熟悉这个领域的人。(只要你持有股份，你就可以随着时间的推移改进这份文件。)

## 受众类型

我们已经指出，你应该按照适合你的读者的技能水平和领域知识来编写。但你的读者到底是谁呢?根据以下一个或多个标准，你可能拥有多个受众:

- 经验水平(专业程序员或初级工程师甚至可能不熟悉这门语言)。

- 领域知识(团队成员，或组织中只熟悉API的其他工程师)。

- 目的(可能需要你的API来完成特定任务并需要快速找到信息的最终用户，或者负责你希望其他人都不需要维护的复杂实现的核心部分的软件专家)。

在某些情况下，不同的读者需要不同的写作风格，但在大多数情况下，技巧是用一种尽可能广泛适用于不同读者群体的方式来写作。通常，你需要向专家和新手解释一个复杂的话题。为拥有领域知识的专家写作可能会让你走捷径，但你会让新手感到困惑；相反地，向新手详细解释每件事无疑会惹恼专家。

显然，编写这样的文档是一种平衡的行为，没有什么灵丹妙药，但我们发现，它有助于保持文档简短。用描述性的文字向不熟悉的人解释复杂的主题，但不要失去或惹恼专家。写一个简短的文档通常需要你写一个较长的文档(记下所有的信息)，然后进行编辑，尽可能删除重复的信息。这听起来可能很乏味，但是请记住，这个费用是由文档的所有读者分摊的。正如Blaise Pascal曾经说过的:“如果我有更多的时间，我会给你写一封更短的信。”通过保持文档的简短和清晰，你将确保它既能满足专家，也能满足新手。

另一个重要的用户区别是基于用户如何接触文档:

- 探索者是工程师，他们知道他们想要什么，想知道他们正在寻找的东西是否符合要求。对这些听众来说，一个关键的教学手段是一致性。如果您正在为这个组编写参考文档——例如，在一个代码文件中——您将希望您的注释遵循类似的格式，这样读者就可以快速浏览参考文档，看看他们是否找到了他们想要的东西。

- 犯错误的人可能不知道自己到底想要什么。他们可能对如何实现他们正在使用的东西只有一个模糊的概念。对这些听众来说，关键是清晰。提供概述或介绍(例如，在文件的顶部)，解释他们正在查看的代码的目的。识别文档何时不适合观众也是很有用的。谷歌上的很多文档都以“TL;DR语句”开头，比如“TL;DR:如果你对谷歌上的C++编译器不感兴趣，你可以停止阅读了。”

最后，一个重要的受众区别是客户(例如，API的用户)和提供者(例如，项目团队的成员)之间的区别。为其中一方准备的文件应尽可能地与为另一方准备的文件分开。实现细节对于团队成员来说是很重要的；终端用户不需要阅读这些信息。通常，工程师会在他们发布的库的参考API中表示设计决策。这样的推理更适合出现在特定的文档(设计文档)中，或者最好是隐藏在接口后面的代码实现细节中。

## 文档格式

工程师编写各种不同类型的文档作为他们工作的一部分:设计文档、代码注释、操作文档、项目页面等等。这些都可以算作“文档”。但重要的是要了解不同的类型，并进行区分。一般来说，一个文件应该只有一个目的，并坚持这个目的。就像API应该只做一件事，并把它做好。避免尝试在一个文档中做几件事。此外，你应该更有逻辑地拆分这些部分。软件工程师经常需要编写的文档主要有以下几种:

- 参考文档，包括代码注释

- 设计文档

- 教程

- 概念性文档

- 登陆页面

在谷歌的早期阶段，团队通常会拥有包含大量链接(许多已经破损或过时)、关于系统如何工作的概念信息、API参考等等的整体wiki页面。这样的文件之所以失败，是因为它们没有单一的目的(而且它们的篇幅太长，没有人会读它们;一些臭名昭著的维基页面过于长篇冗余)。因此，要确保您的文档具有单一的目的，如果向该页面添加内容是没有意义的，您可能需要寻找甚至创建另一个文档来实现。


### 参考文档

参考文档是工程师需要编写的最常见的文档类型;事实上，他们经常需要每天写一些参考文档。所谓参考文档，我们指的是在代码库中记录代码使用的任何东西。代码注释是工程师必须维护的最常见的参考文档形式。这种注释可以分为两个基本阵营:API注释和实现注释。请记住这两者之间的受众差异:API注释不需要讨论实现细节或设计决策，不需要用户和作者一样精通API。另一方面，实现注释可以假定读者有更多的领域知识，但这种假定要适当。抛开项目，有时更安全的方法是系统地说明为什么要这样编写代码。

大多数参考文档，即使作为独立于代码的文档提供，也是从代码库本身的注释中生成的，就像参考文档应该尽可能单一来源一样。一些语言，如Java或Python，有特定的注释框架(Javadoc, PyDoc, GoDoc)，旨在使参考文档的生成更容易。其他的局域网语言，如c++，没有标准的“参考文档”实现，因为c++将它的API接口(在头文件或.h文件中)与实现(.cc文件)分开，头文件通常是一个很自然的地方来记录一个c++ API。

谷歌采用了这种方法:一个c++ API应该在头文件中有它的参考文档。其他参考文档也直接嵌入到Java、Python和Go源代码中。因为谷歌的代码搜索浏览器(见第17章)十分健壮，我们发现提供单独的生成参考文档并没有什么好处。代码搜索的用户不仅可以轻松地搜索代码，他们通常可以在顶部的结果中找到代码的原始定义。在代码定义旁边加上说明文档也使文档更容易发现和维护。

我们都知道代码注释对于一个良好文档化的API是必不可少的。但什么才是“好”评论呢?在本章的早些时候，我们为参考文档确定了两个主要的系统:搜索器和阻扰器。搜索器知道他们想要什么;而阻扰器知道不要什么。对于搜索器来说，关键是得到一个一致的注释代码库，这样他们就可以快速扫描一个API并找到他们想要的东西。对于阻扰器来说，关键在于清楚地确定API的用途，通常是在文件头的顶部。我们将在接下来的小节中介绍一些代码注释。下面的代码注释指导原则适用于c++，但是类似的规则也适用于其他语言的谷歌。



### 文档注释

谷歌中几乎所有代码文件都必须包含文件注释。(有些头文件只包含一个实用函数等，可能会偏离这个标准。)文件注释应该以下列形式开头:

```
// -----------------------------------------------------------------------------

// str_cat.h 

// ----------------------------------------------------------------------------- 

// 

// This header file contains functions for efficiently concatenating and appending 

// strings: StrCat() and StrAppend(). Most of the work within these routines is 

// actually handled through use of a special AlphaNum type, which was designed 

// to be used as a parameter type that efficiently manages conversion to

 // strings and avoids copies in the above operations.

… 
```

通常，文件注释应该以您正在阅读的代码中包含的内容的大纲开始。它应该识别代码的主要用例和意图(在前面的例子中，开发者想要连接字符串)。任何不能在第一段或第二段中简洁描述的API，通常表明该API没有经过深思熟虑。在这些情况下，可以考虑将API分解成独立的组件。



### 类注释

大多数现代编程语言都是面向对象的。类注释对于定义代码库中使用的API“对象”非常重要。谷歌的所有公共类(和结构)必须包含一个类注释，描述类/结构、该类的重要方法和该类的用途。一般来说，类评论应该用强调其对象方面的文档“命名”。也就是说，“Foo类包含x、y、z，允许您执行Bar，并具有以下Baz方面”等等。

类注释通常应该以以下形式的注释开始:
```
// ----------------------------------------------------------------------------- 

// AlphaNum

// ----------------------------------------------------------------------------- 

// 

// The AlphaNum class acts as the main parameter type for StrCat() and 

// StrAppend(), providing efficient conversion of numeric, boolean, and 

// hexadecimal values (through the Hex type) into strings.
```

### 函数注释

在谷歌，所有的自由函数或类的公共方法也必须包含一个函数注释来描述函数的功能。函数注释应该强调其使用的有效性质，以陈述性动词开头，描述函数做什么以及返回什么。

函数注释通常应该以以下形式的注释开始:

```
// StrCat() 

// 

// Merges the given strings or numbers, using no delimiter(s),

// returning the merged result as a string. 

… 
```

注意，用声明性动词开始函数注释会在使整个头文件中一致性较强。阅读者可以通过快速扫描API，且只需要查看动词，就可以了解该函数是否合适“合并、删除、创建”等等。

一些文档样式(和一些文档生成器)需要各种形式的函数注释模板，如" Returns: "， " Throws: "，等等，但在谷歌中，我们发现它们并不是必要的。用一些散列的评论来表达这些信息通常会更清晰，而不是人为僵硬的定义分界点:

```
// Creates a new record for a customer with the given name and address,

// and returns the record ID, or throws `DuplicateEntryError` if a

// record with that name already exists. 
```

int AddCustomer(string name, string address);

注意后置条件、参数、返回值和异常情况是如何自然地一起记录的(在本例中，在一个句子中)，因为它们不是相互独立的。添加显式的样板会使注释更加冗长和重复，但不会更加清晰，甚至可能会更不清晰。



### 教程

每个软件工程师，当他们加入一个新的团队时，都会想要尽快跟上进度。拥有一份指导创建新项目的教程是非常有价值的；此外，“Hello World”已经拥有了自己的地位，这是确保所有团队成员都能以正确的方式开始的最好方法之一。这适用于文档和代码。大多数项目都应该有一个“Hello World”文档，它不需要任何假设，让工程师“真实”地完成一些事情。

通常情况下，编写教程(如果还不存在教程)的最佳时机是当你刚加入一个团队时，这也是在现有教程中寻找漏洞的最佳时机。你可以用用记事本或其他方法做笔记，假设没有领域知识或特殊设置限制，记录下在项目中需要做的所有事情；完成之后，你可能会知道自己在这个过程中犯了什么错误以及为什么犯错，然后可以进一步编辑你的步骤，得到一个更精简的教程。重要的是，写下需要做的所有事情；尽量不要假定任何特定的设置、权限或领域知识。如果您确实需要进行其他设置，请在本教程的开头清楚地说明这一点，作为先决条件。

大多数教程要求您按顺序执行许多步骤。在这些情况下，明确地为这些步骤编号。如果教程的重点是用户(比如外部开发者文档)，那么给用户需要采取的每个行动编号。不要对系统响应这些用户操作可能采取的操作进行编号。在执行此操作时，明确地为每一步编号是至关重要的。没有什么比第4步出错更烦人的了，比如，你忘记告诉别人授权他们的用户名。

例子:糟糕的教程

1. 从我们的服务器http://example.com下载该包

2. 将shell脚本复制到您的主目录

3. 执行shell脚本

4. foobar系统将与认证系统通信

5. 一旦验证，foobar将引导一个名为“baz”的新数据库

6. 通过在命令行上执行SQL命令来测试“baz”

7. 类型:CREATE DATABASE my_foobar_db;

在上述步骤中，步骤4和步骤5发生在服务器端。目前还不清楚用户是否需要做什么，但他们不需要，所以这些副作用可以作为步骤3的一部分。同样，也不清楚第6步和第7步是否不同。(他们不是。)将所有原子用户操作合并为单个步骤，以便用户知道他们需要在流程的每个步骤中执行一些操作。此外，如果你的教程有用户可见的输入或输出，需要在单独的行上表示(通常使用等宽粗体字体)。

例子：优化一个糟糕的例子

1. 从我们的服务器http://example.com:下载该包

   $ curl -I http://example.com

2. 将shell脚本复制到你的主目录：

   $ cp foobar.sh ~

3. 在主目录下执行shell脚本:	

   $ cd ~;foobar系统将首先与身份验证系统通信。一旦验证，foobar将引导一个名为“baz”的新数据库，并打开一个输入shell。

4. 在命令行上执行SQL命令来测试“baz”:

   $ CREATE DATABASE my_foobar_db; 

注意每个步骤都需要特定的用户干预。如果教程侧重于其他方面(例如，关于“服务器生命周期”的文档)，那么就应该从该重点的角度(服务器做什么)为这些步骤编号。



### 概念性文档

阅读有些代码需要比阅读参考文档有更深入的解释或见解。在这种情况下，我们需要概念文档来提供api或系统的概述。概念文档化的一些例子可能是一个流行API的库概述，一个描述服务器内数据生命周期的文档等等。几乎所有的情况下，一个概念性的文档都是用来增加，而不是取代一个参考文档集的。这常常导致某些资料的重复，但目的是：促进澄清。在这些情况下，概念文档不需要涵盖所有边缘情况(尽管参考文献应该涵盖这些情况)。在这种情况下，为了清晰度牺牲一些准确性是可以接受的。概念文件的主要目的是传授理解。

概念文档是最难编写的文档形式。因此，在软件工程师的工具箱里，它们往往是最被忽视的文档类型。工程师在编写概念性文档时面临的一个问题是，它通常不能直接嵌入到源代码中，因为没有一个规范的位置来放置它。一些API有一个相对广泛的API表面积，在这种情况下，一个文件注释可能是一个合适的地方来对API进行“概念性”的解释。但通常，一个API与其他API和/或模块规则一起工作。记录这种复杂行为的唯一合乎逻辑的地方是通过一个单独的概念性文档。如果注释是文档的单元测试，那么概念文档就是集成测试。

即使API有适当的作用域，提供一个单独的概念性文档也是有意义的。例如，Abseil的StrFormat库涵盖了API的成熟用户应该理解的各种概念。在这些情况下，我们在内部和外部都提供格式概念文档。

概念文档需要对广泛的受众有用:无论是专家还是新手。此外，它需要强调清晰度，所以经常需要牺牲完整性(最好的参考)和有时严格的准确性。这并不是说一个概念性文件应该故意不准确;这只是意味着它应该集中在常见用法上，而把罕见的用法或副作用留给参考文档。



### 团队首页

大多数工程师是团队中的一员，并且大多数团队都有一个“团队页面”——在他们公司的内网。通常，这些网站有点混乱:一个典型的登录页面可能包含一些有趣的链接，有时几个标题为“先读这个!”，并为团队和客户提供一些信息。这些文件一开始很有用，但很快就变成了灾难;因为维护起来非常麻烦，它们最终会变得过时，只有勇敢或绝望的人才能修复它们。

幸运的是，这些文档看起来很吓人，但实际上很容易修复:确保登录页面清楚地表达其目的，然后只包含到其他页面的链接以获取更多信息。如果登陆页面上的某样东西做的不仅仅是警示，那它就没有做好它的工作。如果你有一个单独的设置文档，从登录页面作为一个单独的文档链接到它。如果登录页上有太多链接(您的页面不应该滚动多个屏幕)，考虑按分类将页面分成不同的部分。

大多数配置糟糕的登录页面都有两个不同的目的:它们是产品或API用户的“转到”页面，或者是团队的主页。不要让页面同时服务于两个主服务器——这会变得很混乱。创建一个独立的“团队页面”作为一个内部页面，除了主登陆页面。团队需要知道的通常与API的客户需要知道的是完全不同的。

## 文档评审

在谷歌，所有的代码都需要评审，我们的代码评审过程可以很好地理解和接受。一般来说，文档也需要审查(尽管这不是普遍接受的)。如果您想“测试”您的文档是否有效，您通常应该让其他人检查它。

一份技术文件得益于三种不同类型的审查，每一种都强调不同的方面:

- 技术审查，为了准确性。评审通常由主题专家完成，通常是团队的另一名成员。通常，这是代码审查本身的一部分。

- 观众评论，为了清晰。这通常是不熟悉该领域的人。这可能是您的团队的新成员或API的客户。

- 为了一致性，写一篇文章。这通常是一个技术作家或志愿者。

当然，这些界限有时是模糊的，但如果您的文档是高调的，或者最终可能对外发布，您可能希望它收到更多类型的评论。(我们在本书中使用了类似的评论过程。)任何文档都能从上述审查中受益，即使其中一些审查是临时的。也就是说，即使只有一个审稿人审阅你的文章，也比没有人审阅要好得多。

重要的是，如果文档与工程工作流程捆绑在一起，它通常会随着时间的推移而改进。谷歌的大多数文档现在都隐式地经过了用户审查，因为在某些时候，他们的用户会使用这些文档，并希望当它们不能工作时(通过bug或其他形式的反馈)让你知道。

### 案例研究:开发人员指南库

如前所述，将大多数(几乎所有)工程文档包含在共享的wiki中存在一些问题:对重要文档、竞争文档、过时信息的所有权很少，难以归档bug或文档问题。但是这个问题并没有出现在一些文档中:谷歌c++风格指南是由一群高级工程师(风格仲裁者)负责管理的。这份文件保存得很好，因为某些人关心它。他们含蓄地拥有该文件。该文档也是规范的:只有一个c++风格指南。

如前所述，直接位于源代码中的文档是促进规范文档建立的一种方法;如果文档与源代码放在一起，它通常应该是最适用的(希望如此)。在谷歌，每个API通常都有一个独立的g3doc目录，其中存放这些文档(以Markdown文件的形式编写，在我们的代码搜索浏览器中可读)。让文档与源代码一起存在不仅建立了事实上的所有权，还使文档看起来更像是代码的“一部分”。

然而，有些文档集不能很有逻辑地存在于源代码中。例如，针对谷歌人的“c++开发人员指南”在源代码中没有明显的位置。没有“c++”主目录供人们查找此类信息。在这种情况下(以及其他跨越API边界的情况)，在它们自己的仓库中创建独立的文档集变得很有用。其中许多将现有文档合并为一个公共集，具有公共导航和外观。这些文档被称为“开发人员指南”，就像代码库中的代码一样，在一个特定的文档库中进行源代码控制，该文档库是按照主题而不是API组织的。通常，技术编写人员管理这些开发人员指南，因为他们更善于跨API边界解释主题。

随着时间的推移，这些开发人员指南成为了规范。编写竞争性文档或补充文档的用户可以在规范化文档集建立后将其文档添加到规范化文档集，然后弃用竞争性文档。最终，c++风格指南成为更大的“c++开发人员指南”的一部分。随着文档集变得更加全面和权威，其质量也得到了提高。工程师们开始记录漏洞，因为他们知道有人在维护这些文件。因为文档是在源代码控制下锁定的，有了适当的所有者，工程师也开始直接向技术编写人员发送变更列表。

go/links的引入(见第3章)实际上使大多数文档更容易在任何给定的主题上建立自己的规范。例如，我们的c++开发人员指南在“go/cpp”建立。随着更好的内部搜索、go/链接以及将多个文档集成到公共文档集中，这样的规范文档集随着时间的推移变得更加权威和健壮。

## 文档哲学

注意:以下部分更多的是关于技术写作最佳实践(和个人观点)的论述，而不是关于“谷歌是如何做到的”。尽管理解这些概念可能会让您更容易地编写技术信息，但是软件工程师可以选择完全掌握这些概念。

## 谁，什么，何时，何地，为什么

大多数技术文档都回答了“如何”的问题。这是如何工作的呢?我如何编写这个API?如何设置此服务器?因此，软件工程师倾向于直接进入任何给定文档的“如何”，而忽略与之相关的其他问题:WHO、WHAT、WHEN、WHERE和WHY。的确，这些内容中没有一个比how更重要，但设计文件是个例外，因为与之相对应的方面通常是why，但如果没有适当的技术文件框架，文档最终就会令人困惑。尽量在任何文件的前两段解决其他问题:

- 世卫组织以前讨论过:这是听众。但有时您还需要在文档中明确地调用和处理听众。例如:“这个文档是给Secret Wizard项目的新工程师的。”

- WHAT确定本文档的目的:“本文档是一个教程，旨在启动一个Frobber服务器在一个测试环境。”有时候，仅仅写“WHAT”就能帮助你恰当地构建文档。如果开始添加不适用于WHAT的信息，则可能希望将该信息移动到单独的文档中。

- WHEN标识何时创建、审查或更新此文档。源代码中的文档会隐式地标注这个日期，其他一些发布方案也会自动标注这个日期。但是，如果没有，一定要在文件本身上注明文件书写(或最后修改)的日期。

- WHERE通常也是隐含的，但要决定文件应该放在哪里。通常情况下，首选项应该处于某种版本控制之下，最好是包含它所记录的源代码。但是其他格式也有不同的用途。在谷歌，我们经常使用谷歌文档来方便协作，特别是在设计问题上。然而，在某种程度上，任何共享文件都不再是一种讨论，而是一种稳定的历史记录。在这一点上，将其转移到更永久的地方，具有明确的所有权、版本控制和责任。

- 为什么设置文件的目的。总结您希望别人在阅读完文档后了解到的内容。一个很好的经验法则是在文档的引言中确定为什么。当你写摘要的时候，验证一下你是否达到了最初的期望(然后相应地修改)。

## 开头、中间和结尾

所有文档——实际上是文档的所有部分——都有一个开头、中间和结尾。虽然听起来很傻，但大多数文档至少应该有这三个部分。只有一个节的文档只有一件事要说，很少有文档只有一件事要说。不要害怕在你的文档中添加章节;它们将流分解成逻辑块，并为读者提供文档涵盖内容的路线图。

即使是最简单的文件通常也有不止一件事要说。我们流行的“c++周小贴士”传统上都很短，集中在一个小建议上。然而，即使在这里，分段也是有帮助的。传统上，第一部分表示问题，中间部分通过推荐的解决方案，结论总结的收获。如果文件只有一个部分，一些读者无疑会很难梳理出要点。

大多数工程师都不喜欢冗余，这是有充分理由的。但是在文档中，冗余通常是有用的。在一堆文本中隐藏的要点很难记住或梳理出来。另一方面，把这个点放在一个更突出的位置可能会失去之后提供的上下文。通常，解决方案是在一个介绍性的段落中介绍和总结要点，然后使用该部分的其余部分以更详细的方式来说明你的情况。在这种情况下，冗余可以帮助读者理解所陈述内容的重要性。

## 优秀文档的参数

好的文档通常有三个方面:完整性、准确性和清晰性。您很少在同一文档中获得所有这三种内容;例如，当你试图使一份文档更“完整”时，清晰度可能会开始下降。如果您试图记录API的每一个可能的用例，您可能会以难以理解的混乱而告终。对于编程语言来说，在所有情况下完全准确(并记录所有可能的副作用)也会影响清晰度。对于其他文档，试图明确一个复杂的主题可能会微妙地影响文档的准确性;例如，您可能决定忽略概念性文档中一些罕见的副作用，因为文档的重点是让人们熟悉API的用法，而不是提供所有预期行为的教条概述。

在每一种情况下，“好文档”都被定义为执行其预期工作的文档。因此，您很少希望一个文档完成不止一项工作。对于每个文档(以及每种文档类型)，确定其重点并适当调整写作。写概念性文档?您可能不需要覆盖API的每个部分。写一个参考?你可能想要完整，但可能必须牺牲一些清晰度。写登陆页面?注重组织，尽量少讨论。所有这些都增加了质量，但不可否认的是，这是很难精确衡量的。

如何快速提高文档的质量?关注听众的需求。通常情况下，少即是多。例如，工程师经常犯的一个错误是向API文档中添加设计决策或实现细节。就像您应该理想地将接口与设计良好的API中的实现分离一样，您应该避免在API文档中讨论设计决策。用户不需要知道这些信息。相反地，你应该将这些决策放在专门的文件中(通常是设计文件)。


## 不以为然的文档

就像旧的代码会导致问题一样，旧的文档也会产生问题。随着时间的推移，文档变得陈旧、过时或(通常)被抛弃。尽量避免被丢弃的文档，但是当文档不再有任何用途时，要么删除它，要么将其标识为过时的(如果有的话，指示从哪里获取新信息)。即使对于无主文档，也会有人添加这样的注释:“这不再有效!”比说什么都不说，留下一些看起来很权威但不再管用的东西更有帮助。

在谷歌，我们经常在文件上附加“新鲜日期”。这样的文档会说明文档最后一次被审查的时间，而文档集中的元数据将在文档尚未被修改(例如三个月)时发送电子邮件提醒。如下面的例子所示，这样的新鲜度日期——并将文档跟踪为bug——可以帮助文档设置在一段时间内更容易维护，这是文档的主要关注点:

```
<!--* 
# Document freshness: For more information, see go/fresh-source. 
freshness: { owner: `username` reviewed: '2019-02-27' } 
*-->
```

拥有这样一个文档的用户有动机保持文档的最新日期(如果文档处于源代码控制之下，就需要进行代码审查)。因此，这是一种低成本的方法来确保文件被不时地检查。在谷歌，我们发现在文档本身中包含一个文档的所有者在这个更新日期内，并加上一个“最后由……，”也导致了更多的用户。


## 你何时需要技术作家?

当谷歌还很年轻和成长的时候，在软件工程方面没有足够的技术写手。(现在依然如此。)那些被认为重要的项目倾向于接受技术作家，而不管团队是否真的需要一个。其理念是，作者可以减轻团队编写和维护文档的一些负担，(理论上)允许重要项目获得更大的开发速度。这是一个糟糕的假设。

我们了解到大多数工程团队都可以很好地为自己(他们的团队)编写文档;只有当他们在为其他读者编写文档时，他们才会需要帮助，因为向其他读者编写文档是很困难的。您的团队中关于文档的反馈循环更加直接，领域知识和假设更加清晰，感知到的需求也更加明显。当然，技术写手通常可以在语法和组织方面做得更好，但支持单个团队并不是对有限和专门资源的最佳利用;它没有规模。它引入了一个反常的动机:成为一个重要的项目，您的软件工程师就不需要编写文档。不让工程师写文档与您想做的恰恰相反。

因为他们是有限的资源，技术作家通常应该关注软件工程师不需要作为他们正常职责的一部分的任务。通常，这涉及编写跨越API边界的文档。Project Foo可能清楚地知道Project Foo需要什么文档，但是它可能不太清楚Project Bar需要什么。技术写手能够更好地代替不熟悉该领域的人。事实上，这是他们的一个关键角色:挑战您的团队对项目效用的假设。这就是为什么许多(如果不是大多数的话)软件工程技术作者倾向于关注这种特定类型的API文档的原因之一。

## 结论

谷歌在过去的十年里在文档质量方面取得了很大的进步，但是坦率地说，谷歌的文档还不是一流的。相比之下，工程师们已经逐渐接受了测试对于任何代码更改都是必要的，无论更改多么小。此外，测试工具是健壮的、多样化的，并且在不同的点插入到工程工作流中。文档在几乎相同的级别上不是根深蒂固的。

公平地说，对文档的要求与对测试的要求并不一定相同。测试可以是原子测试(单元测试)，并且可以遵循规定的形式和功能。文档在很大程度上不能。测试可以自动化，并且常常缺乏自动化文档的方案。文件必然是主观的;文档的质量不是由作者来衡量的，而是由读者来衡量的，而且通常是相当不同步的。也就是说，人们已经认识到文档的重要性，并且围绕文档开发的过程正在改进。在笔者看来，谷歌的文档质量比大多数软件工程工作室要好。

为了改变工程文档的质量，工程师——以及整个工程组织——需要接受他们既是问题所在也是解决方案。他们需要意识到，制作高质量的文档是他们工作的一部分，从长远来看可以节省他们的时间和精力，而不是对文档的状态束手无策。对于任何您希望寿命超过几个月的代码，您为该代码编写文档的额外周期不仅会帮助他人，还会帮助您维护该代码。

## TL, DRs

- 文档在时间和规模上都非常重要。

- 文档变更应该利用现有的开发人员工作流。

- 把文件集中在一个目的上。

- 写给你的读者，而不是你自己。