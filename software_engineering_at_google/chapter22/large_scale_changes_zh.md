# 第22章 大规模变更

**由Hyrum Wright撰写**。
**编辑：Lisa Carey**

想一想你自己的代码库，在一次同时提交中，你能可靠地更新多少个文件？制约这个数字的因素是什么？你有没有试过做出这么大的改动？在紧急情况下，你能在合理的时间内完成吗？你的最大提交量与您的代码库的实际规模相比如何？你将如何测试这样的变化？在提交变更之前，需要有多少人对其进行审核？如果真的被提交了，你能否回滚这个改动？这些问题的答案可能会让你大吃一惊(包括你认为的答案和对你的组织而言的实际效果)。

在谷歌，我们很久以前就放弃了在我们的代码库中进行大规模原子式修改的想法。我们观察到，随着代码库和在其中工作的工程师数量的增加，最大的原子修改可能会违反直觉地减少——运行所有受影响的提交前检查和测试变得困难，更不用说确保更改中的每个文件在提交前都是最新的。由于对我们的代码库进行全面的更改变得越来越困难，考虑到我们普遍希望能够不断改进底层基础设施，我们必须开发新的方法来推理大规模的更改以及如何实现它们。

在本章中，我们将讨论社会和技术方面的技术，这些技术使我们能够保持大型谷歌代码库的灵活性，并对底层基础设施的变化做出响应。我们还将提供一些我们如何以及在哪里使用这些方法的真实例子。尽管你的代码库可能不像谷歌的代码库，但是理解这些原则并在本地进行调整，将有助于您的开发组织在扩大规模的同时，仍然能够在您的代码库中进行广泛的更改。

## 什么是大规模的变更

在更进一步之前，我们应该深入研究什么是一次大规模变更（LSC)。根据我们的经验，LSC是任何一组逻辑上相关的变化，但实际上不能作为一个单一的原子单位提交。这可能是因为它涉及了太多的文件，底层工具无法一次提交所有文件，也可能是因为更改太大，总是会有合并冲突。在许多情况下，LSC是由您的存储库拓扑决定的:如果您的组织使用分布式或联合存储库的集合，在它们之间进行原子性更改在技术上甚至是不可能的。我们将在本章后面更详细地研究原子变化的潜在障碍。

谷歌的 LSCs 几乎总是使用自动工具生成的。产生 LSC 的原因各不相同，但这些变化本身通常属于几个基本类别:

•  使用代码库范围的分析工具清理常见的反模式

•  替换已废弃的库功能的使用

•  启用底层基础设施改进，如编译器升级

•  将用户从旧系统转移到新系统

在给定的组织中，从事这些具体任务的工程师数量可能很少，但是让他们的客户了解 LSC 工具和流程是很有用的。就其本质而言，LSC 将影响大量客户，而LSC工具很容易缩小到只做几十个相关变更的团队。

在特定的LSCs背后可能有更广泛的动机。例如，一个新的语言标准可能会引入一个更有效的成语来完成一个给定的任务，一个内部库接口可能会改变，或者一个新的编译器版本可能需要修复现有的问题，这些问题会被新版本标记为错误。谷歌的大多数LSCs实际上对功能的影响几乎为零：它们往往是为了清晰、优化或未来兼容性而进行的广泛的文本更新。但理论上，LSC并不局限于这种行为保护/重构类的变化。

在所有这些情况下，在像谷歌这样规模的代码库中，基础设施团队可能经常需要改变数十万个对旧模式或符号的单独引用。到目前为止，在最大的案例中，我们已经触及了数百万个引用，我们希望这个过程能够继续良好地扩展。一般来说，我们发现早期和经常投资于工具，以便为许多从事基础设施工作的团队实现LSCs是有利的。我们还发现，高效的工具也有助于工程师形成较小的变化。那些能使成千上万的文件得到有效修改的工具也能很好地扩展到几十个文件。

## 谁来解决大规模变更？

如前所述，构建和管理我们系统的基础设施团队负责执行物流服务中心的大部分工作，但工具和资源在整个公司都可用。如果您跳过了第1章，您可能会想为什么基础设施团队负责这项工作。为什么我们不能引入一个新的类、函数或系统，并规定每个使用旧的类、函数或系统的人都要转到更新的模拟类呢？虽然这在实践中似乎更容易，但由于几个原因，它并没有很好地扩展。

首先，构建和管理底层系统的基础设施团队也是拥有领域知识的团队，他们需要修复对这些系统的数十万次引用。消费基础设施的团队不太可能拥有处理许多这样的迁移的背景，而且期望他们每个人都重新学习基础设施团队已经拥有的专业知识，这在全球范围内是低效的。集中化也允许在面临错误时更快地恢复，因为错误通常属于一个小的类别，运行迁移的团队可以有一个正式或非正式的剧本来解决这些问题。

考虑一下做一系列你不了解的半机械性变化中的第一个所需的时间。你可能会花一些时间来阅读关于修改的动机和性质，找到一个简单的例子，试着按照提供的建议去做，然后试着把它应用到你的本地代码中。为组织中的每一个团队重复这样的工作，大大增加了执行的总体成本。通过只让少数集中的团队负责LSCs，谷歌既将这些成本内部化，又通过使变革更有效地发生而使其下降。

第二，没有人喜欢没有资金支持的任务。即使一个新的系统在本质上比它所取代的系统更好，但这些好处往往分散在整个组织中，因此不太可能重要到让各个团队主动去更新。如果新的系统足够重要，需要迁移到新的系统，那么迁移的成本将由组织中的某个地方来承担。集中迁移和核算其成本，几乎总是比依靠单个团队的有机迁移更快、更便宜。

此外，拥有需要LSCs的系统的团队有助于调整激励机制，以确保变革得以完成。根据我们的经验，有机迁移不太可能完全成功，部分原因是工程师在编写新代码时倾向于使用现有代码作为范例。由一个对移除旧系统有兴趣的团队负责迁移工作，有助于确保迁移工作真正完成。尽管为这些迁移工作提供资金和人员似乎是一种额外的成本，但实际上这只是将没有资金支持的任务所产生的外部因素内部化，同时还有规模经济的额外好处。

> ​                                                                  **案例学习： 填补坑洞**
>
> 尽管谷歌的LSC系统用于高优先级的迁移，但我们也发现，只要它们可用，就能为我们的代码库带来各种小的修复机会，没有它们是不可能的。就像交通基础设施任务包括修建新道路和修复旧道路一样，谷歌的基础设施团队除了开发新系统和将用户转移到新系统上之外，还花费大量时间修复现有代码。
>
> 例如，在我们历史的早期，出现了一个模板库来补充C++标准模板库。这个库被恰当地命名为谷歌模板库，由几个值得实现的头文件组成。由于时间的原因，这些头文件中的一个被命名为stl_util.h，另一个被命名为map-util.h(注意文件名中不同的分隔符)。除了让一致性纯粹主义者发疯之外，这种差异还导致了生产率的降低，工程师必须记住哪个文件使用了哪个分隔符，并且只有在潜在的漫长编译周期后出错时才会发现。
>
> 虽然修复这个单字符的变化似乎毫无意义，尤其是在像谷歌这么大的代码库中，但我们LSC工具和流程的成熟使我们只需要几周的后台工作就可以完成。库的作者可以发现并应用这种变化，而不必麻烦这些文件的最终用户，我们能够从数量上减少由这个特定问题导致的构建失败的数量。由此带来的生产率(和幸福感)的提高超过了做出改变所付出的时间。
>
> 随着在我们整个代码库中进行更改的能力的提高，更改的多样性也扩大了，我们可以做出一些工程决策，知道它们在未来不是不可改变的。有时候，填几个坑是值得的。

## 原子化修改的障碍

在我们讨论谷歌用来实际影响LSC的过程之前，我们应该谈谈为什么许多类型的更改不能自动提交。在理想的情况下，所有的逻辑变更都可以打包成一个独立的原子提交，可以独立于其他变更进行测试、审查和提交。不幸的是，随着版本库--以及在其中工作的工程师数量--的增长，这种理想变得不太可行。当使用一组分布式或联合版本库时，即使在小规模上，这也是完全不可行的。

### 技术限制

首先，大多数版本控制系统（VCS）都有随着变更的大小而线性扩展的操作。您的系统可能能够很好地处理小的提交(例如，几十个文件)，但是可能没有足够的内存或处理能力来一次自动提交数千个文件。在集中式 VCS 中，提交可以阻止其他写程序(在旧系统中，是读程序)在处理时使用系统，这意味着大型提交会使系统的其他用户停滞。

简而言之，原子性地做出大的改变可能不仅仅是“困难”或“不明智”的: 在特定基础设施下，这根本是不可能的。将大的变更分成更小的、独立的块可以避开这些限制，尽管这会使变更的执行更加复杂。

### 合并冲突

随着变更规模的增长，合并冲突的可能性也会增加。我们所知的每个版本控制系统都需要更新和合并，如果中央存储库中存在文件的更新版本，则可能需要手动解析。随着变更中文件数量的增加，遇到合并冲突的可能性也会增加，并且会因在存储库中工作的工程师数量而增加。

如果你的公司很小，你可以在没有人做开发的周末偷偷的修改仓库中的每个文件。或者您可能有一个非正式的系统，通过传递一个虚拟的(甚至是物理的！）你的开发团队。在像谷歌这样的大型全球性公司中，这些方法是不可行的:总是有人对存储库进行更改。

变更中的文件越少，合并冲突的概率就越小，因此它们更有可能被提交而没有问题。该属性也适用于以下领域。

### 没有闹鬼的墓地

运营谷歌生产服务的 SRE们有一句口头禅:“没有闹鬼的墓地”。在这个意义上，一个闹鬼的墓地是一个非常古老、愚蠢或复杂以至于没有人敢进入的系统。闹鬼的墓地通常是关键业务系统，它们会被及时冻结，因为任何改变它们的尝试都可能导致系统以不可理解的方式失败，给企业带来真正的损失。它们构成了真正的生存风险，并会消耗过多的资源。

然而，闹鬼的墓地不仅仅存在于生产系统中；它们可以在代码库中找到。许多组织都有一些旧的、未维护的软件，它们是由远离团队的人编写的，并且处于一些重要的创收功能的关键路径上。这些系统也在时间上被冻结，层层的官僚机构被建立起来，以防止可能导致不稳定的变化。没人想当翻错位的网络支持工程师二！

代码库的这些部分是LSC过程中的大忌，因为它们阻碍了大型迁移的完成，阻碍了它们所依赖的其他系统的退役，也阻碍了它们所使用的编译器或库的升级。从LSC的角度来看，闹鬼的墓地阻碍了各种有意义的进展。

在谷歌，我们发现与之相反的是好的老式测试。当软件经过彻底测试后，我们可以对其进行任意更改，并且可以放心地知道这些更改是否会被破坏，无论系统的年龄或复杂性如何。编写这些测试需要很大的努力，但它允许像谷歌这样的代码库在很长一段时间内发展，将闹鬼的软件墓地的概念交付给自己的墓地。

### 异构性

只有当大部分的工作由计算机而不是人类来完成时，LSC才会真正发挥作用。尽管人类可以很好地处理模棱两可的问题，但计算机要依靠一致的环境将适当的代码转换应用到正确的地方。如果你的组织有许多不同的VCS、持续集成（CI）系统、特定项目的工具或格式化准则，就很难在整个代码库中进行全面的改变。简化环境，增加一致性，对需要在其中活动的人类和进行自动转换的机器人都有帮助。

例如，谷歌的许多项目都配置了预提交测试，以便在对其代码库进行修改之前运行。这些检查可能非常复杂，从对照白名单检查新的依赖关系，到运行测试，再到确保变化有一个相关的错误。这些检查中有许多与编写新功能的团队有关，但对于LSCs来说，它们只是增加了额外的无关的复杂性。

我们已经决定接受其中的一些复杂性，例如运行预提交测试，使其成为我们整个代码库的标准。对于其他不一致的地方，我们建议团队在LSCs的部分内容接触到他们的项目代码时，省略他们的特殊检查。考虑到这些类型的变化对他们的项目的好处，大多数团队都很乐意帮助。

### 测试

每一个变化都应该被测试(这个过程我们稍后会详细讨论)，但是变化越大，就越难对其进行适当的测试。谷歌的CI系统不仅会立即运行受到变更影响的测试，还会运行任何暂时依赖于变更文件的测试。[6]这意味着变更得到了广泛的覆盖，但是我们也观察到，在依赖图中，一个测试离受影响的文件越远，那么失败就越不可能是由变更本身引起的。

一个小的、独立的变更更容易被验证，因为它们中的每一个不仅会影响更小的测试集，而且因为测试失败更容易诊断和修复。在25个文件的变更中找到测试失败的根本原因非常简单；在一万个文件的变更中找到一个就像谚语中所说的大海捞针。 

这个决定的权衡是较小的改变将导致运行多次相同的测试，特别是依赖于大部分代码库的测试。因为工程师花在跟踪测试失败上的时间比运行这些额外测试所需的计算时间要更多，所以我们下意识地决定，这是我们愿意做出的权衡。同样的权衡可能不适用于所有的组织，但是值得研究一下什么是适合你自己的权衡。

> 
>​                                                                       **案例研究:LSCs**

> ​                                                                       Adam Bender
>
> 如今，由LSC导致的项目中两位数百分比(10%到20%)的变更是很常见的，这意味着项目中大量的代码是由与这些项目无关的全职工作的人更改的。没有好的测试，这样的工作是不可能的，谷歌的代码库将在自身重量下迅速萎缩。LSCs使我们能够系统地将我们的整个代码库迁移到新的应用编程接口，而不是旧的应用编程接口，改变语言版本，并删除流行但危险的做法。
>
>即使是一个简单的单行签名更改，当在一千个不同的地方，跨越数百种不同的产品和服务时，也会变得复杂。写完变更后，你需要协调几十个团队的代码评审。最后，在评审通过后，你需要尽可能多地运行测试来确保变更是安全的。我们说“尽可能多”，是因为一个适当大小的LSC可能会引发谷歌每一项测试的重新运行，这可能需要一段时间。实际上，许多LSC必须计划时间来捕获下游客户，而下游客户在LSC进入流程的过程中会发生代码后退的情况。
> 
>测试LSC可能是一个缓慢而令人沮丧的过程。当一个变化足够大时，你的本地环境几乎总是会永远与head不同步，因为代码库会像沙子一样在你的工作中移动。在这种情况下，很容易发现自己正在运行和重新运行测试，只是为了确保您的更改继续有效 。当一个项目有不稳定的测试或者缺少单元测试覆盖时，它可能需要大量的人工干预，并减慢整个过程。为了加快速度，我们使用了一种叫做TAP(测试自动化平台)的策略。
> 
>​                                                                           **认识TAP策略**
> 
>对LSCs的核心认识是，它们很少相互作用，大多数受影响的测试将通过大多数LSCs。因此，我们可以一次测试多个变更，并减少执行的测试总数。列车模型已被证明对测试低成本策略非常有效。
> 
>TAP系列利用了两个事实：
> 
>- LSCs往往是纯粹的重构，因此范围非常窄，保留了局部语义。
> 
>
> - 单个更改通常更简单且受到严格审查，因此它们经常是正确的。 
>
> 
>策略模型还具有以下优点：它可以同时处理多个变更，并且不需要每个单独的变更都单独处理。[9] 
>
> 策略模型有五个步骤，每三个小时重新开始 :
>
>1. 对于策略上的每个变化，运行1000个随机选择的测试样本。
> 2. 收集通过1000次测试的所有变更，并从所有变更中创建一个超级变更：“策略”。 
>3. 运行受变更组直接影响的所有测试的联合。给定一个足够大(或足够低)的LSC，这可能意味着在谷歌的存储库中运行每一个测试。这个过程可能需要六个多小时才能完成。
> 4. 对于每一个失败的不可靠的测试，针对进入策略的每一个变化单独重新运行，以确定是哪些变化导致它失败。
>5. TAP为策略中的每个变更生成一份报告。报告描述所有通过和未通过的目标，并可用作提交LSC是安全的证据。

### 代码审查

最后，正如我们在第9章中提到的，所有变更都需要在提交之前进行审查，此政策甚至适用于LSCs。审查大型提交可能是乏味的、繁重的，甚至是容易出错的，尤其是如果变更是手工生成的(您希望避免这一过程，我们将很快讨论这一点)。稍后，我们将看看工具在这一领域是如何发挥作用的，但是对于某些类别的变化，我们仍然希望人类能够明确地验证它们是正确的。将LSC分割成独立的碎片会使这变得容易得多。

> ​                                                                       **案例研究:从scoped_ptr到std::unique_ptr**
>
> 从早期开始，谷歌的C++代码库就有一个自毁式智能指针，用于包装堆分配的C++对象，并确保当智能指针超出范围时，这些对象被销毁。这种类型被称为scoped_ptr，并在谷歌的代码库中广泛使用，以确保对象生命周期得到适当的管理。它并不完美，但是考虑到当时的C++标准(C++98)在第一次引入这种类型时的局限性，它使程序更加安全。[9]可以要求TAP进行单次更改“隔离”运行，但这些非常昂贵，并且仅在非高峰时段执行。
>
> 在C++11中，该语言引入了一种新的类型:std::unique_ptr。它实现了与scoped_ptr相同的功能，但也防止了该语言现在可以检测到的其他类型的错误。std::unique_ptr严格来说比scoped_ptr好，但是谷歌的代码库有超过500,000个对scoped_ptr的引用，分散在数百万个源文件中。转向更现代的类型需要谷歌内部最大的LSC进行尝试。
>
> 在几个月的时间里，几名工程师并行处理了这个问题。使用Google的大规模迁移基础设施，我们能够将对scoped_ptr的引用更改为对std::unique_ptr的引用，并慢慢调整scoped_ptr，使其行为更接近std::unique_ptr。在迁移过程的高峰期，我们不断地生成、测试和提交超过700个独立的变更，每天处理超过15,000个文件。今天，我们有时可以管理10倍的吞吐量，改进我们的实践和工具。
>
> 像几乎所有的LSC一样，这个LSC有一条很长的尾巴来跟踪各种细微的行为依赖(Hyrum定律的另一种表现)，与其他工程师一起对抗种族条件，并在生成的代码中使用我们的自动化工具无法检测到的东西。当测试基础设施发现它们时，我们继续手动处理它们。
>
> scoped_ptr还在一些广泛使用的API中用作参数类型，这使得小的独立更改变得困难。我们考虑编写一个调用图分析系统，它可以在一次提交中临时改变一个应用编程接口及其调用方，但担心由此产生的更改本身会太大，无法自动提交。
>
最后，我们能够最终删除scoped_ptr，方法是首先使它成为std::unique_ptr的类型别名，然后在旧别名和新别名之间执行文本替换，最后只删除旧的scoped_ptr别名。今天，谷歌的代码库受益于使用与C++生态系统其余部分相同的标准类型，这是可能的，因为我们的技术和工具为LSC。

## LSC基础设施

谷歌投资了大量基础设施，使物流服务公司成为可能。该基础设施包括用于变更创建、变更管理、变更评审和测试的工具。然而，对地方自治中心最重要的支持可能是围绕大规模变革的文化规范的演变和对它们的监督。尽管技术和社交工具的组合可能因组织而异，但一般原则应该是相同的。

### 政策和文化

正如我们在第16章中所描述的，谷歌将其大部分源代码存储在一个单一的存储库中(monorepo)，每个工程师都可以看到几乎所有这些代码。这种高度的开放性意味着任何工程师都可以编辑任何文件，并将这些编辑内容发送给能够批准它们的人进行审查。然而，每一次编辑都有成本，既要生成，也要审核。[10]

从历史上看，这些成本多少是对称的，这限制了单个工程师或团队可能产生的变化范围。随着谷歌LSC工具的改进，以非常低的成本生成大量变更变得更加容易，对于一个工程师来说，给整个公司的大量评审人员增加负担也变得同样容易。即使我们想鼓励对我们的代码库进行广泛的改进，我们也想确保它们背后有一些监督和考虑，而不是不加选择的调整。[11]

最终结果是一个轻量级的批准过程，这适用于寻求在谷歌内部制造LSCs的团队和个人。这一过程由一群熟悉各种语言细微差别的有经验的工程师监督，同时也邀请领域专家参与讨论中的特定变化。这个过程的目标不是禁止LSC，而是帮助变更作者产生尽可能好的变更，最大限度地利用谷歌的技术和人力资本。偶尔，这个小组可能会认为清理是不值得的：例如，清理一个常见的错别字，而没有任何方法来防止再次发生。

与这些政策相关的是围绕地方自治中心的文化规范的转变。尽管对代码所有者来说，对他们的软件有责任感很重要，但他们也需要知道LSC是谷歌扩大我们软件工程实践的努力的重要组成部分。正如产品团队最熟悉他们自己的软件一样，库基础设施团队知道基础设施的细微差别，让产品团队相信领域专业知识是社会接受LSC的重要一步。作为这种文化转变的结果，当地的产品团队已经开始信任LSC的作者来做出与这些作者的领域相关的改变。

有时，本地所有者会质疑作为更广泛的LSC的一部分而做出的特定承诺的目的，而变更作者会像对其他评论那样对这些评论做出回应。从社会角度来说，代码所有者理解他们的软件正在发生的变化是很重要的，但是他们也开始意识到他们对更广泛的LSC没有否决权。随着时间的推移，我们发现了一个很好的常见问题一个坚实的历史进步记录已经在整个谷歌得到了物流服务公司的广泛认可。

### 代码库洞察

为了进行语义搜索，我们发现能够对我们的代码库进行大规模分析是非常宝贵的，既可以在文本层面使用传统工具，也可以在语义层面进行分析。例如，谷歌对语义索引工具Kythe的使用提供了我们代码库各部分之间链接的完整地图，允许我们询问诸如”这个函数的调用方在哪里？”或者“哪个类从这个派生？”Kythe和类似的工具还提供了对其数据的编程访问，以便它们可以被合并到重构工具中。(更多示例，请参见第17章和第20章。）

我们还使用基于编译器的索引在我们的代码库中运行基于抽象语法树的分析和转换。可以以高度并行化的方式执行转换的工具，如ClangMR、JavacFlume或Refaster，依赖于这些洞察力作为其功能的一部分。对于较小的更改，作者可以使用专门的定制工具、perl或sed、正则表达式匹配，甚至简单的shell脚本。

无论您的组织使用什么工具来创建变更，重要的是它的人工工作要与代码库次线性地扩展；换句话说，无论存储库的大小如何，生成所有所需变更的集合都应该花费大致相同的人工时间。变更创建工具在整个代码库中也应该是全面的，这样作者可以确信他们的变更覆盖了他们试图修复的所有情况。

与本书的其他领域一样，工具的早期投资通常在短期到中期内会有回报。根据经验，我们一直认为，如果一个变更需要500次以上的编辑，工程师学习和执行我们的变更生成工具通常比手动执行编辑更有效。对于有经验的“代码管理员”，这个数字通常要小得多。

### 变更管理

可以说，大规模变更基础设施最重要的部分是一套工具，它将主变更分割成更小的部分，并独立地管理测试、邮寄、审查和提交它们的过程。在谷歌，这个工具叫做Rosie，当我们检查我们的LSC过程时，我们稍后会更全面地讨论它的使用。在许多方面，Rosie不仅仅是一个工具，而是一个在谷歌规模上制作LSC的完整平台。它提供了将工具产生的大量综合变更分割成更小的碎片的能力，这些碎片可以独立地进行测试、评审和提交。

### 测试

测试是支持大规模变革的基础设施的另一个重要部分。正如在第11章中所讨论的，测试是我们验证软件行为是否符合预期的重要方式之一。当应用非人类创作的更改时，这一点尤其重要。强大的测试文化和基础设施意味着其他工具可以确信这些变化不会产生意想不到的影响。

谷歌对LSC的测试策略与正常变化略有不同，同时仍然使用相同的底层CI基础设施。测试LSCs意味着不仅要确保大型主变更不会导致失败，还要确保每个碎片都可以安全、独立地提交。因为每个碎片可以包含任意文件，所以我们不使用标准的基于项目的预提交测试。相反，我们在每个可能影响的测试的传递闭包上运行每个分片，这在前面已经讨论过了。

### 语言支持 

谷歌的本地化服务通常是基于每种语言进行的，有些语言比其他语言更容易支持。我们发现，当我们引入新系统并以非原子方式将用户迁移到新系统时，诸如类型别名和转发功能等语言功能对于允许现有用户继续运行非常重要。对于缺乏这些特性的语言，通常很难增量迁移系统。

我们还发现，静态类型的语言比动态类型的语言更容易执行大型自动化更改。基于编译器的工具以及强大的静态分析提供了大量的信息，我们可以使用这些信息来构建工具，以影响LSC，并在无效转换进入测试阶段之前拒绝它们。这样做的不幸结果是，像Python、Ruby和JavaScript这样的动态类型语言对维护人员来说格外困难。在许多方面，语言选择与代码生命周期密切相关:倾向于被视为更关注开发人员生产力的语言更难维护。虽然这不是一个内在的设计要求，但这正是当前艺术的现状。

最后，值得指出的是，自动语言格式化程序是LSC基础设施的关键部分。因为我们致力于优化代码的可读性，所以我们希望确保由自动化工具产生的任何更改对代码的直接审阅者和未来的读者来说都是可理解的。所有的LSC生成工具都运行适合被改变的语言的自动格式化程序，作为一个单独的过程，所以特定于改变的工具不需要关注格式细节。对我们的代码库应用自动格式化，如google-java-format或clang-format，意味着自动生成的更改将“适合”人类编写的代码，从而减少未来的开发摩擦。如果没有自动化的格式化，大规模的自动化变更将永远不会成为谷歌接受的现状。

> <center>案例研究:RoseHub操作</center>
>LSCs已经成为谷歌内部文化的一大部分，但它们开始在更广阔的世界产生影响。到目前为止，最著名的案例可能是“RoseHub操作”。
> 
>2017年初，Apache Commons库中的一个漏洞允许任何在其可传递的类路径中具有该库的易受攻击版本的Java应用程序变得容易被远程执行。这个bug被称为“疯狂小工具”。除此之外，它还允许一个贪婪的黑客对旧金山市交通局的系统进行加密，并关闭其运营。因为该漏洞的唯一要求是在其类路径中的某个地方有错误的库，所以任何依赖于GitHub上许多开源项目之一的东西都是易受攻击的。
> 
>为了解决这个问题，一些有进取心的谷歌人推出了他们自己版本的LSC进程。通过使用BigQuery等工具，志愿者们确定了受影响的项目，并发送了2600多个补丁，将他们的共享库版本升级到一个针对Mad Gadget的版本。代替自动化工具来管理这个过程，50多人让这个LSC工作。
## LSC进程

有了这些基础设施，我们现在可以谈谈实际制作LSC的过程。这大致分为四个阶段（它们之间的界限非常模糊）:

1. 授权
2. 变更的产生
3. 碎片管理
4. 清理

通常情况下，这些步骤发生在一个新的系统、类或功能被编写出来之后，但在设计新系统的过程中牢记这些步骤是很重要的。在Google，我们的目标是在设计后续系统时，考虑到旧系统的迁移路径，这样系统维护者就可以自动将用户转移到新系统中。

### 授权

我们要求潜在的作者们填写一份简短的文档，解释拟议变更的原因，其对整个代码库的估计影响（即，大型变更将产生多少个较小的碎片）以及可能的审阅者可能回答的任何问题的答案。 此过程还迫使作者考虑如何以FAQ和建议的更改描述的形式向不熟悉的工程师描述更改。 作者还可以从重构API的所有者那里获得“域审查”。

然后，这个提案会被转发到一个有十几个人的电子邮件名单上，这些人对整个过程有监督作用。经过讨论，委员会会就如何推进工作给出反馈。例如，委员会做出的最常见的变更之一是将一个LSC的所有代码审查引导到一个 "全局审批人 "那里。许多第一次编写LSC的人倾向于认为本地项目业主应该审查所有的东西，但对于大多数机械LSC来说，让一个专家了解变化的性质并围绕正确审查它建立自动化是更加便宜的。

在修改获得批准后，作者可以继续提交其修改。从历史上看，委员会在批准方面一直非常宽松，往往不仅批准某项具体的修改，而且还批准一系列广泛的相关修改。委员会成员可以酌情对明显的改动进行快速处理，而不需要进行充分审议。

这个过程的目的是提供监督和升级的途径，而不至于让LSC的作者太过繁琐。委员会还被授权作为对有关LSC的关切或冲突的升级机构：不同意修改的当地业主可以向该小组提出申诉，然后由该小组对任何冲突进行仲裁。在实践中，很少需要这样做。

### 变更的产生

在获得必要的批准后，LSC作者将开始制作实际的代码编辑。有时，这些内容可以全面地生成一个大的全局变化，随后将被分割成许多小的独立部分。通常情况下，由于底层版本控制系统的技术限制，修改的规模太大，无法容纳在一个全局修改中。

变更的产生过程应该尽可能的自动化，这样当用户退回到旧的使用方式或在变更的代码中出现文本合并冲突时，父级变更可以被更新。偶尔，在技术工具无法生成全局变更的罕见情况下，我们也会将变更的生成分给人类（见第472页的 "案例研究：RoseHub操作"）。尽管这比自动生成变更要耗费更多的人力，但对于时间敏感的应用来说，这使得全局性的变更能够更快发生。

请记住，我们对代码库的人类可读性进行了优化，所以无论什么工具生成的修改，我们都希望生成的修改看起来尽可能的像人类生成的修改。这一要求导致了风格指南和自动格式化工具的必要性（见第8章）。

### 分片和提交

在全局变化产生之后，作者就开始运行Rosie。Rosie获取一个大的变更，并根据项目边界和所有权规则将其分割成可以原子化提交的变更。然后，它把每个单独的分片变化通过一个独立的测试--邮件-提交管道。Rosie可能是谷歌开发者基础设施其他部分的重度用户，所以它对任何给定的LSC的未完成分片数量设置上限，以较低的优先级运行，并与基础设施的其他部分进行沟通，了解它在我们的共享测试基础设施上产生多少负载是可以接受的。

我们在下面会更多地谈论每个分片的具体测试-邮件提交过程。

> ​                                                                                                    **牛与宠物**
>
> 当提到分布式计算环境中的单个机器时，我们经常使用 "牛与宠物 "的比喻，但同样的原则可以适用于代码库中的变化。

> 在谷歌，和大多数组织一样，代码库的典型变更是由从事特定功能或错误修复的个别工程师手工制作的。工程师们可能会花几天或几周的时间来创建、测试和审查一个单一的变更。他们密切了解这个变更，当它最终被提交到主资源库时，他们会感到很自豪。创建这样的变更就像拥有和养育一只喜爱的宠物一样。
>
>相比之下，有效地处理LSCs需要高度的自动化，并产生大量的单独的变更。在这种环境下，我们发现把特定的修改当作牛来对待是很有用的：无名无姓的提交，在任何时候都可能被回滚或以其他方式拒绝，除非整个牛群受到影响，否则代价很小。通常情况下，这种情况发生的原因是测试没有发现的意外问题，或者是像合并冲突这样简单的事情。
> 

对于 "宠物 "提交，不把拒绝放在心上是很难的，但当作为大规模变更的一部分，处理许多变更时，这只是工作的性质。有了自动化，意味着可以以非常低的成本更新工具和产生新的变化，所以偶尔失去几头牛并不是什么问题。

#### 测试

每个独立的分片都是通过谷歌的CI框架TAP来测试的。我们运行每一个依赖于特定变化中的文件的测试，这常常给我们的CI系统带来高负荷。

这可能听起来很昂贵，但实际上，在我们的代码库中的数百万个测试中，绝大多数碎片影响的测试不到一千。对于那些影响更多的测试，我们可以将它们分组：首先运行所有分片的所有受影响测试的联合，然后对于每个单独的分片，只运行其受影响的测试与那些第一次运行失败的测试的交集。大多数这些联合导致代码库中的几乎每一个测试都被运行，所以向该批分片添加额外的修改几乎是无成本的。

运行如此大量的测试的缺点之一是，独立的低概率事件在足够大的规模下几乎是肯定的。脆弱和易碎的测试，如第11章中讨论的那些，通常不会伤害编写和维护它们的团队，对LSC作者来说特别困难。虽然对单个团队的影响相当小，但片状测试会严重影响LSC系统的吞吐量。自动片断检测和消除系统有助于解决这个问题，但要确保编写片断测试的团队承担其成本，这可能是一个持续的努力。

根据我们对LSCs作为语义保护、机器生成的变化的经验，我们现在对单个变化的正确性比对近期有任何闪失的测试更有信心 —— 以至于最近闪失的测试现在在通过我们的自动化工具提交时被忽略了。在理论上，这意味着一个单一的碎片可能会导致性能衰退，而这个衰退只能由一个不稳定的测试从不稳定到失败来检测。在实践中，我们很少看到这种情况，所以通过人工沟通而不是自动化来处理它。

对于任何LSC进程来说，各个分片应该是可以独立提交的。这意味着它们没有任何相互依赖性，或者说分片机制可以将相互依赖的变更（比如对头文件和其实现的变更）归为一组。就像其他变化一样，大规模的变化分片在被审查和提交之前也必须通过项目特定的检查。

#### 寄送审查者

在Rosie通过测试验证了某项变更是安全的之后，它就会将该变更寄送给适当的审查者。在谷歌这样一个拥有数千名工程师的大公司，审查者的发现本身就是一个具有挑战性的问题。回顾第九章，版本库中的代码是用 OWNERS 文件组织的，它列出了对版本库中特定子树有批准权限的用户。Rosie使用一个所有者检测服务来理解这些OWNERS文件，并根据他们审查特定分片的预期能力来衡量每个所有者。如果一个特定的所有者被证明没有反应，Rosie会自动添加额外的审查者，以努力使一个变化得到及时的审查。

作为邮寄过程的一部分，Rosie也运行每个项目的预提交工具，这可能会执行额外的检查。对于LSCs，我们有选择地禁用某些检查，例如对非标准的修改描述格式的检查。虽然对特定项目的个别变化很有用，但这种检查是整个代码库的异质性的来源，会给LSC过程增加很大的摩擦。这种异质性是扩展我们流程和系统的障碍，不能指望LSC工具和作者了解每个团队的特殊政策。

我们还主动地忽略了预先提交的检查故障，这些故障在有关的变化之前就已经存在了。当在一个单独的项目上工作时，工程师很容易修复这些故障并继续他们原来的工作，但当在谷歌的代码库中制作LSC时，这种技术就无法扩展。本地代码所有者有责任在他们的代码库中没有预先存在的故障，这是他们和基础设施团队之间社会契约的一部分。

#### 审查

和其他的修改一样，由Rosie产生的变更被期望通过标准的代码审查过程。在实践中，我们发现本地业主通常不会像对待普通变更那样严格对待LSCs —— 他们太信任产生LSCs的工程师了。理想情况下，这些变化会像其他变化一样被审查，但在实践中，本地项目业主已经开始信任基础设施团队，以至于这些变化往往只被粗略地审查。我们已经开始只把那些需要他们审查的变化发送给本地业主，而不仅仅是批准权限。所有其他的修改都可以交给 "全局审批人"：拥有所有权的人可以批准整个版本库的任何修改。

全局审核员可以使用单独的一组基于模式的工具来审核每个更改并自动批准满足其期望的更改，而不是单独查看每个更改。 因此，他们只需要手动检查由于合并冲突或工具故障而异常的一小部分子集，这可以很好地扩展过程。

#### 提交

最后，单独修改被提交。与寄送步骤一样，我们确保修改通过各种项目的预提交检查，然后才真正最终提交到仓库。

借助Rosie，我们每天可以有效地创建，测试，审查和提交Google所有代码库中成千上万的更改，并使团队能够有效地迁移其用户。 过去曾经是最终决定的技术决策（例如，广泛使用的符号的名称或代码库中流行类的位置）不再是最终决定。

### 清理

不同的LSC对 "完成 "有不同的定义，从完全删除一个旧系统到只迁移高价值的引用，让旧的引用有机地消失。几乎在所有情况下，重要的是要有一个系统来防止额外引入大规模变革中努力删除的符号或系统。在谷歌，我们使用第20章和第19章中提到的Tricorder框架，当工程师引入一个废弃对象的新用途时，在审查时进行标记，这被证明是防止倒退的有效方法。我们在第15章中详细讨论了整个废弃过程。

## 总结

LSCs构成了谷歌软件工程生态系统的一个重要部分。在设计时，他们开启了更多的可能性，知道一些设计决策不需要像以前那样固定。LSC过程还允许核心基础设施的维护者有能力将谷歌的大片代码库从旧的系统、语言版本和库习语迁移到新的系统，使代码库在空间上和时间上保持一致。而这一切都发生在只有几十名工程师支持数万名其他工程师的情况下。

无论你的组织有多大的规模，你都有理由考虑如何在你的源代码集合中进行这类广泛的变更。不管是出于选择还是需要，拥有这种能力将使你的组织在扩大规模时有更大的灵活性，同时使你的源代码随着时间的推移保持可塑性。

## TL;DRs

- LSC过程使我们有可能重新思考某些技术决定的不可改变性。

- 传统的重构模式在大范围内会被打破。
- 制作LSCs意味着养成制作LSCs的习惯。
