# 第12章 单元测试

**由Erik Kuefler撰写**
**由Tom Manshreck编辑**

上一章介绍了Google对测试进行分类的两个主要轴线：规模和范围。简而言之，规模指的是测试所消耗的资源和它被允许做的事情，范围指的是一个测试打算验证多少代码。虽然谷歌对测试规模有明确的定义，但范围往往有点模糊不清。我们用单元测试这个术语来指代范围相对较窄的测试，如单个类或方法的测试。单元测试通常是小规模的，但这并不总是如此。
在防止错误之后，测试最重要的目的是提高工程师的生产力。与范围更广的测试相比，单元测试有许多特性，使其成为优化生产力的绝佳方式。

- 根据谷歌对测试规模的定义，它们往往是小的。小型测试是快速和确定的，允许开发人员频繁地运行它们，作为他们工作流程的一部分，并获得即时反馈。
- 他们往往很容易与他们正在测试的代码同时编写，允许工程师将他们的测试集中在他们正在工作的代码上，而不需要建立和理解一个更大的系统。
- 他们促进高水平的测试覆盖率，因为他们是快速和容易编写的。高测试覆盖率使工程师有信心进行修改，他们不会破坏任何东西。
- 当他们失败的时候，他们往往很容易理解什么是错的，因为每个测试在概念上是简单的，并集中在系统的一个特定部分。
- 它们可以作为文档和例子，向工程师展示如何使用被测试的系统部分，以及该系统打算如何工作。

由于它们有很多优点，在Google写的大多数测试都是单元测试，作为一个经验法则，我们鼓励工程师把80%的单元测试和20%的范围更广的测试混合起来。这个建议，再加上编写单元测试的简易性和运行速度，意味着工程师要运行大量的单元测试--一个工程师在平均工作日内执行数千个单元测试（直接或间接）是很正常的。
由于单元测试在工程师的生活中占了很大一部分，所以谷歌非常重视测试的可维护性。可维护的测试是那些 "只是工作 "的测试：写完后，工程师不需要再考虑它们，直到它们失败，而且这些失败表明有明确原因的真正的错误。本章的主要内容是探讨可维护性的概念和实现它的技术。

## 可维护性的重要性

想象一下这个场景。Mary想给产品增加一个简单的新功能，并且能够快速实现，也许只需要几十行代码。但是当她去检查她的改动时，她从自动测试系统那里得到了满屏的错误。她花了一天的时间来逐一检查这些错误。在每个案例中，修改没有引入实际的错误，但打破了测试对代码内部结构的一些假设，需要对这些测试进行更新。通常情况下，她很难弄清楚这些测试首先要做的是什么，而她为修复这些测试而添加的黑客攻击使这些测试在未来更加难以理解。最终，本应是一个快速的工作，却要花费数小时甚至数天的时间来忙碌，扼杀了玛丽的工作效率，消磨了她的士气。
在这里，测试与它的预期效果正好相反，它耗尽了生产力，而不是提高生产力，同时也没有意义地提高被测代码的质量。这种情况太常见了，谷歌的工程师们每天都在与它斗争。没有什么灵丹妙药，但谷歌的许多工程师一直在努力开发一套模式和实践来缓解这些问题，我们鼓励公司的其他部门也这样做。
玛丽遇到的问题不是她的错，而且她也无法避免这些问题：糟糕的测试必须在签入之前被修复，以免它们给未来的工程师带来拖累。概括地说，她遇到的问题分为两类。首先，她所使用的测试是很脆弱的：它们在应对一个无害的、不相关的变化时，没有引入真正的bug而损坏。第二，测试不明确：在测试失败后，很难确定哪里出了问题，如何修复它，以及这些测试首先应该做什么。

## 防止脆性测试

正如刚才所定义的，脆性测试是指在面对不相关的程序代码变化时失败的测试，它并没有引入任何真正的bug。<sup>1</sup>在只有几个工程师的小代码库中，每次修改都要调整一些测试，这可能不是一个大问题。但是，如果一个团队经常写脆弱的测试，测试维护将不可避免地消耗团队越来越多的时间，因为他们不得不在不断增长的测试套件中梳理越来越多的故障。如果一套测试需要工程师为每一个变化进行手动调整，称其为 "自动化测试套件 "就有点牵强了。
1 请注意，这与片状测试略有不同，片状测试是在不改变生产代码的情况下非确定地失败。
脆弱的测试在任何规模的代码库中都会造成痛苦，但在谷歌的规模中，它们变得尤为严重。一个工程师在工作过程中，一天之内可能会轻易地运行数千个测试，而一个大规模的变化（见第22章）可能会引发数十万的测试。在这种规模下，即使是影响一小部分测试的假性故障也会浪费大量的工程时间。谷歌的团队在他们的测试套件的脆性方面有很大的不同，但我们已经确定了一些实践和模式，倾向于使测试对变化更加健壮。

### 努力实现不变的测试

在谈论避免脆性测试的模式之前，我们需要回答一个问题：在编写测试之后，我们应该多长时间需要修改一次？任何花在更新旧测试上的时间都是不能用在更有价值的工作上的时间。因此，理想的测试是不变的：在它写完之后，除非被测系统的需求发生变化，否则它永远不需要改变。
这在实践中是什么样子的呢？我们需要考虑工程师对生产代码所做的各种改变，以及我们应该如何期望测试对这些改变做出反应。从根本上说，有四种变化。
*纯粹的重构*
当工程师重构一个系统的内部结构而不修改其界面时，无论是为了性能、清晰度，还是其他原因，系统的测试都不应该改变。在这种情况下，测试的作用是确保重构没有改变系统的行为。在重构过程中需要改变的测试表明，要么变化影响了系统的行为，不是纯粹的重构，要么测试没有写在适当的抽象水平上。Google依靠大规模的变化（在第22章中描述）来做这样的重构，使得这种情况对我们特别重要。
*新功能*
当工程师向现有系统添加新的功能或行为时，系统的现有行为应该不受影响。工程师必须编写新的测试来覆盖新的行为，但他们不应该需要改变任何现有的测试。与重构一样，在添加新功能时，对现有测试的改变表明该功能的非预期后果或不适当的测试。
*Bug修复*
修复bug与添加新功能很相似：bug的存在表明初始测试套件中缺少一个案例，bug修复应该包括缺少的测试案例。同样，错误修复通常不需要对现有的测试进行更新。
*行为改变
改变系统的现有行为是一种情况，我们希望对系统的现有测试进行更新。请注意，这种变化往往比其他三种类型的测试要昂贵得多。一个系统的用户很可能依赖于其当前的行为，对该行为的改变需要与这些用户协调，以避免混乱或破坏。在这种情况下，改变一个测试表明我们正在破坏系统的一个明确的契约，而在前面的情况下的改变表明我们正在破坏一个非预期的契约。低级别的库往往会投入大量的精力来避免曾经的行为改变，以免破坏他们的用户。
这方面的启示是，在你写了一个测试之后，在你重构系统、修复错误或增加新功能时，你不应该再去碰这个测试。这种理解使得大规模地使用一个系统成为可能：扩展系统只需要写少量的与你所做的改变有关的新测试，而不是可能要触动每一个针对该系统写的测试。只有在系统行为中发生的破坏性变化才需要回去改变它的测试，在这种情况下，更新这些测试的成本相对于更新所有系统用户的成本来说，往往是很小的。

### 通过公共API进行测试

现在我们明白了我们的目标，让我们看看一些做法，以确保测试不需要改变，除非被测系统的需求改变。到目前为止，确保这一点的最重要的方法是编写测试，以与用户相同的方式调用被测系统；也就是说，针对其公共API而不是其实现细节进行调用。如果测试的工作方式与系统的用户相同，根据定义，破坏测试的变化也可能破坏用户。作为额外的奖励，这种测试可以作为用户的有用的例子和文档。
请看例12-1，它验证了一个事务并将其保存到数据库中。
*例12-1. 一个事务的API*.

```java
public void processTransaction(Transaction transaction) {
  if (isValid(transaction)) {
    saveToDatabase(transaction);
  }
}

private boolean isValid(Transaction t) {
  return t.getAmount() < t.getSender().getBalance();
}

private void saveToDatabase(Transaction t) {
  String s = t.getSender() + "," + t.getRecipient() + "," + t.getAmount();
  database.put(t.getId(), s);
}

public void setAccountBalance(String accountName, int balance) {
  // Write the balance to the database directly
}

public void getAccountBalance(String accountName) {
  // Read transactions from the database to determine the account balance
}
```

测试这段代码的一个诱人的方法是去掉 "私有 "可见性修饰符，直接测试实现逻辑，如例12-2所示。
*例12-2. 对交易API的实现的天真测试

```java
@Test
public void emptyAccountShouldNotBeValid() {
  assertThat(processor.isValid(newTransaction().setSender(EMPTY_ACCOUNT)))
    .isFalse();
}

@Test
public void shouldSaveSerializedData() {
  processor.saveToDatabase(newTransaction()
    .setId(123)
    .setSender("me")
    .setRecipient("you")
    .setAmount(100));
  assertThat(database.get(123)).isEqualTo("me,you,100");
}
```

这个测试与交易处理器的交互方式与真实用户的交互方式大不相同：它窥视系统的内部状态并调用系统API中没有公开的方法。因此，测试是脆弱的，几乎任何对被测系统的重构（如重命名其方法，将其分解为一个辅助类，或改变序列化格式）都会导致测试中断，即使这种变化对类的真正用户来说是看不见的。相反，同样的测试覆盖率可以通过只针对类的公共许可API进行测试来实现，如例12-3所示。<sup>2</sup>
2 这有时被称为 "先用前门 "原则。
*例12-3. 测试公共API*

```java
@Test
public void shouldTransferFunds() {
  processor.setAccountBalance("me", 150);
  processor.setAccountBalance("you", 20);

  processor.processTransaction(newTransaction()
    .setSender("me")
    .setRecipient("you")
    .setAmount(100));

  assertThat(processor.getAccountBalance("me")).isEqualTo(50);
  assertThat(processor.getAccountBalance("you")).isEqualTo(120);
}

@Test
public void shouldNotPerformInvalidTransactions() {
  processor.setAccountBalance("me", 50);
  processor.setAccountBalance("you", 20);

  processor.processTransaction(newTransaction()
    .setSender("me")
    .setRecipient("you")
    .setAmount(100));

  assertThat(processor.getAccountBalance("me")).isEqualTo(50);
  assertThat(processor.getAccountBalance("you")).isEqualTo(20);
}
```

根据定义，只使用公共API的测试是以其用户的方式来访问被测系统。这样的测试更现实，也更不脆，因为它们形成了明确的契约：如果这样的测试被破坏，就意味着系统的现有用户也将被破坏。只测试这些契约意味着你可以自由地对系统进行任何内部重构，而不必担心对测试进行繁琐的修改。
什么是 "公共API "并不总是很清楚，这个问题真正涉及到单元测试中的 "单元 "的核心。单元可以小到一个单独的功能，也可以大到由几个相关的包/模块组成的集合。当我们在这里说 "公共API "时，我们实际上是在谈论该单元暴露给拥有该代码的团队之外的第三方的API。这并不总是与某些编程语言提供的可见性概念一致；例如，Java中的类可能将自己定义为 "公共"，以便被同一单元中的其他包所访问，但并不打算供该单元之外的其他方使用。一些语言，如Python，没有内置的可见性概念（通常依赖于惯例，如在私有方法名称前加上下划线），而像Bazel这样的构建系统可以进一步限制谁被允许依赖由编程语言声明的公共API。
定义一个单元的适当范围，以及什么应该被认为是公共API，更多的是艺术而不是科学，但这里有一些经验法则。

- 如果一个方法或类的存在只是为了支持一两个其他的类（即，它是一个 "帮助类"），它可能不应该被认为是自己的单元，它的功能应该通过这些类而不是直接测试。
- 如果一个包或类被设计成任何人都可以访问，而不需要咨询它的所有者，那么它几乎肯定构成了一个应该被直接测试的单元，它的测试以与用户相同的方式访问该单元。
- 如果一个包或类只能由拥有它的人访问，但它被设计为提供在一系列情况下有用的一般功能（即，它是一个 "支持库"），它也应该被视为一个单元并直接测试。这通常会在测试中产生一些冗余，因为支持库的代码会被它自己的测试和用户的测试所覆盖。然而，这样的冗余是有价值的：如果没有它，如果库的一个用户（和它的测试）被删除，测试覆盖率就会出现缺口。

在谷歌，我们发现工程师有时需要被说服，通过公共API进行测试比针对实现细节进行测试要好。这种不情愿的态度是可以理解的，因为写测试的重点往往是你刚刚写的那段代码，而不是弄清楚这段代码是如何影响整个系统的。然而，我们发现鼓励这种做法是很有价值的，因为额外的前期努力在减少维护负担方面得到了许多倍的回报。对公共API进行测试并不能完全防止脆性，但这是你能做的最重要的事情，以确保你的测试只在系统发生意外变化时失败。

### 测试状态，而不是交互

测试通常依赖于实现细节的另一种方式，不是测试调用系统的哪些方法，而是如何验证这些调用的结果。一般来说，有两种方法来验证被测系统的行为是否符合预期。通过状态测试，你观察系统本身，看它在被调用后是什么样子。通过交互测试，你要检查系统是否对其合作者采取了预期的行动序列，以响应调用它。许多测试将执行状态和交互验证的组合。
交互测试往往比状态测试更脆，原因与测试一个私有方法比测试一个公共方法更脆的原因相同：交互测试检查一个系统是如何得到其结果的，而通常你应该只关心结果是什么。例12-4说明了一个使用测试替身（在第13章进一步解释）来验证系统如何与数据库交互的测试。
*例12-4. 脆性交互测试*

```java
@Test
public void shouldWriteToDatabase() {
  accounts.createUser("foobar");
  verify(database).put("foobar");
}
```

该测试验证了针对数据库API的特定调用，但有几种不同的方式可能出错。

- 如果被测系统中的一个错误导致记录在写入后不久就从数据库中删除，测试就会通过，尽管我们希望它失败。
- 如果被测系统被重构，调用一个稍微不同的API来写一个等效的记录，测试将失败，即使我们希望它通过。

如例12-5所示，直接对系统的状态进行测试就不那么脆了。
*例12-5. 针对状态的测试*

```java
@Test
public void shouldCreateUsers() {
  accounts.createUser("foobar");
  assertThat(accounts.getUser("foobar")).isNotNull();
}
```

这个测试更准确地表达了我们所关心的：被测系统与之交互后的状态。